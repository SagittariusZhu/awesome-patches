diff --git a/node_modules/gg-editor/es/common/CommandManager/index.d.ts b/node_modules/gg-editor/es/common/CommandManager/index.d.ts
new file mode 100644
index 0000000..49795d5
--- /dev/null
+++ b/node_modules/gg-editor/es/common/CommandManager/index.d.ts
@@ -0,0 +1,18 @@
+import { Graph, Command } from '../../../es/common/interfaces';
+declare class CommandManager {
+    command: {
+        [propName: string]: Command;
+    };
+    commandQueue: Command[];
+    commandIndex: number;
+    constructor();
+    /** 注册命令 */
+    register(name: string, command: Command): void;
+    /** 执行命令 */
+    execute(graph: Graph, name: string, params?: object): void;
+    /** 判断是否可以执行 */
+    canExecute(graph: Graph, name: string): boolean;
+    /** 注入是否应该执行 */
+    injectShouldExecute(name: string, shouldExecute: (graph: Graph) => boolean): void;
+}
+export default CommandManager;
diff --git a/node_modules/gg-editor/es/common/CommandManager/index.js b/node_modules/gg-editor/es/common/CommandManager/index.js
new file mode 100644
index 0000000..d197174
--- /dev/null
+++ b/node_modules/gg-editor/es/common/CommandManager/index.js
@@ -0,0 +1,102 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+import cloneDeep from 'lodash/cloneDeep';
+import { getGraphState } from '../../../es/utils';
+import { EditorEvent } from '../../../es/common/constants';
+
+var CommandManager = /*#__PURE__*/function () {
+  function CommandManager() {
+    _classCallCheck(this, CommandManager);
+
+    this.command = {};
+    this.commandQueue = [];
+    this.commandIndex = 0;
+  }
+  /** 注册命令 */
+
+
+  _createClass(CommandManager, [{
+    key: "register",
+    value: function register(name, command) {
+      this.command[name] = _objectSpread(_objectSpread({}, command), {}, {
+        name: name
+      });
+    }
+    /** 执行命令 */
+
+  }, {
+    key: "execute",
+    value: function execute(graph, name, params) {
+      var Command = this.command[name];
+
+      if (!Command) {
+        return;
+      }
+
+      var command = Object.create(Command);
+      command.params = cloneDeep(Command.params);
+
+      if (params) {
+        command.params = _objectSpread(_objectSpread({}, command.params), params);
+      }
+
+      if (!command.canExecute(graph)) {
+        return;
+      }
+
+      if (!command.shouldExecute(graph)) {
+        return;
+      }
+
+      command.init(graph);
+      graph.emit(EditorEvent.onBeforeExecuteCommand, {
+        name: command.name,
+        params: command.params
+      });
+      command.execute(graph);
+      graph.emit(EditorEvent.onAfterExecuteCommand, {
+        name: command.name,
+        params: command.params
+      });
+
+      if (command.canUndo(graph)) {
+        var commandQueue = this.commandQueue,
+            commandIndex = this.commandIndex;
+        commandQueue.splice(commandIndex, commandQueue.length - commandIndex, command);
+        this.commandIndex += 1;
+      }
+
+      graph.emit(EditorEvent.onGraphStateChange, {
+        graphState: getGraphState(graph)
+      });
+    }
+    /** 判断是否可以执行 */
+
+  }, {
+    key: "canExecute",
+    value: function canExecute(graph, name) {
+      return this.command[name].canExecute(graph);
+    }
+    /** 注入是否应该执行 */
+
+  }, {
+    key: "injectShouldExecute",
+    value: function injectShouldExecute(name, shouldExecute) {
+      this.command[name].shouldExecute = shouldExecute;
+    }
+  }]);
+
+  return CommandManager;
+}();
+
+export default CommandManager;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/common/behaviorManager/index.d.ts b/node_modules/gg-editor/es/common/behaviorManager/index.d.ts
new file mode 100644
index 0000000..51fabf8
--- /dev/null
+++ b/node_modules/gg-editor/es/common/behaviorManager/index.d.ts
@@ -0,0 +1,13 @@
+import { GraphType } from '../../../es/common/constants';
+import { Behavior } from '../../../es/common/interfaces';
+declare class BehaviorManager {
+    behaviors: {
+        [propName: string]: Behavior;
+    };
+    constructor();
+    getRegisteredBehaviors(type: GraphType): {};
+    wrapEventHandler(type: GraphType, behavior: Behavior): Behavior;
+    register(name: string, behavior: Behavior): void;
+}
+declare const _default: BehaviorManager;
+export default _default;
diff --git a/node_modules/gg-editor/es/common/behaviorManager/index.js b/node_modules/gg-editor/es/common/behaviorManager/index.js
new file mode 100644
index 0000000..4cf3d7c
--- /dev/null
+++ b/node_modules/gg-editor/es/common/behaviorManager/index.js
@@ -0,0 +1,90 @@
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+import G6 from '@antv/g6';
+import { isMind } from '../../../es/utils';
+import { GraphType } from '../../../es/common/constants';
+
+var BehaviorManager = /*#__PURE__*/function () {
+  function BehaviorManager() {
+    _classCallCheck(this, BehaviorManager);
+
+    this.behaviors = {};
+  }
+
+  _createClass(BehaviorManager, [{
+    key: "getRegisteredBehaviors",
+    value: function getRegisteredBehaviors(type) {
+      var _this = this;
+
+      var registeredBehaviors = {};
+      Object.keys(this.behaviors).forEach(function (name) {
+        var behavior = _this.behaviors[name];
+        var graphType = behavior.graphType;
+
+        if (graphType && graphType !== type) {
+          return;
+        }
+
+        var _behavior$graphMode = behavior.graphMode,
+            graphMode = _behavior$graphMode === void 0 ? 'default' : _behavior$graphMode;
+
+        if (!registeredBehaviors[graphMode]) {
+          registeredBehaviors[graphMode] = {};
+        }
+
+        registeredBehaviors[graphMode][name] = name;
+      });
+      return registeredBehaviors;
+    }
+  }, {
+    key: "wrapEventHandler",
+    value: function wrapEventHandler(type, behavior) {
+      var events = behavior.getEvents();
+      Object.keys(events).forEach(function (event) {
+        var handlerName = events[event];
+        var handler = behavior[handlerName];
+
+        behavior[handlerName] = function () {
+          var graph = this.graph;
+
+          if (type === GraphType.Flow && isMind(graph) === false || type === GraphType.Mind && isMind(graph)) {
+            for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
+              params[_key] = arguments[_key];
+            }
+
+            handler.apply(this, params);
+          }
+        };
+      });
+      return behavior;
+    }
+  }, {
+    key: "register",
+    value: function register(name, behavior) {
+      var graphType = behavior.graphType;
+      this.behaviors[name] = behavior;
+
+      switch (graphType) {
+        case GraphType.Flow:
+          G6.registerBehavior(name, this.wrapEventHandler(GraphType.Flow, behavior));
+          break;
+
+        case GraphType.Mind:
+          G6.registerBehavior(name, this.wrapEventHandler(GraphType.Mind, behavior));
+          break;
+
+        default:
+          G6.registerBehavior(name, behavior);
+          break;
+      }
+    }
+  }]);
+
+  return BehaviorManager;
+}();
+
+export default new BehaviorManager();
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/common/constants/index.d.ts b/node_modules/gg-editor/es/common/constants/index.d.ts
new file mode 100644
index 0000000..fdeafe6
--- /dev/null
+++ b/node_modules/gg-editor/es/common/constants/index.d.ts
@@ -0,0 +1,251 @@
+export declare const FLOW_CONTAINER_ID = "J_FlowContainer";
+export declare const MIND_CONTAINER_ID = "J_MindContainer";
+export declare const LABEL_DEFAULT_TEXT = "\u65B0\u5EFA\u8282\u70B9";
+export declare enum RendererType {
+    Canvas = "canvas",
+    Svg = "svg"
+}
+export declare enum ItemType {
+    Node = "node",
+    Edge = "edge"
+}
+export declare enum ItemState {
+    Active = "active",
+    ActiveAnchorPoints = "activeAnchorPoints",
+    Selected = "selected",
+    HighLight = "highLight",
+    Error = "error"
+}
+export declare enum GraphType {
+    Flow = "flow",
+    Mind = "mind"
+}
+export declare enum GraphMode {
+    Default = "default",
+    AddNode = "addNode",
+    Readonly = "readonly"
+}
+export declare enum GraphState {
+    NodeSelected = "nodeSelected",
+    EdgeSelected = "edgeSelected",
+    MultiSelected = "multiSelected",
+    CanvasSelected = "canvasSelected"
+}
+export declare enum LabelState {
+    Hide = "hide",
+    Show = "show"
+}
+export declare enum AnchorPointState {
+    Enabled = "enabled",
+    Disabled = "disabled"
+}
+export declare enum EditorEvent {
+    /** 调用命令之前触发 */
+    onBeforeExecuteCommand = "onBeforeExecuteCommand",
+    /** 调用命令之后触发 */
+    onAfterExecuteCommand = "onAfterExecuteCommand",
+    /** 改变画面状态触发 */
+    onGraphStateChange = "onGraphStateChange",
+    /** 改变标签状态触发 */
+    onLabelStateChange = "onLabelStateChange"
+}
+export declare enum EditorCommand {
+    /** 撤销 */
+    Undo = "undo",
+    /** 重做 */
+    Redo = "redo",
+    /** 添加 */
+    Add = "add",
+    /** 更新 */
+    Update = "update",
+    /** 删除 */
+    Remove = "remove",
+    /** 复制 */
+    Copy = "copy",
+    /** 粘贴 */
+    Paste = "paste",
+    /** 粘贴到这里 */
+    PasteHere = "pasteHere",
+    /** 放大 */
+    ZoomIn = "zoomIn",
+    /** 缩小 */
+    ZoomOut = "zoomOut",
+    /** 插入主题 */
+    Topic = "topic",
+    /** 插入子主题 */
+    Subtopic = "subtopic",
+    /** 收起 */
+    Fold = "fold",
+    /** 展开 */
+    Unfold = "unfold"
+}
+export declare enum GraphCommonEvent {
+    /** 单击鼠标左键或者按下回车键时触发 */
+    onClick = "click",
+    /** 双击鼠标左键时触发 */
+    onDoubleClick = "dblclick",
+    /** 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 */
+    onMouseEnter = "mouseenter",
+    /** 鼠标在元素内部移到时不断触发，不能通过键盘触发 */
+    onMouseMove = "mousemove",
+    /** 鼠标移出目标元素后触发 */
+    onMouseOut = "mouseout",
+    /** 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 */
+    onMouseOver = "mouseover",
+    /** 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 */
+    onMouseLeave = "mouseleave",
+    /** 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 */
+    onMouseDown = "mousedown",
+    /** 鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+    onMouseUp = "mouseup",
+    /** 用户右击鼠标时触发并打开上下文菜单 */
+    onContextMenu = "contextmenu",
+    /** 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 */
+    onDragStart = "dragstart",
+    /** 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 */
+    onDrag = "drag",
+    /** 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 */
+    onDragEnd = "dragend",
+    /** 当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+    onDragEnter = "dragenter",
+    /** 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+    onDragLeave = "dragleave",
+    /** 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
+    onDrop = "drop",
+    /** 按下键盘键触发该事件 */
+    onKeyDown = "keydown",
+    /** 释放键盘键触发该事件 */
+    onKeyUp = "keyup",
+    /** 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 */
+    onTouchStart = "touchstart",
+    /** 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault() 事件可以阻止滚动。 */
+    onTouchMove = "touchmove",
+    /** 当手指从屏幕上离开的时候触发 */
+    onTouchEnd = "touchend"
+}
+export declare enum GraphNodeEvent {
+    /** 鼠标左键单击节点时触发 */
+    onNodeClick = "node:click",
+    /** 鼠标双击左键节点时触发 */
+    onNodeDoubleClick = "node:dblclick",
+    /** 鼠标移入节点时触发 */
+    onNodeMouseEnter = "node:mouseenter",
+    /** 鼠标在节点内部移到时不断触发，不能通过键盘触发 */
+    onNodeMouseMove = "node:mousemove",
+    /** 鼠标移出节点后触发 */
+    onNodeMouseOut = "node:mouseout",
+    /** 鼠标移入节点上方时触发 */
+    onNodeMouseOver = "node:mouseover",
+    /** 鼠标移出节点时触发 */
+    onNodeMouseLeave = "node:mouseleave",
+    /** 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 */
+    onNodeMouseDown = "node:mousedown",
+    /** 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+    onNodeMouseUp = "node:mouseup",
+    /** 用户在节点上右击鼠标时触发并打开右键菜单 */
+    onNodeContextMenu = "node:contextmenu",
+    /** 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 */
+    onNodeDragStart = "node:dragstart",
+    /** 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 */
+    onNodeDrag = "node:drag",
+    /** 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 */
+    onNodeDragEnd = "node:dragend",
+    /** 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+    onNodeDragEnter = "node:dragenter",
+    /** 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+    onNodeDragLeave = "node:dragleave",
+    /** 被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
+    onNodeDrop = "node:drop"
+}
+export declare enum GraphEdgeEvent {
+    /** 鼠标左键单击边时触发 */
+    onEdgeClick = "edge:click",
+    /** 鼠标双击左键边时触发 */
+    onEdgeDoubleClick = "edge:dblclick",
+    /** 鼠标移入边时触发 */
+    onEdgeMouseEnter = "edge:mouseenter",
+    /** 鼠标在边上移到时不断触发，不能通过键盘触发 */
+    onEdgeMouseMove = "edge:mousemove",
+    /** 鼠标移出边后触发 */
+    onEdgeMouseOut = "edge:mouseout",
+    /** 鼠标移入边上方时触发 */
+    onEdgeMouseOver = "edge:mouseover",
+    /** 鼠标移出边时触发 */
+    onEdgeMouseLeave = "edge:mouseleave",
+    /** 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 */
+    onEdgeMouseDown = "edge:mousedown",
+    /** 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+    onEdgeMouseUp = "edge:mouseup",
+    /** 用户在边上右击鼠标时触发并打开右键菜单 */
+    onEdgeContextMenu = "edge:contextmenu"
+}
+export declare enum GraphCanvasEvent {
+    /** 鼠标左键单击画布时触发 */
+    onCanvasClick = "canvas:click",
+    /** 鼠标双击左键画布时触发 */
+    onCanvasDoubleClick = "canvas:dblclick",
+    /** 鼠标移入画布时触发 */
+    onCanvasMouseEnter = "canvas:mouseenter",
+    /** 鼠标在画布内部移到时不断触发，不能通过键盘触发 */
+    onCanvasMouseMove = "canvas:mousemove",
+    /** 鼠标移出画布后触发 */
+    onCanvasMouseOut = "canvas:mouseout",
+    /** 鼠标移入画布上方时触发 */
+    onCanvasMouseOver = "canvas:mouseover",
+    /** 鼠标移出画布时触发 */
+    onCanvasMouseLeave = "canvas:mouseleave",
+    /** 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 */
+    onCanvasMouseDown = "canvas:mousedown",
+    /** 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+    onCanvasMouseUp = "canvas:mouseup",
+    /** 用户在画布上右击鼠标时触发并打开右键菜单 */
+    onCanvasContextMenu = "canvas:contextmenu",
+    /** 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 */
+    onCanvasDragStart = "canvas:dragstart",
+    /** 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 */
+    onCanvasDrag = "canvas:drag",
+    /** 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 */
+    onCanvasDragEnd = "canvas:dragend",
+    /** 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+    onCanvasDragEnter = "canvas:dragenter",
+    /** 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+    onCanvasDragLeave = "canvas:dragleave"
+}
+export declare enum GraphCustomEvent {
+    /** 调用 add / addItem 方法之前触发 */
+    onBeforeAddItem = "beforeadditem",
+    /** 调用 add / addItem 方法之后触发 */
+    onAfterAddItem = "afteradditem",
+    /** 调用 remove / removeItem 方法之前触发 */
+    onBeforeRemoveItem = "beforeremoveitem",
+    /** 调用 remove / removeItem 方法之后触发 */
+    onAfterRemoveItem = "afterremoveitem",
+    /** 调用 update / updateItem 方法之前触发 */
+    onBeforeUpdateItem = "beforeupdateitem",
+    /** 调用 update / updateItem 方法之后触发 */
+    onAfterUpdateItem = "afterupdateitem",
+    /** 调用 showItem / hideItem 方法之前触发 */
+    onBeforeItemVisibilityChange = "beforeitemvisibilitychange",
+    /** 调用 showItem / hideItem 方法之后触发 */
+    onAfterItemVisibilityChange = "afteritemvisibilitychange",
+    /** 调用 setItemState 方法之前触发 */
+    onBeforeItemStateChange = "beforeitemstatechange",
+    /** 调用 setItemState 方法之后触发 */
+    onAfterItemStateChange = "afteritemstatechange",
+    /** 调用 refreshItem 方法之前触发 */
+    onBeforeRefreshItem = "beforerefreshitem",
+    /** 调用 refreshItem 方法之后触发 */
+    onAfterRefreshItem = "afterrefreshitem",
+    /** 调用 clearItemStates 方法之前触发 */
+    onBeforeItemStatesClear = "beforeitemstatesclear",
+    /** 调用 clearItemStates 方法之后触发 */
+    onAfterItemStatesClear = "afteritemstatesclear",
+    /** 布局前触发。调用 render 时会进行布局，因此 render 时会触发。或用户主动调用图的 layout 时触发 */
+    onBeforeLayout = "beforelayout",
+    /** 布局完成后触发。调用 render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 layout 时布局完成后触发 */
+    onAfterLayout = "afterlayout",
+    /** 连线完成之前触发 */
+    onBeforeConnect = "beforeconnect",
+    /** 连线完成之后触发 */
+    onAfterConnect = "afterconnect"
+}
diff --git a/node_modules/gg-editor/es/common/constants/index.js b/node_modules/gg-editor/es/common/constants/index.js
new file mode 100644
index 0000000..07ebfad
--- /dev/null
+++ b/node_modules/gg-editor/es/common/constants/index.js
@@ -0,0 +1,386 @@
+export var FLOW_CONTAINER_ID = 'J_FlowContainer';
+export var MIND_CONTAINER_ID = 'J_MindContainer';
+export var LABEL_DEFAULT_TEXT = '新建节点';
+export var RendererType;
+
+(function (RendererType) {
+  RendererType["Canvas"] = "canvas";
+  RendererType["Svg"] = "svg";
+})(RendererType || (RendererType = {}));
+
+export var ItemType;
+
+(function (ItemType) {
+  ItemType["Node"] = "node";
+  ItemType["Edge"] = "edge";
+})(ItemType || (ItemType = {}));
+
+export var ItemState;
+
+(function (ItemState) {
+  ItemState["Active"] = "active";
+  ItemState["ActiveAnchorPoints"] = "activeAnchorPoints";
+  ItemState["Selected"] = "selected";
+  ItemState["HighLight"] = "highLight";
+  ItemState["Error"] = "error";
+})(ItemState || (ItemState = {}));
+
+export var GraphType;
+
+(function (GraphType) {
+  GraphType["Flow"] = "flow";
+  GraphType["Mind"] = "mind";
+})(GraphType || (GraphType = {}));
+
+export var GraphMode;
+
+(function (GraphMode) {
+  GraphMode["Default"] = "default";
+  GraphMode["AddNode"] = "addNode";
+  GraphMode["Readonly"] = "readonly";
+})(GraphMode || (GraphMode = {}));
+
+export var GraphState;
+
+(function (GraphState) {
+  GraphState["NodeSelected"] = "nodeSelected";
+  GraphState["EdgeSelected"] = "edgeSelected";
+  GraphState["MultiSelected"] = "multiSelected";
+  GraphState["CanvasSelected"] = "canvasSelected";
+})(GraphState || (GraphState = {}));
+
+export var LabelState;
+
+(function (LabelState) {
+  LabelState["Hide"] = "hide";
+  LabelState["Show"] = "show";
+})(LabelState || (LabelState = {}));
+
+export var AnchorPointState;
+
+(function (AnchorPointState) {
+  AnchorPointState["Enabled"] = "enabled";
+  AnchorPointState["Disabled"] = "disabled";
+})(AnchorPointState || (AnchorPointState = {}));
+
+export var EditorEvent;
+
+(function (EditorEvent) {
+  /** 调用命令之前触发 */
+  EditorEvent["onBeforeExecuteCommand"] = "onBeforeExecuteCommand";
+  /** 调用命令之后触发 */
+
+  EditorEvent["onAfterExecuteCommand"] = "onAfterExecuteCommand";
+  /** 改变画面状态触发 */
+
+  EditorEvent["onGraphStateChange"] = "onGraphStateChange";
+  /** 改变标签状态触发 */
+
+  EditorEvent["onLabelStateChange"] = "onLabelStateChange";
+})(EditorEvent || (EditorEvent = {}));
+
+export var EditorCommand;
+
+(function (EditorCommand) {
+  /** 撤销 */
+  EditorCommand["Undo"] = "undo";
+  /** 重做 */
+
+  EditorCommand["Redo"] = "redo";
+  /** 添加 */
+
+  EditorCommand["Add"] = "add";
+  /** 更新 */
+
+  EditorCommand["Update"] = "update";
+  /** 删除 */
+
+  EditorCommand["Remove"] = "remove";
+  /** 复制 */
+
+  EditorCommand["Copy"] = "copy";
+  /** 粘贴 */
+
+  EditorCommand["Paste"] = "paste";
+  /** 粘贴到这里 */
+
+  EditorCommand["PasteHere"] = "pasteHere";
+  /** 放大 */
+
+  EditorCommand["ZoomIn"] = "zoomIn";
+  /** 缩小 */
+
+  EditorCommand["ZoomOut"] = "zoomOut";
+  /** 插入主题 */
+
+  EditorCommand["Topic"] = "topic";
+  /** 插入子主题 */
+
+  EditorCommand["Subtopic"] = "subtopic";
+  /** 收起 */
+
+  EditorCommand["Fold"] = "fold";
+  /** 展开 */
+
+  EditorCommand["Unfold"] = "unfold";
+})(EditorCommand || (EditorCommand = {}));
+
+export var GraphCommonEvent;
+
+(function (GraphCommonEvent) {
+  /** 单击鼠标左键或者按下回车键时触发 */
+  GraphCommonEvent["onClick"] = "click";
+  /** 双击鼠标左键时触发 */
+
+  GraphCommonEvent["onDoubleClick"] = "dblclick";
+  /** 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 */
+
+  GraphCommonEvent["onMouseEnter"] = "mouseenter";
+  /** 鼠标在元素内部移到时不断触发，不能通过键盘触发 */
+
+  GraphCommonEvent["onMouseMove"] = "mousemove";
+  /** 鼠标移出目标元素后触发 */
+
+  GraphCommonEvent["onMouseOut"] = "mouseout";
+  /** 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 */
+
+  GraphCommonEvent["onMouseOver"] = "mouseover";
+  /** 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 */
+
+  GraphCommonEvent["onMouseLeave"] = "mouseleave";
+  /** 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphCommonEvent["onMouseDown"] = "mousedown";
+  /** 鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphCommonEvent["onMouseUp"] = "mouseup";
+  /** 用户右击鼠标时触发并打开上下文菜单 */
+
+  GraphCommonEvent["onContextMenu"] = "contextmenu";
+  /** 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 */
+
+  GraphCommonEvent["onDragStart"] = "dragstart";
+  /** 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 */
+
+  GraphCommonEvent["onDrag"] = "drag";
+  /** 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 */
+
+  GraphCommonEvent["onDragEnd"] = "dragend";
+  /** 当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCommonEvent["onDragEnter"] = "dragenter";
+  /** 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCommonEvent["onDragLeave"] = "dragleave";
+  /** 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
+
+  GraphCommonEvent["onDrop"] = "drop";
+  /** 按下键盘键触发该事件 */
+
+  GraphCommonEvent["onKeyDown"] = "keydown";
+  /** 释放键盘键触发该事件 */
+
+  GraphCommonEvent["onKeyUp"] = "keyup";
+  /** 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 */
+
+  GraphCommonEvent["onTouchStart"] = "touchstart";
+  /** 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault() 事件可以阻止滚动。 */
+
+  GraphCommonEvent["onTouchMove"] = "touchmove";
+  /** 当手指从屏幕上离开的时候触发 */
+
+  GraphCommonEvent["onTouchEnd"] = "touchend";
+})(GraphCommonEvent || (GraphCommonEvent = {}));
+
+export var GraphNodeEvent;
+
+(function (GraphNodeEvent) {
+  /** 鼠标左键单击节点时触发 */
+  GraphNodeEvent["onNodeClick"] = "node:click";
+  /** 鼠标双击左键节点时触发 */
+
+  GraphNodeEvent["onNodeDoubleClick"] = "node:dblclick";
+  /** 鼠标移入节点时触发 */
+
+  GraphNodeEvent["onNodeMouseEnter"] = "node:mouseenter";
+  /** 鼠标在节点内部移到时不断触发，不能通过键盘触发 */
+
+  GraphNodeEvent["onNodeMouseMove"] = "node:mousemove";
+  /** 鼠标移出节点后触发 */
+
+  GraphNodeEvent["onNodeMouseOut"] = "node:mouseout";
+  /** 鼠标移入节点上方时触发 */
+
+  GraphNodeEvent["onNodeMouseOver"] = "node:mouseover";
+  /** 鼠标移出节点时触发 */
+
+  GraphNodeEvent["onNodeMouseLeave"] = "node:mouseleave";
+  /** 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphNodeEvent["onNodeMouseDown"] = "node:mousedown";
+  /** 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphNodeEvent["onNodeMouseUp"] = "node:mouseup";
+  /** 用户在节点上右击鼠标时触发并打开右键菜单 */
+
+  GraphNodeEvent["onNodeContextMenu"] = "node:contextmenu";
+  /** 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 */
+
+  GraphNodeEvent["onNodeDragStart"] = "node:dragstart";
+  /** 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 */
+
+  GraphNodeEvent["onNodeDrag"] = "node:drag";
+  /** 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 */
+
+  GraphNodeEvent["onNodeDragEnd"] = "node:dragend";
+  /** 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphNodeEvent["onNodeDragEnter"] = "node:dragenter";
+  /** 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphNodeEvent["onNodeDragLeave"] = "node:dragleave";
+  /** 被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
+
+  GraphNodeEvent["onNodeDrop"] = "node:drop";
+})(GraphNodeEvent || (GraphNodeEvent = {}));
+
+export var GraphEdgeEvent;
+
+(function (GraphEdgeEvent) {
+  /** 鼠标左键单击边时触发 */
+  GraphEdgeEvent["onEdgeClick"] = "edge:click";
+  /** 鼠标双击左键边时触发 */
+
+  GraphEdgeEvent["onEdgeDoubleClick"] = "edge:dblclick";
+  /** 鼠标移入边时触发 */
+
+  GraphEdgeEvent["onEdgeMouseEnter"] = "edge:mouseenter";
+  /** 鼠标在边上移到时不断触发，不能通过键盘触发 */
+
+  GraphEdgeEvent["onEdgeMouseMove"] = "edge:mousemove";
+  /** 鼠标移出边后触发 */
+
+  GraphEdgeEvent["onEdgeMouseOut"] = "edge:mouseout";
+  /** 鼠标移入边上方时触发 */
+
+  GraphEdgeEvent["onEdgeMouseOver"] = "edge:mouseover";
+  /** 鼠标移出边时触发 */
+
+  GraphEdgeEvent["onEdgeMouseLeave"] = "edge:mouseleave";
+  /** 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphEdgeEvent["onEdgeMouseDown"] = "edge:mousedown";
+  /** 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphEdgeEvent["onEdgeMouseUp"] = "edge:mouseup";
+  /** 用户在边上右击鼠标时触发并打开右键菜单 */
+
+  GraphEdgeEvent["onEdgeContextMenu"] = "edge:contextmenu";
+})(GraphEdgeEvent || (GraphEdgeEvent = {}));
+
+export var GraphCanvasEvent;
+
+(function (GraphCanvasEvent) {
+  /** 鼠标左键单击画布时触发 */
+  GraphCanvasEvent["onCanvasClick"] = "canvas:click";
+  /** 鼠标双击左键画布时触发 */
+
+  GraphCanvasEvent["onCanvasDoubleClick"] = "canvas:dblclick";
+  /** 鼠标移入画布时触发 */
+
+  GraphCanvasEvent["onCanvasMouseEnter"] = "canvas:mouseenter";
+  /** 鼠标在画布内部移到时不断触发，不能通过键盘触发 */
+
+  GraphCanvasEvent["onCanvasMouseMove"] = "canvas:mousemove";
+  /** 鼠标移出画布后触发 */
+
+  GraphCanvasEvent["onCanvasMouseOut"] = "canvas:mouseout";
+  /** 鼠标移入画布上方时触发 */
+
+  GraphCanvasEvent["onCanvasMouseOver"] = "canvas:mouseover";
+  /** 鼠标移出画布时触发 */
+
+  GraphCanvasEvent["onCanvasMouseLeave"] = "canvas:mouseleave";
+  /** 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphCanvasEvent["onCanvasMouseDown"] = "canvas:mousedown";
+  /** 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphCanvasEvent["onCanvasMouseUp"] = "canvas:mouseup";
+  /** 用户在画布上右击鼠标时触发并打开右键菜单 */
+
+  GraphCanvasEvent["onCanvasContextMenu"] = "canvas:contextmenu";
+  /** 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 */
+
+  GraphCanvasEvent["onCanvasDragStart"] = "canvas:dragstart";
+  /** 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 */
+
+  GraphCanvasEvent["onCanvasDrag"] = "canvas:drag";
+  /** 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 */
+
+  GraphCanvasEvent["onCanvasDragEnd"] = "canvas:dragend";
+  /** 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCanvasEvent["onCanvasDragEnter"] = "canvas:dragenter";
+  /** 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCanvasEvent["onCanvasDragLeave"] = "canvas:dragleave";
+})(GraphCanvasEvent || (GraphCanvasEvent = {}));
+
+export var GraphCustomEvent;
+
+(function (GraphCustomEvent) {
+  /** 调用 add / addItem 方法之前触发 */
+  GraphCustomEvent["onBeforeAddItem"] = "beforeadditem";
+  /** 调用 add / addItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterAddItem"] = "afteradditem";
+  /** 调用 remove / removeItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeRemoveItem"] = "beforeremoveitem";
+  /** 调用 remove / removeItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterRemoveItem"] = "afterremoveitem";
+  /** 调用 update / updateItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeUpdateItem"] = "beforeupdateitem";
+  /** 调用 update / updateItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterUpdateItem"] = "afterupdateitem";
+  /** 调用 showItem / hideItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeItemVisibilityChange"] = "beforeitemvisibilitychange";
+  /** 调用 showItem / hideItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterItemVisibilityChange"] = "afteritemvisibilitychange";
+  /** 调用 setItemState 方法之前触发 */
+
+  GraphCustomEvent["onBeforeItemStateChange"] = "beforeitemstatechange";
+  /** 调用 setItemState 方法之后触发 */
+
+  GraphCustomEvent["onAfterItemStateChange"] = "afteritemstatechange";
+  /** 调用 refreshItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeRefreshItem"] = "beforerefreshitem";
+  /** 调用 refreshItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterRefreshItem"] = "afterrefreshitem";
+  /** 调用 clearItemStates 方法之前触发 */
+
+  GraphCustomEvent["onBeforeItemStatesClear"] = "beforeitemstatesclear";
+  /** 调用 clearItemStates 方法之后触发 */
+
+  GraphCustomEvent["onAfterItemStatesClear"] = "afteritemstatesclear";
+  /** 布局前触发。调用 render 时会进行布局，因此 render 时会触发。或用户主动调用图的 layout 时触发 */
+
+  GraphCustomEvent["onBeforeLayout"] = "beforelayout";
+  /** 布局完成后触发。调用 render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 layout 时布局完成后触发 */
+
+  GraphCustomEvent["onAfterLayout"] = "afterlayout";
+  /** 连线完成之前触发 */
+
+  GraphCustomEvent["onBeforeConnect"] = "beforeconnect";
+  /** 连线完成之后触发 */
+
+  GraphCustomEvent["onAfterConnect"] = "afterconnect";
+})(GraphCustomEvent || (GraphCustomEvent = {}));
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/common/global/index.d.ts b/node_modules/gg-editor/es/common/global/index.d.ts
new file mode 100644
index 0000000..785ad4f
--- /dev/null
+++ b/node_modules/gg-editor/es/common/global/index.d.ts
@@ -0,0 +1,36 @@
+import { NodeModel } from '../../../es/common/interfaces';
+declare class Global {
+    /** 当前版本 */
+    version: string;
+    /** 埋点开关 */
+    trackable: boolean;
+    /** 剪贴板 */
+    clipboard: {
+        point: {
+            x: number;
+            y: number;
+        };
+        models: NodeModel[];
+    };
+    /** 组件数据 */
+    component: {
+        itemPanel: {
+            model: Partial<NodeModel>;
+            delegateShapeClassName: string;
+        };
+    };
+    /** 插件数据 */
+    plugin: {
+        itemPopover: {
+            state: 'show' | 'hide';
+        };
+        contextMenu: {
+            state: 'show' | 'hide';
+        };
+        editableLabel: {
+            state: 'show' | 'hide';
+        };
+    };
+}
+declare const _default: Global;
+export default _default;
diff --git a/node_modules/gg-editor/es/common/global/index.js b/node_modules/gg-editor/es/common/global/index.js
new file mode 100644
index 0000000..7fcf5cc
--- /dev/null
+++ b/node_modules/gg-editor/es/common/global/index.js
@@ -0,0 +1,45 @@
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+import { guid } from '../../../es/utils';
+
+var Global = function Global() {
+  _classCallCheck(this, Global);
+
+  /** 当前版本 */
+  this.version = process.env.GG_EDITOR_VERSION;
+  /** 埋点开关 */
+
+  this.trackable = true;
+  /** 剪贴板 */
+
+  this.clipboard = {
+    point: {
+      x: 0,
+      y: 0
+    },
+    models: []
+  };
+  /** 组件数据 */
+
+  this.component = {
+    itemPanel: {
+      model: null,
+      delegateShapeClassName: "delegateShape_".concat(guid())
+    }
+  };
+  /** 插件数据 */
+
+  this.plugin = {
+    itemPopover: {
+      state: 'hide'
+    },
+    contextMenu: {
+      state: 'hide'
+    },
+    editableLabel: {
+      state: 'hide'
+    }
+  };
+};
+
+export default new Global();
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/common/interfaces/index.d.ts b/node_modules/gg-editor/es/common/interfaces/index.d.ts
new file mode 100644
index 0000000..78482eb
--- /dev/null
+++ b/node_modules/gg-editor/es/common/interfaces/index.d.ts
@@ -0,0 +1,83 @@
+import { GraphType, GraphState, LabelState, EditorCommand, GraphCommonEvent, GraphNodeEvent, GraphEdgeEvent, GraphCanvasEvent, GraphCustomEvent } from '../../../es/common/constants';
+import IGGroup from '@antv/g-canvas/lib/group';
+import { IShape as IGShape } from '@antv/g-canvas/lib/interfaces';
+import { Graph as IGraph, TreeGraph as ITreeGraph } from '@antv/g6';
+import { IPoint, ShapeStyle as IShapeStyle, GraphData as IGraphData, TreeGraphData as ITreeGraphData, NodeConfig as INodeConfig, EdgeConfig as IEdgeConfig, BehaviorOption as IBehaviorOption, IG6GraphEvent as IGraphEvent } from '@antv/g6/lib/types';
+import { GraphOptions as IGraphOptions } from '@antv/g6/lib/types';
+import { ShapeOptions as IShapeOptions } from '@antv/g6/lib/interface/shape';
+import { INode, IEdge } from '@antv/g6/lib/interface/item';
+export interface GShape extends IGShape {
+}
+export interface GGroup extends IGGroup {
+}
+export interface Graph extends IGraph {
+}
+export interface TreeGraph extends ITreeGraph {
+}
+export interface AnchorPoint extends IPoint {
+    index: number;
+}
+export interface ShapeStyle extends IShapeStyle {
+}
+export interface FlowData extends IGraphData {
+}
+export interface MindData extends ITreeGraphData {
+}
+export interface NodeModel extends INodeConfig {
+}
+export interface EdgeModel extends IEdgeConfig {
+}
+export interface GraphEvent extends IGraphEvent {
+}
+export interface GraphOptions extends IGraphOptions {
+}
+export interface CustomShape extends IShapeOptions {
+}
+export interface CustomNode extends CustomShape {
+}
+export interface CustomEdge extends CustomShape {
+}
+export declare type Item = Node | Edge;
+export interface Node extends INode {
+}
+export interface Edge extends IEdge {
+}
+export interface Behavior extends IBehaviorOption {
+    graph?: Graph;
+    graphType?: GraphType;
+    graphMode?: string;
+    [propName: string]: any;
+}
+export interface Command<P = object, G = Graph> {
+    /** 命令名称 */
+    name: string;
+    /** 命令参数 */
+    params: P;
+    /** 是否可以执行 */
+    canExecute(graph: G): boolean;
+    /** 是否应该执行 */
+    shouldExecute(graph: G): boolean;
+    /** 是否可以撤销 */
+    canUndo(graph: G): boolean;
+    /** 初始命令 */
+    init(graph: G): void;
+    /** 执行命令 */
+    execute(graph: G): void;
+    /** 撤销命令 */
+    undo(graph: G): void;
+    /** 命令快捷键 */
+    shortcuts: string[] | string[][];
+}
+export interface CommandEvent {
+    name: EditorCommand;
+    params: object;
+}
+export interface GraphStateEvent {
+    graphState: GraphState;
+}
+export interface LabelStateEvent {
+    labelState: LabelState;
+}
+export declare type GraphNativeEvent = GraphCommonEvent | GraphNodeEvent | GraphEdgeEvent | GraphCanvasEvent | GraphCustomEvent;
+export declare type GraphReactEvent = keyof typeof GraphCommonEvent | keyof typeof GraphNodeEvent | keyof typeof GraphEdgeEvent | keyof typeof GraphCanvasEvent | keyof typeof GraphCustomEvent;
+export declare type GraphReactEventProps = Record<GraphReactEvent, (e: any) => void>;
diff --git a/node_modules/gg-editor/es/common/interfaces/index.js b/node_modules/gg-editor/es/common/interfaces/index.js
new file mode 100644
index 0000000..e69de29
diff --git a/node_modules/gg-editor/es/common/withContext/index.d.ts b/node_modules/gg-editor/es/common/withContext/index.d.ts
new file mode 100644
index 0000000..d882cd8
--- /dev/null
+++ b/node_modules/gg-editor/es/common/withContext/index.d.ts
@@ -0,0 +1,2 @@
+import React from 'react';
+export default function <CP>(Context: React.Context<CP>, shouldRender?: (context: CP) => boolean): <P extends CP, T = unknown>(WrappedComponent: React.ComponentType<P>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<Pick<React.PropsWithChildren<P>, Exclude<"children", keyof CP> | Exclude<keyof P, keyof CP>>> & React.RefAttributes<T>>;
diff --git a/node_modules/gg-editor/es/common/withContext/index.js b/node_modules/gg-editor/es/common/withContext/index.js
new file mode 100644
index 0000000..5add796
--- /dev/null
+++ b/node_modules/gg-editor/es/common/withContext/index.js
@@ -0,0 +1,38 @@
+function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
+
+function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
+
+import React from 'react';
+export default function (Context) {
+  var shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
+    return true;
+  };
+  return function (WrappedComponent) {
+    var InjectContext = function InjectContext(props) {
+      var forwardRef = props.forwardRef,
+          rest = _objectWithoutProperties(props, ["forwardRef"]);
+
+      var refProp = {};
+
+      if (WrappedComponent.prototype.isReactComponent) {
+        refProp = {
+          ref: forwardRef
+        };
+      } else {
+        refProp = {
+          forwardRef: forwardRef
+        };
+      }
+
+      return /*#__PURE__*/React.createElement(Context.Consumer, null, function (context) {
+        return shouldRender(context) ? /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({}, refProp, rest, context)) : null;
+      });
+    };
+
+    return /*#__PURE__*/React.forwardRef(function (props, ref) {
+      return /*#__PURE__*/React.createElement(InjectContext, Object.assign({
+        forwardRef: ref
+      }, props));
+    });
+  };
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Command/index.d.ts b/node_modules/gg-editor/es/components/Command/index.d.ts
new file mode 100644
index 0000000..1ce4831
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Command/index.d.ts
@@ -0,0 +1,9 @@
+import React from 'react';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+interface CommandProps extends EditorContextProps {
+    name: string;
+    className?: string;
+    disabledClassName?: string;
+}
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<CommandProps>, "children" | "className" | "name" | "disabledClassName"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/components/Command/index.js b/node_modules/gg-editor/es/components/Command/index.js
new file mode 100644
index 0000000..771b373
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Command/index.js
@@ -0,0 +1,104 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import { EditorEvent } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+
+var Command =
+/** @class */
+function () {
+  var Command = /*#__PURE__*/function (_React$Component) {
+    _inherits(Command, _React$Component);
+
+    var _super = _createSuper(Command);
+
+    function Command() {
+      var _this;
+
+      _classCallCheck(this, Command);
+
+      _this = _super.apply(this, arguments);
+      _this.state = {
+        disabled: false
+      };
+
+      _this.handleClick = function () {
+        var _this$props = _this.props,
+            name = _this$props.name,
+            executeCommand = _this$props.executeCommand;
+        executeCommand(name);
+      };
+
+      return _this;
+    }
+
+    _createClass(Command, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            name = _this$props2.name;
+        var commandManager = graph.get('commandManager');
+        this.setState({
+          disabled: !commandManager.canExecute(graph, name)
+        });
+        graph.on(EditorEvent.onGraphStateChange, function () {
+          _this2.setState({
+            disabled: !commandManager.canExecute(graph, name)
+          });
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var graph = this.props.graph;
+
+        if (!graph) {
+          return null;
+        }
+
+        var _this$props3 = this.props,
+            className = _this$props3.className,
+            disabledClassName = _this$props3.disabledClassName,
+            children = _this$props3.children;
+        var disabled = this.state.disabled;
+        return /*#__PURE__*/React.createElement("div", {
+          className: "".concat(className).concat(disabled ? " ".concat(disabledClassName) : ''),
+          onClick: this.handleClick
+        }, children);
+      }
+    }]);
+
+    return Command;
+  }(React.Component);
+
+  Command.defaultProps = {
+    className: 'command',
+    disabledClassName: 'command-disabled'
+  };
+  return Command;
+}();
+
+export default withEditorContext(Command);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/DetailPanel/index.d.ts b/node_modules/gg-editor/es/components/DetailPanel/index.d.ts
new file mode 100644
index 0000000..148808b
--- /dev/null
+++ b/node_modules/gg-editor/es/components/DetailPanel/index.d.ts
@@ -0,0 +1,13 @@
+import React from 'react';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+import { Node, Edge } from '../../../es/common/interfaces';
+declare type DetailPanelType = 'node' | 'edge' | 'multi' | 'canvas';
+export interface DetailPanelComponentProps {
+    type: DetailPanelType;
+    nodes: Node[];
+    edges: Edge[];
+}
+declare class DetailPanel {
+    static create: <P extends DetailPanelComponentProps>(type: DetailPanelType) => (WrappedComponent: React.ComponentType<P>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<Pick<React.PropsWithChildren<EditorContextProps & Pick<P, Exclude<keyof P, "type" | "nodes" | "edges">>>, "children" | Exclude<Exclude<keyof P, "type" | "nodes" | "edges">, "graph" | "executeCommand" | "commandManager">>> & React.RefAttributes<unknown>>;
+}
+export default DetailPanel;
diff --git a/node_modules/gg-editor/es/components/DetailPanel/index.js b/node_modules/gg-editor/es/components/DetailPanel/index.js
new file mode 100644
index 0000000..78e0a68
--- /dev/null
+++ b/node_modules/gg-editor/es/components/DetailPanel/index.js
@@ -0,0 +1,98 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+import React from 'react';
+import { getSelectedNodes, getSelectedEdges } from '../../../es/utils';
+import { GraphState, EditorEvent } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+
+var DetailPanel =
+/** @class */
+function () {
+  var DetailPanel = function DetailPanel() {
+    _classCallCheck(this, DetailPanel);
+  };
+
+  DetailPanel.create = function (type) {
+    return function (WrappedComponent) {
+      var TypedPanel = /*#__PURE__*/function (_React$Component) {
+        _inherits(TypedPanel, _React$Component);
+
+        var _super = _createSuper(TypedPanel);
+
+        function TypedPanel() {
+          var _this;
+
+          _classCallCheck(this, TypedPanel);
+
+          _this = _super.apply(this, arguments);
+          _this.state = {
+            graphState: GraphState.CanvasSelected
+          };
+          return _this;
+        }
+
+        _createClass(TypedPanel, [{
+          key: "componentDidMount",
+          value: function componentDidMount() {
+            var _this2 = this;
+
+            var graph = this.props.graph;
+            graph.on(EditorEvent.onGraphStateChange, function (_ref) {
+              var graphState = _ref.graphState;
+
+              _this2.setState({
+                graphState: graphState
+              });
+            });
+          }
+        }, {
+          key: "render",
+          value: function render() {
+            var graph = this.props.graph;
+            var graphState = this.state.graphState;
+
+            if (graphState !== "".concat(type, "Selected")) {
+              return null;
+            }
+
+            var nodes = getSelectedNodes(graph);
+            var edges = getSelectedEdges(graph);
+            return /*#__PURE__*/React.createElement(WrappedComponent, Object.assign({
+              type: type,
+              nodes: nodes,
+              edges: edges
+            }, this.props));
+          }
+        }]);
+
+        return TypedPanel;
+      }(React.Component);
+
+      return withEditorContext(TypedPanel);
+    };
+  };
+
+  return DetailPanel;
+}();
+
+export default DetailPanel;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Editor/index.d.ts b/node_modules/gg-editor/es/components/Editor/index.d.ts
new file mode 100644
index 0000000..7677545
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Editor/index.d.ts
@@ -0,0 +1,28 @@
+import React from 'react';
+import { EditorEvent } from '../../../es/common/constants';
+import { Graph, CommandEvent } from '../../../es/common/interfaces';
+import { EditorContextProps, EditorPrivateContextProps } from '../../../es/components/EditorContext';
+interface EditorProps {
+    style?: React.CSSProperties;
+    className?: string;
+    [EditorEvent.onBeforeExecuteCommand]?: (e: CommandEvent) => void;
+    [EditorEvent.onAfterExecuteCommand]?: (e: CommandEvent) => void;
+}
+interface EditorState extends EditorContextProps, EditorPrivateContextProps {
+}
+declare class Editor extends React.Component<EditorProps, EditorState> {
+    static setTrackable(trackable: boolean): void;
+    static defaultProps: {
+        onBeforeExecuteCommand: () => void;
+        onAfterExecuteCommand: () => void;
+    };
+    lastMousedownTarget: HTMLElement | null;
+    constructor(props: EditorProps);
+    shouldTriggerShortcut(graph: Graph, target: HTMLElement | null): boolean;
+    bindEvent(graph: Graph): void;
+    bindShortcut(graph: Graph): void;
+    setGraph: (graph: Graph) => void;
+    executeCommand: (name: string, params?: object) => void;
+    render(): JSX.Element;
+}
+export default Editor;
diff --git a/node_modules/gg-editor/es/components/Editor/index.js b/node_modules/gg-editor/es/components/Editor/index.js
new file mode 100644
index 0000000..ba20158
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Editor/index.js
@@ -0,0 +1,204 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import isArray from 'lodash/isArray';
+import pick from 'lodash/pick';
+import global from '../../../es/common/global';
+import { RendererType, EditorEvent, GraphCommonEvent } from '../../../es/common/constants';
+import CommandManager from '../../../es/common/CommandManager';
+import { EditorContext, EditorPrivateContext } from '../../../es/components/EditorContext';
+
+var Editor =
+/** @class */
+function () {
+  var _Editor$defaultProps;
+
+  var Editor = /*#__PURE__*/function (_React$Component) {
+    _inherits(Editor, _React$Component);
+
+    var _super = _createSuper(Editor);
+
+    function Editor(props) {
+      var _this;
+
+      _classCallCheck(this, Editor);
+
+      _this = _super.call(this, props);
+      _this.lastMousedownTarget = null;
+
+      _this.setGraph = function (graph) {
+        _this.setState({
+          graph: graph
+        });
+
+        _this.bindEvent(graph);
+
+        _this.bindShortcut(graph);
+      };
+
+      _this.executeCommand = function (name, params) {
+        var _this$state = _this.state,
+            graph = _this$state.graph,
+            commandManager = _this$state.commandManager;
+
+        if (graph) {
+          commandManager.execute(graph, name, params);
+        }
+      };
+
+      _this.state = {
+        graph: null,
+        setGraph: _this.setGraph,
+        executeCommand: _this.executeCommand,
+        commandManager: new CommandManager()
+      };
+      _this.lastMousedownTarget = null;
+      return _this;
+    }
+
+    _createClass(Editor, [{
+      key: "shouldTriggerShortcut",
+      value: function shouldTriggerShortcut(graph, target) {
+        var renderer = graph.get('renderer');
+        var canvasElement = graph.get('canvas').get('el');
+
+        if (!target) {
+          return false;
+        }
+
+        if (target === canvasElement) {
+          return true;
+        }
+
+        if (renderer === RendererType.Svg) {
+          if (target.nodeName === 'svg') {
+            return true;
+          }
+
+          var parentNode = target.parentNode;
+
+          while (parentNode && parentNode.nodeName !== 'BODY') {
+            if (parentNode.nodeName === 'svg') {
+              return true;
+            } else {
+              parentNode = parentNode.parentNode;
+            }
+          }
+
+          return false;
+        }
+      }
+    }, {
+      key: "bindEvent",
+      value: function bindEvent(graph) {
+        var props = this.props;
+        graph.on(EditorEvent.onBeforeExecuteCommand, props[EditorEvent.onBeforeExecuteCommand]);
+        graph.on(EditorEvent.onAfterExecuteCommand, props[EditorEvent.onAfterExecuteCommand]);
+      }
+    }, {
+      key: "bindShortcut",
+      value: function bindShortcut(graph) {
+        var _this2 = this;
+
+        var commandManager = this.state.commandManager;
+        window.addEventListener(GraphCommonEvent.onMouseDown, function (e) {
+          _this2.lastMousedownTarget = e.target;
+        });
+        graph.on(GraphCommonEvent.onKeyDown, function (e) {
+          if (!_this2.shouldTriggerShortcut(graph, _this2.lastMousedownTarget)) {
+            return;
+          }
+
+          Object.values(commandManager.command).some(function (command) {
+            var name = command.name,
+                shortcuts = command.shortcuts;
+            var flag = shortcuts.some(function (shortcut) {
+              var key = e.key;
+
+              if (!isArray(shortcut)) {
+                return shortcut === key;
+              }
+
+              return shortcut.every(function (item, index) {
+                if (index === shortcut.length - 1) {
+                  return item === key;
+                }
+
+                return e[item];
+              });
+            });
+
+            if (flag) {
+              if (commandManager.canExecute(graph, name)) {
+                // Prevent default
+                e.preventDefault(); // Execute command
+
+                _this2.executeCommand(name);
+
+                return true;
+              }
+            }
+
+            return false;
+          });
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var children = this.props.children;
+        var _this$state2 = this.state,
+            graph = _this$state2.graph,
+            setGraph = _this$state2.setGraph,
+            executeCommand = _this$state2.executeCommand,
+            commandManager = _this$state2.commandManager;
+        return /*#__PURE__*/React.createElement(EditorContext.Provider, {
+          value: {
+            graph: graph,
+            executeCommand: executeCommand,
+            commandManager: commandManager
+          }
+        }, /*#__PURE__*/React.createElement(EditorPrivateContext.Provider, {
+          value: {
+            setGraph: setGraph,
+            commandManager: commandManager
+          }
+        }, /*#__PURE__*/React.createElement("div", Object.assign({}, pick(this.props, ['className', 'style'])), children)));
+      }
+    }], [{
+      key: "setTrackable",
+      value: function setTrackable(trackable) {
+        global.trackable = trackable;
+      }
+    }]);
+
+    return Editor;
+  }(React.Component);
+
+  Editor.defaultProps = (_Editor$defaultProps = {}, _defineProperty(_Editor$defaultProps, EditorEvent.onBeforeExecuteCommand, function () {}), _defineProperty(_Editor$defaultProps, EditorEvent.onAfterExecuteCommand, function () {}), _Editor$defaultProps);
+  return Editor;
+}();
+
+export default Editor;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/EditorContext/index.d.ts b/node_modules/gg-editor/es/components/EditorContext/index.d.ts
new file mode 100644
index 0000000..13755d2
--- /dev/null
+++ b/node_modules/gg-editor/es/components/EditorContext/index.d.ts
@@ -0,0 +1,16 @@
+import React from 'react';
+import { Graph } from '../../../es/common/interfaces';
+import CommandManager from '../../../es/common/CommandManager';
+export interface EditorContextProps {
+    graph: Graph | null;
+    executeCommand: (name: string, params?: object) => void;
+    commandManager: CommandManager;
+}
+export interface EditorPrivateContextProps {
+    setGraph: (graph: Graph) => void;
+    commandManager: CommandManager;
+}
+export declare const EditorContext: React.Context<EditorContextProps>;
+export declare const EditorPrivateContext: React.Context<EditorPrivateContextProps>;
+export declare const withEditorContext: <P extends EditorContextProps, T = unknown>(WrappedComponent: React.ComponentType<P>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<Pick<React.PropsWithChildren<P>, "children" | Exclude<keyof P, "graph" | "executeCommand" | "commandManager">>> & React.RefAttributes<T>>;
+export declare const withEditorPrivateContext: <P extends EditorPrivateContextProps, T = unknown>(WrappedComponent: React.ComponentType<P>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<Pick<React.PropsWithChildren<P>, "children" | Exclude<keyof P, "commandManager" | "setGraph">>> & React.RefAttributes<T>>;
diff --git a/node_modules/gg-editor/es/components/EditorContext/index.js b/node_modules/gg-editor/es/components/EditorContext/index.js
new file mode 100644
index 0000000..03e05c2
--- /dev/null
+++ b/node_modules/gg-editor/es/components/EditorContext/index.js
@@ -0,0 +1,8 @@
+import React from 'react';
+import withContext from '../../../es/common/withContext';
+export var EditorContext = React.createContext({});
+export var EditorPrivateContext = React.createContext({});
+export var withEditorContext = withContext(EditorContext, function (context) {
+  return !!context.graph;
+});
+export var withEditorPrivateContext = withContext(EditorPrivateContext);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Flow/behavior/dragAddEdge.d.ts b/node_modules/gg-editor/es/components/Flow/behavior/dragAddEdge.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/behavior/dragAddEdge.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/components/Flow/behavior/dragAddEdge.js b/node_modules/gg-editor/es/components/Flow/behavior/dragAddEdge.js
new file mode 100644
index 0000000..88c52fa
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/behavior/dragAddEdge.js
@@ -0,0 +1,246 @@
+import _merge from "lodash/merge";
+import _isPlainObject from "lodash/isPlainObject";
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+import { guid } from '../../../../es/utils';
+import { ItemType, ItemState, GraphType, AnchorPointState } from '../../../../es/common/constants';
+import behaviorManager from '../../../../es/common/behaviorManager';
+
+var getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {
+  var _item$getKeyShape$get = item.getKeyShape().getBBox(),
+      width = _item$getKeyShape$get.width,
+      height = _item$getKeyShape$get.height;
+
+  var _anchorPoint = _slicedToArray(anchorPoint, 2),
+      x = _anchorPoint[0],
+      y = _anchorPoint[1];
+
+  return {
+    x: width * x,
+    y: height * y - 3,
+    r: 3,
+    lineWidth: 2,
+    fill: '#FFFFFF',
+    stroke: '#5AAAFF'
+  };
+};
+
+var dragAddEdgeBehavior = {
+  edge: null,
+  animateAnchor: null,
+  targetId: null,
+  targetAnchorIndex: null,
+  graphType: GraphType.Flow,
+  getDefaultCfg: function getDefaultCfg() {
+    return {
+      edgeType: 'bizFlowEdge',
+      getAnchorPointStateOfSourceNode: function getAnchorPointStateOfSourceNode() {
+        return AnchorPointState.Enabled;
+      },
+      getAnchorPointStateOfTargetNode: function getAnchorPointStateOfTargetNode() {
+        return AnchorPointState.Enabled;
+      }
+    };
+  },
+  getEvents: function getEvents() {
+    return {
+      'node:mouseenter': 'handleNodeMouseEnter',
+      'node:mouseleave': 'handleNodeMouseLeave',
+      'node:mousedown': 'handleNodeMouseDown',
+      mousemove: 'handleMouseMove',
+      mouseup: 'handleMouseUp'
+    };
+  },
+  isEnabledAnchorPoint: function isEnabledAnchorPoint(e) {
+    var target = e.target;
+    return !!target.get('isAnchorPoint') && target.get('anchorPointState') === AnchorPointState.Enabled;
+  },
+  isNotSelf: function isNotSelf(e) {
+    var edge = this.edge;
+    var item = e.item;
+    return item.getModel().id !== edge.getSource().getModel().id;
+  },
+  getTargetNodes: function getTargetNodes(sourceId) {
+    var graph = this.graph;
+    var nodes = graph.getNodes();
+    return nodes.filter(function (node) {
+      return node.getModel().id !== sourceId;
+    });
+  },
+  canFindTargetAnchorPoint: function canFindTargetAnchorPoint(e) {
+    return this.isEnabledAnchorPoint(e) && this.isNotSelf(e);
+  },
+  shouldAddDelegateEdge: function shouldAddDelegateEdge(e) {
+    return this.isEnabledAnchorPoint(e);
+  },
+  shouldAddRealEdge: function shouldAddRealEdge() {
+    var edge = this.edge;
+    var target = edge.getTarget();
+    return !_isPlainObject(target);
+  },
+  handleNodeMouseEnter: function handleNodeMouseEnter(e) {
+    var graph = this.graph,
+        getAnchorPointStateOfSourceNode = this.getAnchorPointStateOfSourceNode;
+    var sourceNode = e.item;
+    var sourceAnchorPoints = sourceNode.getAnchorPoints();
+    var sourceAnchorPointsState = [];
+    sourceAnchorPoints.forEach(function (sourceAnchorPoint) {
+      sourceAnchorPointsState.push(getAnchorPointStateOfSourceNode(sourceNode, sourceAnchorPoint));
+    });
+    sourceNode.set('anchorPointsState', sourceAnchorPointsState);
+    graph.setItemState(sourceNode, ItemState.ActiveAnchorPoints, true);
+  },
+  handleNodeMouseLeave: function handleNodeMouseLeave(e) {
+    var graph = this.graph,
+        edge = this.edge;
+    var item = e.item;
+
+    if (!edge) {
+      item.set('anchorPointsState', []);
+      graph.setItemState(item, ItemState.ActiveAnchorPoints, false);
+    }
+  },
+  handleNodeMouseDown: function handleNodeMouseDown(e) {
+    if (!this.shouldBegin(e) || !this.shouldAddDelegateEdge(e)) {
+      return;
+    }
+
+    var graph = this.graph,
+        edgeType = this.edgeType,
+        getAnchorPointStateOfTargetNode = this.getAnchorPointStateOfTargetNode;
+    var target = e.target;
+    var sourceNode = e.item;
+    var sourceNodeId = sourceNode.getModel().id;
+    var sourceAnchorPointIndex = target.get('anchorPointIndex');
+    var sourceAnchorPoint = sourceNode.getAnchorPoints()[sourceAnchorPointIndex];
+    var model = {
+      id: guid(),
+      type: edgeType,
+      source: sourceNodeId,
+      sourceAnchor: sourceAnchorPointIndex,
+      target: sourceNodeId
+    };
+    this.edge = graph.addItem(ItemType.Edge, model);
+    graph.getNodes().forEach(function (targetNode) {
+      if (targetNode.getModel().id === sourceNodeId) {
+        return;
+      }
+
+      var targetAnchorPoints = targetNode.getAnchorPoints();
+      var targetAnchorPointsState = [];
+      targetAnchorPoints.forEach(function (targetAnchorPoint) {
+        targetAnchorPointsState.push(getAnchorPointStateOfTargetNode(sourceNode, sourceAnchorPoint, targetNode, targetAnchorPoint));
+      });
+      targetNode.set('anchorPointsState', targetAnchorPointsState);
+      graph.setItemState(targetNode, ItemState.ActiveAnchorPoints, true);
+    });
+  },
+  handleMouseMove: function handleMouseMove(e) {
+    var _this = this;
+
+    var graph = this.graph,
+        edge = this.edge;
+
+    if (edge === null) {
+      return;
+    }
+
+    if (this.targetId && this.targetAnchorIndex !== null) {
+      var item = graph.findById(this.targetId);
+
+      if (item) {
+        var targetAnchor = item.getLinkPointByAnchor(this.targetAnchorIndex);
+        if (targetAnchor && Math.abs(targetAnchor.x - e.x) < 5 && Math.abs(targetAnchor.y - e.y) < 5) return;
+      }
+    }
+
+    if (this.canFindTargetAnchorPoint(e)) {
+      var _item = e.item,
+          target = e.target;
+      this.targetId = _item.getModel().id;
+      this.targetAnchorIndex = target.get('anchorPointIndex');
+
+      var _targetAnchor = _item.getLinkPointByAnchor(this.targetAnchorIndex);
+
+      if (!!this.animateAnchorCfg && !this.animateAnchor) {
+        this.animateAnchor = graph.addItem('node', _merge(this.animateAnchorCfg, {
+          id: guid(),
+          x: _targetAnchor.x,
+          y: _targetAnchor.y
+        }));
+      }
+      /*
+      graph.updateItem(edge, {
+        target: targetId,
+        targetAnchor,
+      });
+      */
+
+    } else {
+      if (this.animateAnchor !== null) {
+        setTimeout(function () {
+          if (_this.animateAnchor !== null) graph.removeItem(_this.animateAnchor);
+          _this.animateAnchor = null;
+        }, 1000);
+      }
+
+      this.targetId = null;
+      this.targetAnchorIndex = null;
+
+      try {
+        graph.updateItem(edge, {
+          target: {
+            x: e.x,
+            y: e.y
+          },
+          targetAnchor: undefined
+        });
+      } catch (err) {//ignore
+      }
+    }
+  },
+  handleMouseUp: function handleMouseUp() {
+    var graph = this.graph,
+        edge = this.edge;
+
+    if (edge === null) {
+      return;
+    }
+
+    if (this.animateAnchor !== null) {
+      graph.removeItem(this.animateAnchor);
+      this.animateAnchor = null;
+    }
+
+    if (this.targetId !== null && this.targetAnchorIndex !== null) {
+      graph.updateItem(edge, {
+        target: this.targetId,
+        targetAnchor: this.targetAnchorIndex
+      });
+      this.targetId = null;
+      this.targetAnchorIndex = null;
+    }
+
+    if (!this.shouldAddRealEdge()) {
+      graph.removeItem(this.edge);
+    }
+
+    this.edge = null;
+    graph.getNodes().forEach(function (node) {
+      node.set('anchorPointsState', []);
+      graph.setItemState(node, ItemState.ActiveAnchorPoints, false);
+    });
+  }
+};
+behaviorManager.register('drag-add-edge', dragAddEdgeBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Flow/behavior/dragAddNode.d.ts b/node_modules/gg-editor/es/components/Flow/behavior/dragAddNode.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/behavior/dragAddNode.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/components/Flow/behavior/dragAddNode.js b/node_modules/gg-editor/es/components/Flow/behavior/dragAddNode.js
new file mode 100644
index 0000000..6cc75cb
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/behavior/dragAddNode.js
@@ -0,0 +1,107 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import isArray from 'lodash/isArray';
+import { guid } from '../../../../es/utils';
+import global from '../../../../es/common/global';
+import { ItemType, GraphType, GraphMode, EditorCommand } from '../../../../es/common/constants';
+import behaviorManager from '../../../../es/common/behaviorManager';
+var dragAddNodeBehavior = {
+  shape: null,
+  graphType: GraphType.Flow,
+  graphMode: GraphMode.AddNode,
+  getEvents: function getEvents() {
+    return {
+      'canvas:mouseenter': 'handleCanvasMouseEnter',
+      mousemove: 'handleMouseMove',
+      mouseup: 'handleMouseUp'
+    };
+  },
+  handleCanvasMouseEnter: function handleCanvasMouseEnter(e) {
+    var graph = this.graph,
+        shape = this.shape;
+
+    if (shape) {
+      return;
+    }
+
+    var group = graph.get('group');
+    var model = global.component.itemPanel.model;
+    var _model$size = model.size,
+        size = _model$size === void 0 ? 100 : _model$size;
+    var width = 0;
+    var height = 0;
+
+    if (isArray(size)) {
+      width = size[0];
+      height = size[1];
+    } else {
+      width = size;
+      height = size;
+    }
+
+    var x = e.x - width / 2;
+    var y = e.y - height / 2;
+    this.shape = group.addShape('rect', {
+      className: global.component.itemPanel.delegateShapeClassName,
+      attrs: {
+        x: x,
+        y: y,
+        width: width,
+        height: height,
+        fill: '#f3f9ff',
+        fillOpacity: 0.5,
+        stroke: '#1890ff',
+        strokeOpacity: 0.9,
+        lineDash: [5, 5]
+      }
+    });
+    graph.paint();
+  },
+  handleMouseMove: function handleMouseMove(e) {
+    var graph = this.graph;
+
+    var _this$shape$getBBox = this.shape.getBBox(),
+        width = _this$shape$getBBox.width,
+        height = _this$shape$getBBox.height;
+
+    var x = e.x - width / 2;
+    var y = e.y - height / 2;
+    this.shape.attr({
+      x: x,
+      y: y
+    });
+    graph.paint();
+  },
+  handleMouseUp: function handleMouseUp(e) {
+    var graph = this.graph;
+
+    var _this$shape$getBBox2 = this.shape.getBBox(),
+        width = _this$shape$getBBox2.width,
+        height = _this$shape$getBBox2.height;
+
+    var x = e.x;
+    var y = e.y;
+    var model = global.component.itemPanel.model;
+
+    if (model.center === 'topLeft') {
+      x -= width / 2;
+      y -= height / 2;
+    }
+
+    this.shape.remove(true);
+    var commandManager = graph.get('commandManager');
+    commandManager.execute(graph, EditorCommand.Add, {
+      type: ItemType.Node,
+      model: _objectSpread({
+        id: guid(),
+        x: x,
+        y: y
+      }, model)
+    });
+  }
+};
+behaviorManager.register('drag-add-node', dragAddNodeBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Flow/behavior/index.d.ts b/node_modules/gg-editor/es/components/Flow/behavior/index.d.ts
new file mode 100644
index 0000000..7623848
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/behavior/index.d.ts
@@ -0,0 +1,2 @@
+import './dragAddNode';
+import './dragAddEdge';
diff --git a/node_modules/gg-editor/es/components/Flow/behavior/index.js b/node_modules/gg-editor/es/components/Flow/behavior/index.js
new file mode 100644
index 0000000..32678d7
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/behavior/index.js
@@ -0,0 +1,2 @@
+import './dragAddNode';
+import './dragAddEdge';
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Flow/index.d.ts b/node_modules/gg-editor/es/components/Flow/index.d.ts
new file mode 100644
index 0000000..5fe7663
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/index.d.ts
@@ -0,0 +1,25 @@
+import React from 'react';
+import { Graph, GraphOptions, FlowData, GraphEvent, GraphReactEventProps } from '../../../es/common/interfaces';
+import './behavior';
+interface FlowProps extends Partial<GraphReactEventProps> {
+    style?: React.CSSProperties;
+    className?: string;
+    data: FlowData;
+    graphConfig?: Partial<GraphOptions>;
+    customModes?: (mode: string, behaviors: any) => object;
+}
+interface FlowState {
+}
+declare class Flow extends React.Component<FlowProps, FlowState> {
+    static defaultProps: {
+        graphConfig: {};
+    };
+    graph: Graph | null;
+    containerId: string;
+    canDragNode: (e: GraphEvent) => boolean;
+    canDragOrZoomCanvas: () => boolean;
+    parseData: (data: any) => void;
+    initGraph: (width: number, height: number) => Graph;
+    render(): JSX.Element;
+}
+export default Flow;
diff --git a/node_modules/gg-editor/es/components/Flow/index.js b/node_modules/gg-editor/es/components/Flow/index.js
new file mode 100644
index 0000000..f5aed16
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Flow/index.js
@@ -0,0 +1,172 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import omit from 'lodash/omit';
+import merge from 'lodash/merge';
+import G6 from '@antv/g6';
+import { guid } from '../../../es/utils';
+import global from '../../../es/common/global';
+import { FLOW_CONTAINER_ID, GraphType } from '../../../es/common/constants';
+import behaviorManager from '../../../es/common/behaviorManager';
+import GraphComponent from '../../../es/components/Graph';
+import './behavior';
+
+var Flow =
+/** @class */
+function () {
+  var Flow = /*#__PURE__*/function (_React$Component) {
+    _inherits(Flow, _React$Component);
+
+    var _super = _createSuper(Flow);
+
+    function Flow() {
+      var _this;
+
+      _classCallCheck(this, Flow);
+
+      _this = _super.apply(this, arguments);
+      _this.graph = null;
+      _this.containerId = "".concat(FLOW_CONTAINER_ID, "_").concat(guid());
+
+      _this.canDragNode = function (e) {
+        return !['anchor', 'banAnchor'].some(function (item) {
+          return item === e.target.get('className');
+        });
+      };
+
+      _this.canDragOrZoomCanvas = function () {
+        var _assertThisInitialize = _assertThisInitialized(_this),
+            graph = _assertThisInitialize.graph;
+
+        if (!graph) {
+          return false;
+        }
+
+        return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';
+      };
+
+      _this.parseData = function (data) {
+        var nodes = data.nodes,
+            edges = data.edges;
+        [].concat(_toConsumableArray(nodes), _toConsumableArray(edges)).forEach(function (item) {
+          var id = item.id;
+
+          if (id) {
+            return;
+          }
+
+          item.id = guid();
+        });
+      };
+
+      _this.initGraph = function (width, height) {
+        var _assertThisInitialize2 = _assertThisInitialized(_this),
+            containerId = _assertThisInitialize2.containerId;
+
+        var _this$props = _this.props,
+            graphConfig = _this$props.graphConfig,
+            customModes = _this$props.customModes;
+        var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Flow), {
+          "default": {
+            'drag-node': {
+              type: 'drag-node',
+              enableDelegate: true,
+              shouldBegin: _this.canDragNode
+            },
+            'drag-canvas': {
+              type: 'drag-canvas',
+              shouldBegin: _this.canDragOrZoomCanvas,
+              shouldUpdate: _this.canDragOrZoomCanvas
+            },
+            'zoom-canvas': {
+              type: 'zoom-canvas',
+              shouldUpdate: _this.canDragOrZoomCanvas
+            },
+            'recall-edge': 'recall-edge',
+            'brush-select': 'brush-select'
+          }
+        });
+        Object.keys(modes).forEach(function (mode) {
+          var behaviors = modes[mode];
+          modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
+        });
+        _this.graph = new G6.Graph(_objectSpread({
+          container: containerId,
+          width: width,
+          height: height,
+          modes: modes,
+          defaultNode: {
+            type: 'bizFlowNode'
+          },
+          defaultEdge: {
+            type: 'bizFlowEdge'
+          }
+        }, graphConfig));
+        return _this.graph;
+      };
+
+      return _this;
+    }
+
+    _createClass(Flow, [{
+      key: "render",
+      value: function render() {
+        var containerId = this.containerId,
+            parseData = this.parseData,
+            initGraph = this.initGraph;
+        return /*#__PURE__*/React.createElement(GraphComponent, Object.assign({
+          containerId: containerId,
+          parseData: parseData,
+          initGraph: initGraph
+        }, omit(this.props, ['graphConfig', 'customModes'])));
+      }
+    }]);
+
+    return Flow;
+  }(React.Component);
+
+  Flow.defaultProps = {
+    graphConfig: {}
+  };
+  return Flow;
+}();
+
+export default Flow;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/clickItem.d.ts b/node_modules/gg-editor/es/components/Graph/behavior/clickItem.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/clickItem.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/clickItem.js b/node_modules/gg-editor/es/components/Graph/behavior/clickItem.js
new file mode 100644
index 0000000..99ce932
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/clickItem.js
@@ -0,0 +1,61 @@
+import { isMind, isEdge, getGraphState, clearSelectedState } from '../../../../es/utils';
+import { ItemState, GraphState, EditorEvent } from '../../../../es/common/constants';
+import behaviorManager from '../../../../es/common/behaviorManager';
+var clickItemBehavior = {
+  getDefaultCfg: function getDefaultCfg() {
+    return {
+      multiple: true,
+      keydown: false,
+      keyCode: 17
+    };
+  },
+  getEvents: function getEvents() {
+    return {
+      'node:click': 'handleItemClick',
+      'edge:click': 'handleItemClick',
+      'canvas:click': 'handleCanvasClick',
+      keydown: 'handleKeyDown',
+      keyup: 'handleKeyUp'
+    };
+  },
+  handleItemClick: function handleItemClick(_ref) {
+    var item = _ref.item;
+    var graph = this.graph;
+
+    if (isMind(graph) && isEdge(item)) {
+      return;
+    }
+
+    var isSelected = item.hasState(ItemState.Selected);
+
+    if (this.multiple && this.keydown) {
+      graph.setItemState(item, ItemState.Selected, !isSelected);
+    } else {
+      clearSelectedState(graph, function (selectedItem) {
+        return selectedItem !== item;
+      });
+
+      if (!isSelected) {
+        graph.setItemState(item, ItemState.Selected, true);
+      }
+    }
+
+    graph.emit(EditorEvent.onGraphStateChange, {
+      graphState: getGraphState(graph)
+    });
+  },
+  handleCanvasClick: function handleCanvasClick() {
+    var graph = this.graph;
+    clearSelectedState(graph);
+    graph.emit(EditorEvent.onGraphStateChange, {
+      graphState: GraphState.CanvasSelected
+    });
+  },
+  handleKeyDown: function handleKeyDown(e) {
+    this.keydown = (e.keyCode || e.which) === this.keyCode;
+  },
+  handleKeyUp: function handleKeyUp() {
+    this.keydown = false;
+  }
+};
+behaviorManager.register('click-item', clickItemBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/dragCanvas.d.ts b/node_modules/gg-editor/es/components/Graph/behavior/dragCanvas.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/dragCanvas.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/dragCanvas.js b/node_modules/gg-editor/es/components/Graph/behavior/dragCanvas.js
new file mode 100644
index 0000000..8a913cf
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/dragCanvas.js
@@ -0,0 +1,135 @@
+import behaviorManager from '../../../../es/common/behaviorManager';
+var dragCanvasBehavior = {
+  origin: null,
+  keyCode: null,
+  dragging: false,
+  handleWindowMouseUp: null,
+  getDefaultCfg: function getDefaultCfg() {
+    return {
+      allowKeyCode: [],
+      notAllowKeyCode: [16]
+    };
+  },
+  getEvents: function getEvents() {
+    return {
+      'canvas:dragstart': 'handleCanvasDragStart',
+      'canvas:drag': 'handleCanvasDrag',
+      'canvas:dragend': 'handleCanvasDragEnd',
+      'canvas:mouseleave': 'handleCanvasMouseLeave',
+      'canvas:contextmenu': 'handleCanvasContextMenu',
+      keydown: 'handleKeyDown',
+      keyup: 'handleKeyUp'
+    };
+  },
+  canDrag: function canDrag() {
+    var keyCode = this.keyCode,
+        allowKeyCode = this.allowKeyCode,
+        notAllowKeyCode = this.notAllowKeyCode;
+    var isAllow = !!!allowKeyCode.length;
+
+    if (!keyCode) {
+      return isAllow;
+    }
+
+    if (allowKeyCode.length && allowKeyCode.includes(keyCode)) {
+      isAllow = true;
+    }
+
+    if (notAllowKeyCode.includes(keyCode)) {
+      isAllow = false;
+    }
+
+    return isAllow;
+  },
+  updateViewport: function updateViewport(e) {
+    var clientX = e.clientX,
+        clientY = e.clientY;
+    var dx = clientX - this.origin.x;
+    var dy = clientY - this.origin.y;
+    this.origin = {
+      x: clientX,
+      y: clientY
+    };
+    this.graph.translate(dx, dy);
+    this.graph.paint();
+  },
+  handleCanvasDragStart: function handleCanvasDragStart(e) {
+    if (!this.shouldBegin.call(this, e)) {
+      return;
+    }
+
+    if (!this.canDrag()) {
+      return;
+    }
+
+    this.origin = {
+      x: e.clientX,
+      y: e.clientY
+    };
+    this.dragging = false;
+  },
+  handleCanvasDrag: function handleCanvasDrag(e) {
+    if (!this.shouldUpdate.call(this, e)) {
+      return;
+    }
+
+    if (!this.canDrag()) {
+      return;
+    }
+
+    if (!this.origin) {
+      return;
+    }
+
+    if (!this.dragging) {
+      this.dragging = true;
+    } else {
+      this.updateViewport(e);
+    }
+  },
+  handleCanvasDragEnd: function handleCanvasDragEnd(e) {
+    if (!this.shouldEnd.call(this, e)) {
+      return;
+    }
+
+    if (!this.canDrag()) {
+      return;
+    }
+
+    this.origin = null;
+    this.dragging = false;
+
+    if (this.handleWindowMouseUp) {
+      document.body.removeEventListener('mouseup', this.handleWindowMouseUp, false);
+      this.handleWindowMouseUp = null;
+    }
+  },
+  handleCanvasMouseLeave: function handleCanvasMouseLeave() {
+    var _this = this;
+
+    var canvasElement = this.graph.get('canvas').get('el');
+
+    if (this.handleWindowMouseUp) {
+      return;
+    }
+
+    this.handleWindowMouseUp = function (e) {
+      if (e.target !== canvasElement) {
+        _this.handleCanvasDragEnd();
+      }
+    };
+
+    document.body.addEventListener('mouseup', this.handleWindowMouseUp, false);
+  },
+  handleCanvasContextMenu: function handleCanvasContextMenu() {
+    this.origin = null;
+    this.dragging = false;
+  },
+  handleKeyDown: function handleKeyDown(e) {
+    this.keyCode = e.keyCode || e.which;
+  },
+  handleKeyUp: function handleKeyUp() {
+    this.keyCode = null;
+  }
+};
+behaviorManager.register('drag-canvas', dragCanvasBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/hoverItem.d.ts b/node_modules/gg-editor/es/components/Graph/behavior/hoverItem.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/hoverItem.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/hoverItem.js b/node_modules/gg-editor/es/components/Graph/behavior/hoverItem.js
new file mode 100644
index 0000000..44720ab
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/hoverItem.js
@@ -0,0 +1,23 @@
+import { ItemState } from '../../../../es/common/constants';
+import behaviorManager from '../../../../es/common/behaviorManager';
+var hoverItemBehavior = {
+  getEvents: function getEvents() {
+    return {
+      'node:mouseenter': 'handleItemMouseenter',
+      'edge:mouseenter': 'handleItemMouseenter',
+      'node:mouseleave': 'handleItemMouseleave',
+      'edge:mouseleave': 'handleItemMouseleave'
+    };
+  },
+  handleItemMouseenter: function handleItemMouseenter(_ref) {
+    var item = _ref.item;
+    var graph = this.graph;
+    graph.setItemState(item, ItemState.Active, true);
+  },
+  handleItemMouseleave: function handleItemMouseleave(_ref2) {
+    var item = _ref2.item;
+    var graph = this.graph;
+    graph.setItemState(item, ItemState.Active, false);
+  }
+};
+behaviorManager.register('hover-item', hoverItemBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/index.d.ts b/node_modules/gg-editor/es/components/Graph/behavior/index.d.ts
new file mode 100644
index 0000000..b50a08a
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/index.d.ts
@@ -0,0 +1,4 @@
+import './clickItem';
+import './hoverItem';
+import './dragCanvas';
+import './recallEdge';
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/index.js b/node_modules/gg-editor/es/components/Graph/behavior/index.js
new file mode 100644
index 0000000..75dfb09
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/index.js
@@ -0,0 +1,4 @@
+import './clickItem';
+import './hoverItem';
+import './dragCanvas';
+import './recallEdge';
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/recallEdge.d.ts b/node_modules/gg-editor/es/components/Graph/behavior/recallEdge.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/recallEdge.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/components/Graph/behavior/recallEdge.js b/node_modules/gg-editor/es/components/Graph/behavior/recallEdge.js
new file mode 100644
index 0000000..88995bb
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/behavior/recallEdge.js
@@ -0,0 +1,62 @@
+import { isFlow, isMind, getFlowRecallEdges, getMindRecallEdges, executeBatch } from '../../../../es/utils';
+import { ItemState } from '../../../../es/common/constants';
+import behaviorManager from '../../../../es/common/behaviorManager';
+var recallEdgeBehavior = {
+  edgeIds: [],
+  getEvents: function getEvents() {
+    return {
+      'node:click': 'handleNodeClick',
+      'edge:click': 'handleEdgeClick',
+      'canvas:click': 'handleCanvasClick'
+    };
+  },
+  setHighLightState: function setHighLightState(edges) {
+    var graph = this.graph;
+    this.clearHighLightState();
+    executeBatch(graph, function () {
+      edges.forEach(function (item) {
+        graph.setItemState(item, ItemState.HighLight, true);
+      });
+    });
+    this.edgeIds = edges.map(function (edge) {
+      return edge.get('id');
+    });
+  },
+  clearHighLightState: function clearHighLightState() {
+    var _this = this;
+
+    var graph = this.graph;
+    executeBatch(graph, function () {
+      _this.edgeIds.forEach(function (id) {
+        var item = graph.findById(id);
+
+        if (item && !item.destroyed) {
+          graph.setItemState(item, ItemState.HighLight, false);
+        }
+      });
+    });
+    this.edgeIds = [];
+  },
+  handleNodeClick: function handleNodeClick(_ref) {
+    var item = _ref.item;
+    var graph = this.graph;
+    var edges = [];
+
+    if (isFlow(graph)) {
+      edges = getFlowRecallEdges(graph, item);
+    }
+
+    if (isMind(graph)) {
+      edges = getMindRecallEdges(graph, item);
+    }
+
+    this.setHighLightState(edges);
+  },
+  handleEdgeClick: function handleEdgeClick() {
+    this.clearHighLightState();
+  },
+  handleCanvasClick: function handleCanvasClick() {
+    this.clearHighLightState();
+  }
+};
+behaviorManager.register('recall-edge', recallEdgeBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/add.d.ts b/node_modules/gg-editor/es/components/Graph/command/add.d.ts
new file mode 100644
index 0000000..4e30e6c
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/add.d.ts
@@ -0,0 +1,9 @@
+import { ItemType } from '../../../../es/common/constants';
+import { NodeModel, EdgeModel } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface AddCommandParams {
+    type: ItemType;
+    model: NodeModel | EdgeModel;
+}
+declare const addCommand: BaseCommand<AddCommandParams>;
+export default addCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/add.js b/node_modules/gg-editor/es/components/Graph/command/add.js
new file mode 100644
index 0000000..ca89fa9
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/add.js
@@ -0,0 +1,40 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { guid } from '../../../../es/utils';
+import { ItemType } from '../../../../es/common/constants';
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+
+var addCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  params: {
+    type: ItemType.Node,
+    model: {
+      id: ''
+    }
+  },
+  init: function init() {
+    var model = this.params.model;
+
+    if (model.id) {
+      return;
+    }
+
+    model.id = guid();
+  },
+  execute: function execute(graph) {
+    var _this$params = this.params,
+        type = _this$params.type,
+        model = _this$params.model;
+    graph.add(type, model);
+    this.setSelectedItems(graph, [model.id]);
+  },
+  undo: function undo(graph) {
+    var model = this.params.model;
+    graph.remove(model.id);
+  }
+});
+
+export default addCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/base.d.ts b/node_modules/gg-editor/es/components/Graph/command/base.d.ts
new file mode 100644
index 0000000..86923d6
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/base.d.ts
@@ -0,0 +1,14 @@
+import { Graph, Item, Node, Edge, Command } from '../../../../es/common/interfaces';
+export interface BaseCommand<P = object, G = Graph> extends Command<P, G> {
+    /** 判断是否脑图 */
+    isMind(graph: G): boolean;
+    /** 获取选中节点 */
+    getSelectedNodes(graph: G): Node[];
+    /** 获取选中连线 */
+    getSelectedEdges(graph: G): Edge[];
+    /** 设置选中元素 */
+    setSelectedItems(graph: G, items: Item[] | string[]): void;
+    /** 编辑选中节点 */
+    editSelectedNode(graph: G): void;
+}
+export declare const baseCommand: BaseCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/base.js b/node_modules/gg-editor/es/components/Graph/command/base.js
new file mode 100644
index 0000000..6c8e30a
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/base.js
@@ -0,0 +1,28 @@
+import { isMind, getSelectedNodes, getSelectedEdges, setSelectedItems } from '../../../../es/utils';
+import { LabelState, EditorEvent } from '../../../../es/common/constants';
+export var baseCommand = {
+  name: '',
+  params: {},
+  canExecute: function canExecute() {
+    return true;
+  },
+  shouldExecute: function shouldExecute() {
+    return true;
+  },
+  canUndo: function canUndo() {
+    return true;
+  },
+  init: function init() {},
+  execute: function execute() {},
+  undo: function undo() {},
+  shortcuts: [],
+  isMind: isMind,
+  getSelectedNodes: getSelectedNodes,
+  getSelectedEdges: getSelectedEdges,
+  setSelectedItems: setSelectedItems,
+  editSelectedNode: function editSelectedNode(graph) {
+    graph.emit(EditorEvent.onLabelStateChange, {
+      labelState: LabelState.Show
+    });
+  }
+};
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/copy.d.ts b/node_modules/gg-editor/es/components/Graph/command/copy.d.ts
new file mode 100644
index 0000000..fbd6f2b
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/copy.d.ts
@@ -0,0 +1,3 @@
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+declare const copyCommand: BaseCommand;
+export default copyCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/copy.js b/node_modules/gg-editor/es/components/Graph/command/copy.js
new file mode 100644
index 0000000..d2ee345
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/copy.js
@@ -0,0 +1,27 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import cloneDeep from 'lodash/cloneDeep';
+import global from '../../../../es/common/global';
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+
+var copyCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  canExecute: function canExecute(graph) {
+    return !!this.getSelectedNodes(graph).length;
+  },
+  canUndo: function canUndo() {
+    return false;
+  },
+  execute: function execute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    global.clipboard.models = cloneDeep(selectedNodes.map(function (node) {
+      return node.getModel();
+    }));
+  },
+  shortcuts: [['metaKey', 'c'], ['ctrlKey', 'c']]
+});
+
+export default copyCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/index.d.ts b/node_modules/gg-editor/es/components/Graph/command/index.d.ts
new file mode 100644
index 0000000..78efbd0
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/index.d.ts
@@ -0,0 +1,13 @@
+declare const _default: {
+    redo: import("../../../common/interfaces").Command<object, import("../../../common/interfaces").Graph>;
+    undo: import("../../../common/interfaces").Command<object, import("../../../common/interfaces").Graph>;
+    add: import("./base").BaseCommand<import("./add").AddCommandParams, import("../../../common/interfaces").Graph>;
+    remove: import("./base").BaseCommand<import("./remove").RemoveCommandParams, import("../../../common/interfaces").Graph>;
+    update: import("./base").BaseCommand<import("./update").UpdateCommandParams, import("../../../common/interfaces").Graph & import("../../../common/interfaces").TreeGraph>;
+    copy: import("./base").BaseCommand<object, import("../../../common/interfaces").Graph>;
+    paste: import("./base").BaseCommand<import("./paste").PasteCommandParams, import("../../../common/interfaces").Graph>;
+    pasteHere: import("./base").BaseCommand<import("./pasteHere").PasteHereCommandParams, import("../../../common/interfaces").Graph>;
+    zoomIn: import("./base").BaseCommand<object, import("../../../common/interfaces").Graph>;
+    zoomOut: import("./base").BaseCommand<object, import("../../../common/interfaces").Graph>;
+};
+export default _default;
diff --git a/node_modules/gg-editor/es/components/Graph/command/index.js b/node_modules/gg-editor/es/components/Graph/command/index.js
new file mode 100644
index 0000000..dc908c3
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/index.js
@@ -0,0 +1,22 @@
+import redo from './redo';
+import undo from './undo';
+import add from './add';
+import remove from './remove';
+import update from './update';
+import copy from './copy';
+import paste from './paste';
+import pasteHere from './pasteHere';
+import zoomIn from './zoomIn';
+import zoomOut from './zoomOut';
+export default {
+  redo: redo,
+  undo: undo,
+  add: add,
+  remove: remove,
+  update: update,
+  copy: copy,
+  paste: paste,
+  pasteHere: pasteHere,
+  zoomIn: zoomIn,
+  zoomOut: zoomOut
+};
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/paste.d.ts b/node_modules/gg-editor/es/components/Graph/command/paste.d.ts
new file mode 100644
index 0000000..d55b930
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/paste.d.ts
@@ -0,0 +1,7 @@
+import { NodeModel } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface PasteCommandParams {
+    models: NodeModel[];
+}
+declare const pasteCommand: BaseCommand<PasteCommandParams>;
+export default pasteCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/paste.js b/node_modules/gg-editor/es/components/Graph/command/paste.js
new file mode 100644
index 0000000..9f30f61
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/paste.js
@@ -0,0 +1,57 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { guid, executeBatch } from '../../../../es/utils';
+import global from '../../../../es/common/global';
+import { ItemType } from '../../../../es/common/constants';
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+
+var pasteCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  params: {
+    models: []
+  },
+  canExecute: function canExecute() {
+    return !!global.clipboard.models.length;
+  },
+  init: function init() {
+    var models = global.clipboard.models;
+    var offsetX = 10;
+    var offsetY = 10;
+    this.params = {
+      models: models.map(function (model) {
+        var x = model.x,
+            y = model.y;
+        return _objectSpread(_objectSpread({}, model), {}, {
+          id: guid(),
+          x: x + offsetX,
+          y: y + offsetY
+        });
+      })
+    };
+  },
+  execute: function execute(graph) {
+    var models = this.params.models;
+    executeBatch(graph, function () {
+      models.forEach(function (model) {
+        graph.addItem(ItemType.Node, model);
+      });
+    });
+    this.setSelectedItems(graph, models.map(function (model) {
+      return model.id;
+    }));
+  },
+  undo: function undo(graph) {
+    var models = this.params.models;
+    executeBatch(graph, function () {
+      models.forEach(function (model) {
+        graph.removeItem(model.id);
+      });
+    });
+  },
+  shortcuts: [['metaKey', 'v'], ['ctrlKey', 'v']]
+});
+
+export default pasteCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/pasteHere.d.ts b/node_modules/gg-editor/es/components/Graph/command/pasteHere.d.ts
new file mode 100644
index 0000000..f38ffe8
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/pasteHere.d.ts
@@ -0,0 +1,7 @@
+import { NodeModel } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface PasteHereCommandParams {
+    models: NodeModel[];
+}
+declare const pasteHereCommand: BaseCommand<PasteHereCommandParams>;
+export default pasteHereCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/pasteHere.js b/node_modules/gg-editor/es/components/Graph/command/pasteHere.js
new file mode 100644
index 0000000..c95b557
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/pasteHere.js
@@ -0,0 +1,36 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { guid } from '../../../../es/utils';
+import global from '../../../../es/common/global';
+import pasteCommand from './paste';
+
+var pasteHereCommand = _objectSpread(_objectSpread({}, pasteCommand), {}, {
+  params: {
+    models: []
+  },
+  init: function init() {
+    var _global$clipboard = global.clipboard,
+        point = _global$clipboard.point,
+        models = _global$clipboard.models;
+    this.params = {
+      models: models.map(function (model) {
+        var x = model.x,
+            y = model.y;
+        var offsetX = point.x - x;
+        var offsetY = point.y - y;
+        return _objectSpread(_objectSpread({}, model), {}, {
+          id: guid(),
+          x: x + offsetX,
+          y: y + offsetY
+        });
+      })
+    };
+  },
+  shortcuts: []
+});
+
+export default pasteHereCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/redo.d.ts b/node_modules/gg-editor/es/components/Graph/command/redo.d.ts
new file mode 100644
index 0000000..c37d2d9
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/redo.d.ts
@@ -0,0 +1,3 @@
+import { Command } from '../../../../es/common/interfaces';
+declare const redoCommand: Command;
+export default redoCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/redo.js b/node_modules/gg-editor/es/components/Graph/command/redo.js
new file mode 100644
index 0000000..f6552c9
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/redo.js
@@ -0,0 +1,27 @@
+var redoCommand = {
+  name: 'redo',
+  params: {},
+  canExecute: function canExecute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandQueue = commandManager.commandQueue,
+        commandIndex = commandManager.commandIndex;
+    return commandIndex < commandQueue.length;
+  },
+  shouldExecute: function shouldExecute() {
+    return true;
+  },
+  canUndo: function canUndo() {
+    return false;
+  },
+  init: function init() {},
+  execute: function execute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandQueue = commandManager.commandQueue,
+        commandIndex = commandManager.commandIndex;
+    commandQueue[commandIndex].execute(graph);
+    commandManager.commandIndex += 1;
+  },
+  undo: function undo() {},
+  shortcuts: [['metaKey', 'shiftKey', 'z'], ['ctrlKey', 'shiftKey', 'z']]
+};
+export default redoCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/remove.d.ts b/node_modules/gg-editor/es/components/Graph/command/remove.d.ts
new file mode 100644
index 0000000..bcbf935
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/remove.d.ts
@@ -0,0 +1,18 @@
+import { NodeModel, EdgeModel } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface RemoveCommandParams {
+    flow: {
+        nodes: {
+            [id: string]: NodeModel;
+        };
+        edges: {
+            [id: string]: EdgeModel;
+        };
+    };
+    mind: {
+        model: NodeModel | null;
+        parent: string;
+    };
+}
+declare const removeCommand: BaseCommand<RemoveCommandParams>;
+export default removeCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/remove.js b/node_modules/gg-editor/es/components/Graph/command/remove.js
new file mode 100644
index 0000000..b344427
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/remove.js
@@ -0,0 +1,122 @@
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { isMind, executeBatch } from '../../../../es/utils';
+import { ItemType } from '../../../../es/common/constants';
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+
+var removeCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  params: {
+    flow: {
+      nodes: {},
+      edges: {}
+    },
+    mind: {
+      model: null,
+      parent: ''
+    }
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    var selectedEdges = this.getSelectedEdges(graph);
+    return !!(selectedNodes.length || selectedEdges.length);
+  },
+  init: function init(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    var selectedEdges = this.getSelectedEdges(graph);
+
+    if (isMind(graph)) {
+      var selectedNode = selectedNodes[0];
+      var selectedNodeModel = selectedNode.getModel();
+      var selectedNodeParent = selectedNode.get('parent');
+      var selectedNodeParentModel = selectedNodeParent ? selectedNodeParent.getModel() : {};
+      this.params.mind = {
+        model: selectedNodeModel,
+        parent: selectedNodeParentModel.id
+      };
+    } else {
+      var _this$params$flow = this.params.flow,
+          nodes = _this$params$flow.nodes,
+          edges = _this$params$flow.edges;
+      selectedNodes.forEach(function (node) {
+        var nodeModel = node.getModel();
+        var nodeEdges = node.getEdges();
+        nodes[nodeModel.id] = nodeModel;
+        nodeEdges.forEach(function (edge) {
+          var edgeModel = edge.getModel();
+          edges[edgeModel.id] = edgeModel;
+        });
+      });
+      selectedEdges.forEach(function (edge) {
+        var edgeModel = edge.getModel();
+        edges[edgeModel.id] = edgeModel;
+      });
+    }
+  },
+  execute: function execute(graph) {
+    if (isMind(graph)) {
+      var model = this.params.mind.model;
+
+      if (!model) {
+        return;
+      }
+
+      graph.removeChild(model.id);
+    } else {
+      var _this$params$flow2 = this.params.flow,
+          nodes = _this$params$flow2.nodes,
+          edges = _this$params$flow2.edges;
+      executeBatch(graph, function () {
+        [].concat(_toConsumableArray(Object.keys(nodes)), _toConsumableArray(Object.keys(edges))).forEach(function (id) {
+          graph.removeItem(id);
+        });
+      });
+    }
+  },
+  undo: function undo(graph) {
+    if (isMind(graph)) {
+      var _this$params$mind = this.params.mind,
+          model = _this$params$mind.model,
+          parent = _this$params$mind.parent;
+
+      if (!model) {
+        return;
+      } //@ts-ignore
+
+
+      graph.addChild(model, parent);
+    } else {
+      var _this$params$flow3 = this.params.flow,
+          nodes = _this$params$flow3.nodes,
+          edges = _this$params$flow3.edges;
+      executeBatch(graph, function () {
+        Object.keys(nodes).forEach(function (id) {
+          var model = nodes[id];
+          graph.addItem(ItemType.Node, model);
+        });
+        Object.keys(edges).forEach(function (id) {
+          var model = edges[id];
+          graph.addItem(ItemType.Edge, model);
+        });
+      });
+    }
+  },
+  shortcuts: ['Delete', 'Backspace']
+});
+
+export default removeCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/undo.d.ts b/node_modules/gg-editor/es/components/Graph/command/undo.d.ts
new file mode 100644
index 0000000..eb76b3f
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/undo.d.ts
@@ -0,0 +1,3 @@
+import { Command } from '../../../../es/common/interfaces';
+declare const undoCommand: Command;
+export default undoCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/undo.js b/node_modules/gg-editor/es/components/Graph/command/undo.js
new file mode 100644
index 0000000..2969d4b
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/undo.js
@@ -0,0 +1,26 @@
+var undoCommand = {
+  name: 'undo',
+  params: {},
+  canExecute: function canExecute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandIndex = commandManager.commandIndex;
+    return commandIndex > 0;
+  },
+  shouldExecute: function shouldExecute() {
+    return true;
+  },
+  canUndo: function canUndo() {
+    return false;
+  },
+  init: function init() {},
+  execute: function execute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandQueue = commandManager.commandQueue,
+        commandIndex = commandManager.commandIndex;
+    commandQueue[commandIndex - 1].undo(graph);
+    commandManager.commandIndex -= 1;
+  },
+  undo: function undo() {},
+  shortcuts: [['metaKey', 'z'], ['ctrlKey', 'z']]
+};
+export default undoCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/update.d.ts b/node_modules/gg-editor/es/components/Graph/command/update.d.ts
new file mode 100644
index 0000000..e7cfd37
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/update.d.ts
@@ -0,0 +1,10 @@
+import { Graph, TreeGraph, NodeModel, EdgeModel } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface UpdateCommandParams {
+    id: string;
+    originModel: Partial<NodeModel> | EdgeModel;
+    updateModel: Partial<NodeModel> | EdgeModel;
+    forceRefreshLayout: boolean;
+}
+declare const updateCommand: BaseCommand<UpdateCommandParams, Graph & TreeGraph>;
+export default updateCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/update.js b/node_modules/gg-editor/es/components/Graph/command/update.js
new file mode 100644
index 0000000..b4c7601
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/update.js
@@ -0,0 +1,49 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import pick from 'lodash/pick';
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+
+var updateCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  params: {
+    id: '',
+    originModel: {},
+    updateModel: {},
+    forceRefreshLayout: false
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    var selectedEdges = this.getSelectedEdges(graph);
+    return (selectedNodes.length || selectedEdges.length) && (selectedNodes.length === 1 || selectedEdges.length === 1) ? true : false;
+  },
+  init: function init(graph) {
+    var _this$params = this.params,
+        id = _this$params.id,
+        updateModel = _this$params.updateModel;
+    var updatePaths = Object.keys(updateModel);
+    var originModel = pick(graph.findById(id).getModel(), updatePaths);
+    this.params.originModel = originModel;
+  },
+  execute: function execute(graph) {
+    var _this$params2 = this.params,
+        id = _this$params2.id,
+        updateModel = _this$params2.updateModel,
+        forceRefreshLayout = _this$params2.forceRefreshLayout;
+    graph.updateItem(id, updateModel);
+
+    if (forceRefreshLayout) {
+      graph.refreshLayout && graph.refreshLayout(false);
+    }
+  },
+  undo: function undo(graph) {
+    var _this$params3 = this.params,
+        id = _this$params3.id,
+        originModel = _this$params3.originModel;
+    graph.updateItem(id, originModel);
+  }
+});
+
+export default updateCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/zoomIn.d.ts b/node_modules/gg-editor/es/components/Graph/command/zoomIn.d.ts
new file mode 100644
index 0000000..c79092f
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/zoomIn.d.ts
@@ -0,0 +1,3 @@
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+declare const zoomInCommand: BaseCommand;
+export default zoomInCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/zoomIn.js b/node_modules/gg-editor/es/components/Graph/command/zoomIn.js
new file mode 100644
index 0000000..1fd271f
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/zoomIn.js
@@ -0,0 +1,28 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+var DELTA = 0.05;
+
+var zoomInCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  canUndo: function canUndo() {
+    return false;
+  },
+  execute: function execute(graph) {
+    var ratio = 1 + DELTA;
+    var zoom = graph.getZoom() * ratio;
+    var maxZoom = graph.get('maxZoom');
+
+    if (zoom > maxZoom) {
+      return;
+    }
+
+    graph.zoom(ratio);
+  },
+  shortcuts: [['metaKey', '='], ['ctrlKey', '=']]
+});
+
+export default zoomInCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/command/zoomOut.d.ts b/node_modules/gg-editor/es/components/Graph/command/zoomOut.d.ts
new file mode 100644
index 0000000..52060b5
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/zoomOut.d.ts
@@ -0,0 +1,3 @@
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+declare const zoomOutCommand: BaseCommand;
+export default zoomOutCommand;
diff --git a/node_modules/gg-editor/es/components/Graph/command/zoomOut.js b/node_modules/gg-editor/es/components/Graph/command/zoomOut.js
new file mode 100644
index 0000000..1b48b37
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/command/zoomOut.js
@@ -0,0 +1,28 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+var DELTA = 0.05;
+
+var zoomOutCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  canUndo: function canUndo() {
+    return false;
+  },
+  execute: function execute(graph) {
+    var ratio = 1 - DELTA;
+    var zoom = graph.getZoom() * ratio;
+    var minZoom = graph.get('minZoom');
+
+    if (zoom < minZoom) {
+      return;
+    }
+
+    graph.zoom(ratio);
+  },
+  shortcuts: [['metaKey', '-'], ['ctrlKey', '-']]
+});
+
+export default zoomOutCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Graph/index.d.ts b/node_modules/gg-editor/es/components/Graph/index.d.ts
new file mode 100644
index 0000000..1d7397f
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/index.d.ts
@@ -0,0 +1,14 @@
+import React from 'react';
+import { Graph, FlowData, MindData, GraphReactEventProps } from '../../../es/common/interfaces';
+import { EditorPrivateContextProps } from '../../../es/components/EditorContext';
+import './behavior';
+interface GraphProps extends Partial<GraphReactEventProps>, EditorPrivateContextProps {
+    style?: React.CSSProperties;
+    className?: string;
+    containerId: string;
+    data: FlowData | MindData;
+    parseData(data: object): void;
+    initGraph(width: number, height: number): Graph;
+}
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<GraphProps>, "data" | "style" | "onClick" | "onDoubleClick" | "onMouseEnter" | "onMouseMove" | "onMouseOut" | "onMouseOver" | "onMouseLeave" | "onMouseDown" | "onMouseUp" | "onContextMenu" | "onDragStart" | "onDrag" | "onDragEnd" | "onDragEnter" | "onDragLeave" | "onDrop" | "onKeyDown" | "onKeyUp" | "onTouchStart" | "onTouchMove" | "onTouchEnd" | "onNodeClick" | "onNodeDoubleClick" | "onNodeMouseEnter" | "onNodeMouseMove" | "onNodeMouseOut" | "onNodeMouseOver" | "onNodeMouseLeave" | "onNodeMouseDown" | "onNodeMouseUp" | "onNodeContextMenu" | "onNodeDragStart" | "onNodeDrag" | "onNodeDragEnd" | "onNodeDragEnter" | "onNodeDragLeave" | "onNodeDrop" | "onEdgeClick" | "onEdgeDoubleClick" | "onEdgeMouseEnter" | "onEdgeMouseMove" | "onEdgeMouseOut" | "onEdgeMouseOver" | "onEdgeMouseLeave" | "onEdgeMouseDown" | "onEdgeMouseUp" | "onEdgeContextMenu" | "onCanvasClick" | "onCanvasDoubleClick" | "onCanvasMouseEnter" | "onCanvasMouseMove" | "onCanvasMouseOut" | "onCanvasMouseOver" | "onCanvasMouseLeave" | "onCanvasMouseDown" | "onCanvasMouseUp" | "onCanvasContextMenu" | "onCanvasDragStart" | "onCanvasDrag" | "onCanvasDragEnd" | "onCanvasDragEnter" | "onCanvasDragLeave" | "onBeforeAddItem" | "onAfterAddItem" | "onBeforeRemoveItem" | "onAfterRemoveItem" | "onBeforeUpdateItem" | "onAfterUpdateItem" | "onBeforeItemVisibilityChange" | "onAfterItemVisibilityChange" | "onBeforeItemStateChange" | "onAfterItemStateChange" | "onBeforeRefreshItem" | "onAfterRefreshItem" | "onBeforeItemStatesClear" | "onAfterItemStatesClear" | "onBeforeLayout" | "onAfterLayout" | "onBeforeConnect" | "onAfterConnect" | "children" | "className" | "containerId" | "parseData" | "initGraph"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/components/Graph/index.js b/node_modules/gg-editor/es/components/Graph/index.js
new file mode 100644
index 0000000..10188a2
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Graph/index.js
@@ -0,0 +1,194 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import pick from 'lodash/pick';
+import { isMind } from '../../../es/utils';
+import { track } from '../../../es/helpers';
+import global from '../../../es/common/global';
+import { GraphType, GraphCommonEvent, GraphNodeEvent, GraphEdgeEvent, GraphCanvasEvent, GraphCustomEvent } from '../../../es/common/constants';
+import { withEditorPrivateContext } from '../../../es/components/EditorContext';
+import baseCommands from './command';
+import mindCommands from '../../../es/components/Mind/command';
+import './behavior';
+
+var GraphComponent = /*#__PURE__*/function (_React$Component) {
+  _inherits(GraphComponent, _React$Component);
+
+  var _super = _createSuper(GraphComponent);
+
+  function GraphComponent() {
+    var _this;
+
+    _classCallCheck(this, GraphComponent);
+
+    _this = _super.apply(this, arguments);
+    _this.graph = null;
+
+    _this.changeWidth = function () {
+      setTimeout(function () {
+        var containerId = _this.props.containerId;
+
+        var _ref = document.getElementById(containerId) || {},
+            _ref$clientWidth = _ref.clientWidth,
+            clientWidth = _ref$clientWidth === void 0 ? 0 : _ref$clientWidth,
+            _ref$clientHeight = _ref.clientHeight,
+            clientHeight = _ref$clientHeight === void 0 ? 0 : _ref$clientHeight;
+
+        _this.graph.changeSize(clientWidth, clientHeight);
+      }, 200);
+    };
+
+    return _this;
+  }
+
+  _createClass(GraphComponent, [{
+    key: "componentDidMount",
+    value: function componentDidMount() {
+      this.initGraph();
+      this.bindEvent();
+    }
+  }, {
+    key: "componentWillUnmount",
+    value: function componentWillUnmount() {
+      window.removeEventListener('resize', this.changeWidth);
+    }
+  }, {
+    key: "componentDidUpdate",
+    value: function componentDidUpdate(prevProps) {
+      var data = this.props.data;
+
+      if (data !== prevProps.data) {
+        this.changeData(data);
+      }
+    }
+  }, {
+    key: "focusRootNode",
+    value: function focusRootNode(graph, data) {
+      if (!isMind(graph)) {
+        return;
+      }
+
+      var id = data.id;
+      graph.focusItem(id);
+    }
+  }, {
+    key: "initGraph",
+    value: function initGraph() {
+      var _this$props = this.props,
+          containerId = _this$props.containerId,
+          parseData = _this$props.parseData,
+          initGraph = _this$props.initGraph,
+          setGraph = _this$props.setGraph,
+          commandManager = _this$props.commandManager;
+
+      var _ref2 = document.getElementById(containerId) || {},
+          _ref2$clientWidth = _ref2.clientWidth,
+          clientWidth = _ref2$clientWidth === void 0 ? 0 : _ref2$clientWidth,
+          _ref2$clientHeight = _ref2.clientHeight,
+          clientHeight = _ref2$clientHeight === void 0 ? 0 : _ref2$clientHeight; // 解析数据
+
+
+      var data = _objectSpread({}, this.props.data);
+
+      parseData(data); // 初始画布
+
+      this.graph = initGraph(clientWidth, clientHeight);
+      this.graph.data(data);
+      this.graph.render();
+      this.focusRootNode(this.graph, data);
+      this.graph.setMode('default');
+      setGraph(this.graph); // 设置命令管理器
+
+      this.graph.set('commandManager', commandManager); // 注册命令
+
+      var commands = baseCommands;
+
+      if (isMind(this.graph)) {
+        commands = _objectSpread(_objectSpread({}, commands), mindCommands);
+      }
+
+      Object.keys(commands).forEach(function (name) {
+        commandManager.register(name, commands[name]);
+      });
+      window.addEventListener('resize', this.changeWidth);
+      this.changeWidth(); // 发送埋点
+
+      if (global.trackable) {
+        var graphType = isMind(this.graph) ? GraphType.Mind : GraphType.Flow;
+        track(graphType);
+      }
+    }
+  }, {
+    key: "bindEvent",
+    value: function bindEvent() {
+      var graph = this.graph,
+          props = this.props;
+
+      if (!graph) {
+        return;
+      }
+
+      var events = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GraphCommonEvent), GraphNodeEvent), GraphEdgeEvent), GraphCanvasEvent), GraphCustomEvent);
+
+      Object.keys(events).forEach(function (event) {
+        if (typeof props[event] === 'function') {
+          graph.on(events[event], props[event]);
+        }
+      });
+    }
+  }, {
+    key: "changeData",
+    value: function changeData(data) {
+      var graph = this.graph;
+      var parseData = this.props.parseData;
+
+      if (!graph) {
+        return;
+      }
+
+      parseData(data);
+      graph.changeData(data);
+      this.focusRootNode(graph, data);
+    }
+  }, {
+    key: "render",
+    value: function render() {
+      var _this$props2 = this.props,
+          containerId = _this$props2.containerId,
+          children = _this$props2.children;
+      return /*#__PURE__*/React.createElement("div", Object.assign({
+        id: containerId
+      }, pick(this.props, ['className', 'style'])), children);
+    }
+  }]);
+
+  return GraphComponent;
+}(React.Component);
+
+export default withEditorPrivateContext(GraphComponent);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/ItemPanel/Item.d.ts b/node_modules/gg-editor/es/components/ItemPanel/Item.d.ts
new file mode 100644
index 0000000..ea91cc1
--- /dev/null
+++ b/node_modules/gg-editor/es/components/ItemPanel/Item.d.ts
@@ -0,0 +1,14 @@
+import React from 'react';
+import { ItemType } from '../../../es/common/constants';
+import { NodeModel } from '../../../es/common/interfaces';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+export interface ItemProps extends EditorContextProps {
+    style?: React.CSSProperties;
+    className?: string;
+    type?: ItemType;
+    model: Partial<NodeModel>;
+}
+export interface ItemState {
+}
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemProps>, "style" | "type" | "model" | "children" | "className"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/components/ItemPanel/Item.js b/node_modules/gg-editor/es/components/ItemPanel/Item.js
new file mode 100644
index 0000000..5f72355
--- /dev/null
+++ b/node_modules/gg-editor/es/components/ItemPanel/Item.js
@@ -0,0 +1,78 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import pick from 'lodash/pick';
+import global from '../../../es/common/global';
+import { ItemType, GraphMode } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+
+var Item =
+/** @class */
+function () {
+  var Item = /*#__PURE__*/function (_React$Component) {
+    _inherits(Item, _React$Component);
+
+    var _super = _createSuper(Item);
+
+    function Item() {
+      var _this;
+
+      _classCallCheck(this, Item);
+
+      _this = _super.apply(this, arguments);
+
+      _this.handleMouseDown = function () {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            type = _this$props.type,
+            model = _this$props.model;
+
+        if (type === ItemType.Node) {
+          global.component.itemPanel.model = model;
+          graph.setMode(GraphMode.AddNode);
+        }
+      };
+
+      return _this;
+    }
+
+    _createClass(Item, [{
+      key: "render",
+      value: function render() {
+        var children = this.props.children;
+        return /*#__PURE__*/React.createElement("div", Object.assign({}, pick(this.props, ['style', 'className']), {
+          onMouseDown: this.handleMouseDown
+        }), children);
+      }
+    }]);
+
+    return Item;
+  }(React.Component);
+
+  Item.defaultProps = {
+    type: ItemType.Node
+  };
+  return Item;
+}();
+
+export default withEditorContext(Item);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/ItemPanel/index.d.ts b/node_modules/gg-editor/es/components/ItemPanel/index.d.ts
new file mode 100644
index 0000000..19fef1e
--- /dev/null
+++ b/node_modules/gg-editor/es/components/ItemPanel/index.d.ts
@@ -0,0 +1,10 @@
+import React from 'react';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+import Item from './Item';
+interface ItemPanelProps extends EditorContextProps {
+    style?: React.CSSProperties;
+    className?: string;
+}
+export { Item };
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemPanelProps>, "style" | "children" | "className"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/components/ItemPanel/index.js b/node_modules/gg-editor/es/components/ItemPanel/index.js
new file mode 100644
index 0000000..f764a06
--- /dev/null
+++ b/node_modules/gg-editor/es/components/ItemPanel/index.js
@@ -0,0 +1,93 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import pick from 'lodash/pick';
+import global from '../../../es/common/global';
+import { GraphMode } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+import Item from './Item';
+
+var ItemPanel =
+/** @class */
+function () {
+  var ItemPanel = /*#__PURE__*/function (_React$Component) {
+    _inherits(ItemPanel, _React$Component);
+
+    var _super = _createSuper(ItemPanel);
+
+    function ItemPanel() {
+      var _this;
+
+      _classCallCheck(this, ItemPanel);
+
+      _this = _super.apply(this, arguments);
+
+      _this.handleMouseUp = function () {
+        var graph = _this.props.graph;
+
+        if (graph.getCurrentMode() === GraphMode.Default) {
+          return;
+        }
+
+        var group = graph.get('group');
+        var shape = group.findByClassName(global.component.itemPanel.delegateShapeClassName);
+
+        if (shape) {
+          shape.remove(true);
+          graph.paint();
+        }
+
+        global.component.itemPanel.model = null;
+        graph.setMode(GraphMode.Default);
+      };
+
+      return _this;
+    }
+
+    _createClass(ItemPanel, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        document.addEventListener('mouseup', this.handleMouseUp, false);
+      }
+    }, {
+      key: "componentWillUnmount",
+      value: function componentWillUnmount() {
+        document.removeEventListener('mouseup', this.handleMouseUp, false);
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var children = this.props.children;
+        return /*#__PURE__*/React.createElement("div", Object.assign({}, pick(this.props, ['style', 'className'])), children);
+      }
+    }]);
+
+    return ItemPanel;
+  }(React.Component);
+
+  ItemPanel.Item = Item;
+  return ItemPanel;
+}();
+
+export { Item };
+export default withEditorContext(ItemPanel);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Mind/command/fold.d.ts b/node_modules/gg-editor/es/components/Mind/command/fold.d.ts
new file mode 100644
index 0000000..f195f46
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/fold.d.ts
@@ -0,0 +1,6 @@
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface FoldCommandParams {
+    id: string;
+}
+declare const foldCommand: BaseCommand<FoldCommandParams>;
+export default foldCommand;
diff --git a/node_modules/gg-editor/es/components/Mind/command/fold.js b/node_modules/gg-editor/es/components/Mind/command/fold.js
new file mode 100644
index 0000000..e5ade80
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/fold.js
@@ -0,0 +1,52 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+
+var foldCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  params: {
+    id: ''
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+
+    if (!selectedNodes.length) {
+      return false;
+    }
+
+    var selectedNode = selectedNodes[0];
+    var selectedNodeModel = selectedNode.getModel(); //@ts-ignore
+
+    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
+      return false;
+    }
+
+    if (selectedNodeModel.collapsed) {
+      return false;
+    }
+
+    return true;
+  },
+  init: function init(graph) {
+    var selectedNode = this.getSelectedNodes(graph)[0];
+    var selectedNodeModel = selectedNode.getModel();
+    this.params = {
+      id: selectedNodeModel.id
+    };
+  },
+  execute: function execute(graph) {
+    var id = this.params.id;
+    var sourceData = graph.findDataById(id);
+    sourceData.collapsed = !sourceData.collapsed;
+    graph.refreshLayout(false);
+  },
+  undo: function undo(graph) {
+    this.execute(graph);
+  },
+  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
+});
+
+export default foldCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Mind/command/index.d.ts b/node_modules/gg-editor/es/components/Mind/command/index.d.ts
new file mode 100644
index 0000000..1c5d4e4
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/index.d.ts
@@ -0,0 +1,7 @@
+declare const _default: {
+    topic: import("../../Graph/command/base").BaseCommand<import("./topic").TopicCommandParams, import("../../../common/interfaces").TreeGraph>;
+    subtopic: import("../../Graph/command/base").BaseCommand<import("./subtopic").SubtopicCommandParams, import("../../../common/interfaces").TreeGraph>;
+    fold: import("../../Graph/command/base").BaseCommand<import("./fold").FoldCommandParams, import("../../../common/interfaces").Graph>;
+    unfold: import("../../Graph/command/base").BaseCommand<import("./unfold").UnfoldCommandParams, import("../../../common/interfaces").Graph>;
+};
+export default _default;
diff --git a/node_modules/gg-editor/es/components/Mind/command/index.js b/node_modules/gg-editor/es/components/Mind/command/index.js
new file mode 100644
index 0000000..36414c5
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/index.js
@@ -0,0 +1,10 @@
+import topic from './topic';
+import subtopic from './subtopic';
+import fold from './fold';
+import unfold from './unfold';
+export default {
+  topic: topic,
+  subtopic: subtopic,
+  fold: fold,
+  unfold: unfold
+};
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Mind/command/subtopic.d.ts b/node_modules/gg-editor/es/components/Mind/command/subtopic.d.ts
new file mode 100644
index 0000000..b139685
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/subtopic.d.ts
@@ -0,0 +1,8 @@
+import { TreeGraph, MindData } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface SubtopicCommandParams {
+    id: string;
+    model: MindData;
+}
+declare const subtopicCommand: BaseCommand<SubtopicCommandParams, TreeGraph>;
+export default subtopicCommand;
diff --git a/node_modules/gg-editor/es/components/Mind/command/subtopic.js b/node_modules/gg-editor/es/components/Mind/command/subtopic.js
new file mode 100644
index 0000000..7059fbb
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/subtopic.js
@@ -0,0 +1,27 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import topicCommand from './topic';
+
+var subtopicCommand = _objectSpread(_objectSpread({}, topicCommand), {}, {
+  canExecute: function canExecute(graph) {
+    return this.getSelectedNodes(graph)[0] ? true : false;
+  },
+  execute: function execute(graph) {
+    var _this$params = this.params,
+        id = _this$params.id,
+        model = _this$params.model; // 添加节点
+
+    graph.addChild(model, id); // 选中节点
+
+    this.setSelectedItems(graph, [model.id]); // 编辑节点
+
+    this.editSelectedNode(graph);
+  },
+  shortcuts: ['Tab']
+});
+
+export default subtopicCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Mind/command/topic.d.ts b/node_modules/gg-editor/es/components/Mind/command/topic.d.ts
new file mode 100644
index 0000000..363d2e1
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/topic.d.ts
@@ -0,0 +1,8 @@
+import { TreeGraph, MindData } from '../../../../es/common/interfaces';
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface TopicCommandParams {
+    id: string;
+    model: MindData;
+}
+export declare const topicCommand: BaseCommand<TopicCommandParams, TreeGraph>;
+export default topicCommand;
diff --git a/node_modules/gg-editor/es/components/Mind/command/topic.js b/node_modules/gg-editor/es/components/Mind/command/topic.js
new file mode 100644
index 0000000..44b5576
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/topic.js
@@ -0,0 +1,56 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { guid } from '../../../../es/utils';
+import { LABEL_DEFAULT_TEXT } from '../../../../es/common/constants';
+import { baseCommand } from '../../../../es/components/Graph/command/base';
+export var topicCommand = _objectSpread(_objectSpread({}, baseCommand), {}, {
+  params: {
+    id: '',
+    model: {
+      id: ''
+    }
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    return selectedNodes.length && selectedNodes.length === 1 && selectedNodes[0].get('parent');
+  },
+  init: function init(graph) {
+    if (this.params.id) {
+      return;
+    }
+
+    var selectedNode = this.getSelectedNodes(graph)[0];
+    this.params = {
+      id: selectedNode.get('id'),
+      model: {
+        id: guid(),
+        label: LABEL_DEFAULT_TEXT
+      }
+    };
+  },
+  execute: function execute(graph) {
+    var _this$params = this.params,
+        id = _this$params.id,
+        model = _this$params.model;
+    var parent = graph.findById(id).get('parent'); // 添加节点
+
+    graph.addChild(model, parent); // 选中节点
+
+    this.setSelectedItems(graph, [model.id]); // 编辑节点
+
+    this.editSelectedNode(graph);
+  },
+  undo: function undo(graph) {
+    var _this$params2 = this.params,
+        id = _this$params2.id,
+        model = _this$params2.model;
+    this.setSelectedItems(graph, [id]);
+    graph.removeChild(model.id);
+  },
+  shortcuts: ['Enter']
+});
+export default topicCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Mind/command/unfold.d.ts b/node_modules/gg-editor/es/components/Mind/command/unfold.d.ts
new file mode 100644
index 0000000..dfcc1d3
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/unfold.d.ts
@@ -0,0 +1,6 @@
+import { BaseCommand } from '../../../../es/components/Graph/command/base';
+export interface UnfoldCommandParams {
+    id: string;
+}
+declare const unfoldCommand: BaseCommand<UnfoldCommandParams>;
+export default unfoldCommand;
diff --git a/node_modules/gg-editor/es/components/Mind/command/unfold.js b/node_modules/gg-editor/es/components/Mind/command/unfold.js
new file mode 100644
index 0000000..43f3d5b
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/command/unfold.js
@@ -0,0 +1,33 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import foldCommand from './fold';
+
+var unfoldCommand = _objectSpread(_objectSpread({}, foldCommand), {}, {
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+
+    if (!selectedNodes.length) {
+      return false;
+    }
+
+    var selectedNode = selectedNodes[0];
+    var selectedNodeModel = selectedNode.getModel(); //@ts-ignore
+
+    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
+      return false;
+    }
+
+    if (!selectedNodeModel.collapsed) {
+      return false;
+    }
+
+    return true;
+  },
+  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
+});
+
+export default unfoldCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Mind/index.d.ts b/node_modules/gg-editor/es/components/Mind/index.d.ts
new file mode 100644
index 0000000..8743f06
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/index.d.ts
@@ -0,0 +1,27 @@
+import React from 'react';
+import { Graph, GraphOptions, MindData, GraphReactEventProps } from '../../../es/common/interfaces';
+import './command';
+interface MindProps extends Partial<GraphReactEventProps> {
+    style?: React.CSSProperties;
+    className?: string;
+    data: MindData;
+    graphConfig?: Partial<GraphOptions>;
+    customModes?: (mode: string, behaviors: any) => object;
+}
+interface MindState {
+}
+declare class Mind extends React.Component<MindProps, MindState> {
+    static defaultProps: {
+        graphConfig: {};
+    };
+    graph: Graph | null;
+    containerId: string;
+    canDragOrZoomCanvas: () => boolean;
+    canCollapseExpand: ({ target }: {
+        target: any;
+    }) => boolean;
+    parseData: (data: any) => void;
+    initGraph: (width: number, height: number) => Graph;
+    render(): JSX.Element;
+}
+export default Mind;
diff --git a/node_modules/gg-editor/es/components/Mind/index.js b/node_modules/gg-editor/es/components/Mind/index.js
new file mode 100644
index 0000000..ad53b95
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Mind/index.js
@@ -0,0 +1,187 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import omit from 'lodash/omit';
+import merge from 'lodash/merge';
+import G6 from '@antv/g6';
+import { guid, recursiveTraversal } from '../../../es/utils';
+import global from '../../../es/common/global';
+import { MIND_CONTAINER_ID, GraphType } from '../../../es/common/constants';
+import { FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME } from '../../../es/shape/nodes/bizMindNode';
+import behaviorManager from '../../../es/common/behaviorManager';
+import GraphComponent from '../../../es/components/Graph';
+import './command';
+
+var Mind =
+/** @class */
+function () {
+  var Mind = /*#__PURE__*/function (_React$Component) {
+    _inherits(Mind, _React$Component);
+
+    var _super = _createSuper(Mind);
+
+    function Mind() {
+      var _this;
+
+      _classCallCheck(this, Mind);
+
+      _this = _super.apply(this, arguments);
+      _this.graph = null;
+      _this.containerId = "".concat(MIND_CONTAINER_ID, "_").concat(guid());
+
+      _this.canDragOrZoomCanvas = function () {
+        var _assertThisInitialize = _assertThisInitialized(_this),
+            graph = _assertThisInitialize.graph;
+
+        if (!graph) {
+          return false;
+        }
+
+        return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';
+      };
+
+      _this.canCollapseExpand = function (_ref) {
+        var target = _ref.target;
+        return target && [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].includes(target.get('className'));
+      };
+
+      _this.parseData = function (data) {
+        recursiveTraversal(data, function (item) {
+          var id = item.id;
+
+          if (id) {
+            return;
+          }
+
+          item.id = guid();
+        });
+      };
+
+      _this.initGraph = function (width, height) {
+        var _assertThisInitialize2 = _assertThisInitialized(_this),
+            containerId = _assertThisInitialize2.containerId;
+
+        var _this$props = _this.props,
+            graphConfig = _this$props.graphConfig,
+            customModes = _this$props.customModes;
+        var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Mind), {
+          "default": {
+            'click-item': {
+              type: 'click-item',
+              multiple: false
+            },
+            'collapse-expand': {
+              type: 'collapse-expand',
+              shouldBegin: _this.canCollapseExpand
+            },
+            'drag-canvas': {
+              type: 'drag-canvas',
+              shouldBegin: _this.canDragOrZoomCanvas,
+              shouldUpdate: _this.canDragOrZoomCanvas
+            },
+            'zoom-canvas': {
+              type: 'zoom-canvas',
+              shouldUpdate: _this.canDragOrZoomCanvas
+            }
+          }
+        });
+        Object.keys(modes).forEach(function (mode) {
+          var behaviors = modes[mode];
+          modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
+        });
+        _this.graph = new G6.TreeGraph(_objectSpread({
+          container: containerId,
+          width: width,
+          height: height,
+          modes: modes,
+          layout: {
+            type: 'mindmap',
+            direction: 'H',
+            getWidth: function getWidth() {
+              return 120;
+            },
+            getHeight: function getHeight() {
+              return 60;
+            },
+            getHGap: function getHGap() {
+              return 100;
+            },
+            getVGap: function getVGap() {
+              return 50;
+            },
+            getSide: function getSide(_ref2) {
+              var data = _ref2.data;
+
+              if (data.side) {
+                return data.side;
+              }
+
+              return 'right';
+            }
+          },
+          animate: false,
+          defaultNode: {
+            type: 'bizMindNode'
+          },
+          defaultEdge: {
+            type: 'bizMindEdge'
+          }
+        }, graphConfig));
+        return _this.graph;
+      };
+
+      return _this;
+    }
+
+    _createClass(Mind, [{
+      key: "render",
+      value: function render() {
+        var containerId = this.containerId,
+            parseData = this.parseData,
+            initGraph = this.initGraph;
+        var data = this.props.data;
+        return /*#__PURE__*/React.createElement(GraphComponent, Object.assign({
+          containerId: containerId,
+          data: data,
+          parseData: parseData,
+          initGraph: initGraph
+        }, omit(this.props, ['graphConfig', 'customModes'])));
+      }
+    }]);
+
+    return Mind;
+  }(React.Component);
+
+  Mind.defaultProps = {
+    graphConfig: {}
+  };
+  return Mind;
+}();
+
+export default Mind;
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/components/Register/index.d.ts b/node_modules/gg-editor/es/components/Register/index.d.ts
new file mode 100644
index 0000000..094c8d3
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Register/index.d.ts
@@ -0,0 +1,12 @@
+import React from 'react';
+import { EditorPrivateContextProps } from '../../../es/components/EditorContext';
+interface RegisterProps extends EditorPrivateContextProps {
+    name: string;
+    config: object;
+    extend?: string;
+}
+export declare const RegisterNode: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export declare const RegisterEdge: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export declare const RegisterCommand: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export declare const RegisterBehavior: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export {};
diff --git a/node_modules/gg-editor/es/components/Register/index.js b/node_modules/gg-editor/es/components/Register/index.js
new file mode 100644
index 0000000..019ae9b
--- /dev/null
+++ b/node_modules/gg-editor/es/components/Register/index.js
@@ -0,0 +1,105 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import G6 from '@antv/g6';
+import behaviorManager from '../../../es/common/behaviorManager';
+import { withEditorPrivateContext } from '../../../es/components/EditorContext';
+
+var Register =
+/** @class */
+function () {
+  var Register = /*#__PURE__*/function (_React$Component) {
+    _inherits(Register, _React$Component);
+
+    var _super = _createSuper(Register);
+
+    function Register(props, type) {
+      var _this;
+
+      _classCallCheck(this, Register);
+
+      _this = _super.call(this, props);
+      var name = props.name,
+          config = props.config,
+          extend = props.extend,
+          commandManager = props.commandManager;
+
+      switch (type) {
+        case 'node':
+          G6.registerNode(name, config, extend);
+          break;
+
+        case 'edge':
+          G6.registerEdge(name, config, extend);
+          break;
+
+        case 'command':
+          commandManager.register(name, config);
+          break;
+
+        case 'behavior':
+          behaviorManager.register(name, config);
+          break;
+
+        default:
+          break;
+      }
+
+      return _this;
+    }
+
+    _createClass(Register, [{
+      key: "render",
+      value: function render() {
+        return null;
+      }
+    }]);
+
+    return Register;
+  }(React.Component);
+
+  Register.create = function (type) {
+    var TypedRegister = /*#__PURE__*/function (_Register) {
+      _inherits(TypedRegister, _Register);
+
+      var _super2 = _createSuper(TypedRegister);
+
+      function TypedRegister(props) {
+        _classCallCheck(this, TypedRegister);
+
+        return _super2.call(this, props, type);
+      }
+
+      return TypedRegister;
+    }(Register);
+
+    return withEditorPrivateContext(TypedRegister);
+  };
+
+  return Register;
+}();
+
+export var RegisterNode = Register.create('node');
+export var RegisterEdge = Register.create('edge');
+export var RegisterCommand = Register.create('command');
+export var RegisterBehavior = Register.create('behavior');
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/helpers/index.d.ts b/node_modules/gg-editor/es/helpers/index.d.ts
new file mode 100644
index 0000000..2ce7294
--- /dev/null
+++ b/node_modules/gg-editor/es/helpers/index.d.ts
@@ -0,0 +1,2 @@
+import { GraphType } from '../../es/common/constants';
+export declare function track(graphType: GraphType): void;
diff --git a/node_modules/gg-editor/es/helpers/index.js b/node_modules/gg-editor/es/helpers/index.js
new file mode 100644
index 0000000..c56e043
--- /dev/null
+++ b/node_modules/gg-editor/es/helpers/index.js
@@ -0,0 +1,27 @@
+import global from '../../es/common/global';
+import { toQueryString } from '../../es/utils';
+var BASE_URL = 'http://gm.mmstat.com/fsp.1.1';
+export function track(graphType) {
+  var version = global.version;
+  var trackable = global.trackable;
+
+  if (!trackable) {
+    return;
+  }
+
+  var _window = window,
+      location = _window.location,
+      navigator = _window.navigator;
+  var image = new Image();
+  var params = toQueryString({
+    pid: 'ggeditor',
+    code: '11',
+    msg: 'syslog',
+    page: "".concat(location.protocol, "//").concat(location.host).concat(location.pathname),
+    hash: location.hash,
+    ua: navigator.userAgent,
+    rel: version,
+    c1: graphType
+  });
+  image.src = "".concat(BASE_URL, "?").concat(params);
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/index.d.ts b/node_modules/gg-editor/es/index.d.ts
new file mode 100644
index 0000000..fa5937e
--- /dev/null
+++ b/node_modules/gg-editor/es/index.d.ts
@@ -0,0 +1,22 @@
+import G6 from '@antv/g6';
+import '../es/shape';
+import * as Util from '../es/utils';
+import Editor from '../es/components/Editor';
+import Flow from '../es/components/Flow';
+import Mind from '../es/components/Mind';
+import Command from '../es/components/Command';
+import ItemPanel, { Item } from '../es/components/ItemPanel';
+import DetailPanel from '../es/components/DetailPanel';
+import { RegisterNode, RegisterEdge, RegisterCommand, RegisterBehavior } from '../es/components/Register';
+import { withEditorContext } from '../es/components/EditorContext';
+import { baseCommand } from '../es/components/Graph/command/base';
+import ItemPopover from '../es/plugins/ItemPopover';
+import ContextMenu from '../es/plugins/ContextMenu';
+import EditableLabel from '../es/plugins/EditableLabel';
+import global from '../es/common/global';
+import * as constants from '../es/common/constants';
+import CommandManager from '../es/common/CommandManager';
+import behaviorManager from '../es/common/behaviorManager';
+import { setAnchorPointsState } from '../es/shape/common/anchor';
+export { G6, Util, Flow, Mind, Command, Item, ItemPanel, DetailPanel, RegisterNode, RegisterEdge, RegisterCommand, RegisterBehavior, withEditorContext, baseCommand, ItemPopover, ContextMenu, EditableLabel, global, constants, CommandManager, behaviorManager, setAnchorPointsState, };
+export default Editor;
diff --git a/node_modules/gg-editor/es/index.js b/node_modules/gg-editor/es/index.js
index ae84284..1080567 100644
--- a/node_modules/gg-editor/es/index.js
+++ b/node_modules/gg-editor/es/index.js
@@ -1,3808 +1,22 @@
 import G6 from '@antv/g6';
-export { default as G6 } from '@antv/g6';
-import _extends from '@babel/runtime/helpers/esm/extends';
-import merge from 'lodash/merge';
-import isArray from 'lodash/isArray';
-import _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';
-import React from 'react';
-import pick from 'lodash/pick';
-import cloneDeep from 'lodash/cloneDeep';
-import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
-import _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';
-import omit from 'lodash/omit';
-import isPlainObject from 'lodash/isPlainObject';
-import ReactDOM from 'react-dom';
-import delay from 'lodash/delay';
-
-var FLOW_CONTAINER_ID = 'J_FlowContainer';
-var MIND_CONTAINER_ID = 'J_MindContainer';
-var LABEL_DEFAULT_TEXT = '新建节点';
-var RendererType;
-
-(function (RendererType) {
-  RendererType["Canvas"] = "canvas";
-  RendererType["Svg"] = "svg";
-})(RendererType || (RendererType = {}));
-
-var ItemType;
-
-(function (ItemType) {
-  ItemType["Node"] = "node";
-  ItemType["Edge"] = "edge";
-})(ItemType || (ItemType = {}));
-
-var ItemState;
-
-(function (ItemState) {
-  ItemState["Active"] = "active";
-  ItemState["ActiveAnchorPoints"] = "activeAnchorPoints";
-  ItemState["Selected"] = "selected";
-  ItemState["HighLight"] = "highLight";
-  ItemState["Error"] = "error";
-})(ItemState || (ItemState = {}));
-
-var GraphType;
-
-(function (GraphType) {
-  GraphType["Flow"] = "flow";
-  GraphType["Mind"] = "mind";
-})(GraphType || (GraphType = {}));
-
-var GraphMode;
-
-(function (GraphMode) {
-  GraphMode["Default"] = "default";
-  GraphMode["AddNode"] = "addNode";
-  GraphMode["Readonly"] = "readonly";
-})(GraphMode || (GraphMode = {}));
-
-var GraphState;
-
-(function (GraphState) {
-  GraphState["NodeSelected"] = "nodeSelected";
-  GraphState["EdgeSelected"] = "edgeSelected";
-  GraphState["MultiSelected"] = "multiSelected";
-  GraphState["CanvasSelected"] = "canvasSelected";
-})(GraphState || (GraphState = {}));
-
-var LabelState;
-
-(function (LabelState) {
-  LabelState["Hide"] = "hide";
-  LabelState["Show"] = "show";
-})(LabelState || (LabelState = {}));
-
-var AnchorPointState;
-
-(function (AnchorPointState) {
-  AnchorPointState["Enabled"] = "enabled";
-  AnchorPointState["Disabled"] = "disabled";
-})(AnchorPointState || (AnchorPointState = {}));
-
-var EditorEvent;
-
-(function (EditorEvent) {
-  /** 调用命令之前触发 */
-  EditorEvent["onBeforeExecuteCommand"] = "onBeforeExecuteCommand";
-  /** 调用命令之后触发 */
-
-  EditorEvent["onAfterExecuteCommand"] = "onAfterExecuteCommand";
-  /** 改变画面状态触发 */
-
-  EditorEvent["onGraphStateChange"] = "onGraphStateChange";
-  /** 改变标签状态触发 */
-
-  EditorEvent["onLabelStateChange"] = "onLabelStateChange";
-})(EditorEvent || (EditorEvent = {}));
-
-var EditorCommand;
-
-(function (EditorCommand) {
-  /** 撤销 */
-  EditorCommand["Undo"] = "undo";
-  /** 重做 */
-
-  EditorCommand["Redo"] = "redo";
-  /** 添加 */
-
-  EditorCommand["Add"] = "add";
-  /** 更新 */
-
-  EditorCommand["Update"] = "update";
-  /** 删除 */
-
-  EditorCommand["Remove"] = "remove";
-  /** 复制 */
-
-  EditorCommand["Copy"] = "copy";
-  /** 粘贴 */
-
-  EditorCommand["Paste"] = "paste";
-  /** 粘贴到这里 */
-
-  EditorCommand["PasteHere"] = "pasteHere";
-  /** 放大 */
-
-  EditorCommand["ZoomIn"] = "zoomIn";
-  /** 缩小 */
-
-  EditorCommand["ZoomOut"] = "zoomOut";
-  /** 插入主题 */
-
-  EditorCommand["Topic"] = "topic";
-  /** 插入子主题 */
-
-  EditorCommand["Subtopic"] = "subtopic";
-  /** 收起 */
-
-  EditorCommand["Fold"] = "fold";
-  /** 展开 */
-
-  EditorCommand["Unfold"] = "unfold";
-})(EditorCommand || (EditorCommand = {}));
-
-var GraphCommonEvent;
-
-(function (GraphCommonEvent) {
-  /** 单击鼠标左键或者按下回车键时触发 */
-  GraphCommonEvent["onClick"] = "click";
-  /** 双击鼠标左键时触发 */
-
-  GraphCommonEvent["onDoubleClick"] = "dblclick";
-  /** 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 */
-
-  GraphCommonEvent["onMouseEnter"] = "mouseenter";
-  /** 鼠标在元素内部移到时不断触发，不能通过键盘触发 */
-
-  GraphCommonEvent["onMouseMove"] = "mousemove";
-  /** 鼠标移出目标元素后触发 */
-
-  GraphCommonEvent["onMouseOut"] = "mouseout";
-  /** 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 */
-
-  GraphCommonEvent["onMouseOver"] = "mouseover";
-  /** 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 */
-
-  GraphCommonEvent["onMouseLeave"] = "mouseleave";
-  /** 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphCommonEvent["onMouseDown"] = "mousedown";
-  /** 鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphCommonEvent["onMouseUp"] = "mouseup";
-  /** 用户右击鼠标时触发并打开上下文菜单 */
-
-  GraphCommonEvent["onContextMenu"] = "contextmenu";
-  /** 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 */
-
-  GraphCommonEvent["onDragStart"] = "dragstart";
-  /** 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 */
-
-  GraphCommonEvent["onDrag"] = "drag";
-  /** 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 */
-
-  GraphCommonEvent["onDragEnd"] = "dragend";
-  /** 当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCommonEvent["onDragEnter"] = "dragenter";
-  /** 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCommonEvent["onDragLeave"] = "dragleave";
-  /** 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
-
-  GraphCommonEvent["onDrop"] = "drop";
-  /** 按下键盘键触发该事件 */
-
-  GraphCommonEvent["onKeyDown"] = "keydown";
-  /** 释放键盘键触发该事件 */
-
-  GraphCommonEvent["onKeyUp"] = "keyup";
-  /** 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 */
-
-  GraphCommonEvent["onTouchStart"] = "touchstart";
-  /** 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault() 事件可以阻止滚动。 */
-
-  GraphCommonEvent["onTouchMove"] = "touchmove";
-  /** 当手指从屏幕上离开的时候触发 */
-
-  GraphCommonEvent["onTouchEnd"] = "touchend";
-})(GraphCommonEvent || (GraphCommonEvent = {}));
-
-var GraphNodeEvent;
-
-(function (GraphNodeEvent) {
-  /** 鼠标左键单击节点时触发 */
-  GraphNodeEvent["onNodeClick"] = "node:click";
-  /** 鼠标双击左键节点时触发 */
-
-  GraphNodeEvent["onNodeDoubleClick"] = "node:dblclick";
-  /** 鼠标移入节点时触发 */
-
-  GraphNodeEvent["onNodeMouseEnter"] = "node:mouseenter";
-  /** 鼠标在节点内部移到时不断触发，不能通过键盘触发 */
-
-  GraphNodeEvent["onNodeMouseMove"] = "node:mousemove";
-  /** 鼠标移出节点后触发 */
-
-  GraphNodeEvent["onNodeMouseOut"] = "node:mouseout";
-  /** 鼠标移入节点上方时触发 */
-
-  GraphNodeEvent["onNodeMouseOver"] = "node:mouseover";
-  /** 鼠标移出节点时触发 */
-
-  GraphNodeEvent["onNodeMouseLeave"] = "node:mouseleave";
-  /** 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphNodeEvent["onNodeMouseDown"] = "node:mousedown";
-  /** 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphNodeEvent["onNodeMouseUp"] = "node:mouseup";
-  /** 用户在节点上右击鼠标时触发并打开右键菜单 */
-
-  GraphNodeEvent["onNodeContextMenu"] = "node:contextmenu";
-  /** 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 */
-
-  GraphNodeEvent["onNodeDragStart"] = "node:dragstart";
-  /** 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 */
-
-  GraphNodeEvent["onNodeDrag"] = "node:drag";
-  /** 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 */
-
-  GraphNodeEvent["onNodeDragEnd"] = "node:dragend";
-  /** 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphNodeEvent["onNodeDragEnter"] = "node:dragenter";
-  /** 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphNodeEvent["onNodeDragLeave"] = "node:dragleave";
-  /** 被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
-
-  GraphNodeEvent["onNodeDrop"] = "node:drop";
-})(GraphNodeEvent || (GraphNodeEvent = {}));
-
-var GraphEdgeEvent;
-
-(function (GraphEdgeEvent) {
-  /** 鼠标左键单击边时触发 */
-  GraphEdgeEvent["onEdgeClick"] = "edge:click";
-  /** 鼠标双击左键边时触发 */
-
-  GraphEdgeEvent["onEdgeDoubleClick"] = "edge:dblclick";
-  /** 鼠标移入边时触发 */
-
-  GraphEdgeEvent["onEdgeMouseEnter"] = "edge:mouseenter";
-  /** 鼠标在边上移到时不断触发，不能通过键盘触发 */
-
-  GraphEdgeEvent["onEdgeMouseMove"] = "edge:mousemove";
-  /** 鼠标移出边后触发 */
-
-  GraphEdgeEvent["onEdgeMouseOut"] = "edge:mouseout";
-  /** 鼠标移入边上方时触发 */
-
-  GraphEdgeEvent["onEdgeMouseOver"] = "edge:mouseover";
-  /** 鼠标移出边时触发 */
-
-  GraphEdgeEvent["onEdgeMouseLeave"] = "edge:mouseleave";
-  /** 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphEdgeEvent["onEdgeMouseDown"] = "edge:mousedown";
-  /** 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphEdgeEvent["onEdgeMouseUp"] = "edge:mouseup";
-  /** 用户在边上右击鼠标时触发并打开右键菜单 */
-
-  GraphEdgeEvent["onEdgeContextMenu"] = "edge:contextmenu";
-})(GraphEdgeEvent || (GraphEdgeEvent = {}));
-
-var GraphCanvasEvent;
-
-(function (GraphCanvasEvent) {
-  /** 鼠标左键单击画布时触发 */
-  GraphCanvasEvent["onCanvasClick"] = "canvas:click";
-  /** 鼠标双击左键画布时触发 */
-
-  GraphCanvasEvent["onCanvasDoubleClick"] = "canvas:dblclick";
-  /** 鼠标移入画布时触发 */
-
-  GraphCanvasEvent["onCanvasMouseEnter"] = "canvas:mouseenter";
-  /** 鼠标在画布内部移到时不断触发，不能通过键盘触发 */
-
-  GraphCanvasEvent["onCanvasMouseMove"] = "canvas:mousemove";
-  /** 鼠标移出画布后触发 */
-
-  GraphCanvasEvent["onCanvasMouseOut"] = "canvas:mouseout";
-  /** 鼠标移入画布上方时触发 */
-
-  GraphCanvasEvent["onCanvasMouseOver"] = "canvas:mouseover";
-  /** 鼠标移出画布时触发 */
-
-  GraphCanvasEvent["onCanvasMouseLeave"] = "canvas:mouseleave";
-  /** 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphCanvasEvent["onCanvasMouseDown"] = "canvas:mousedown";
-  /** 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphCanvasEvent["onCanvasMouseUp"] = "canvas:mouseup";
-  /** 用户在画布上右击鼠标时触发并打开右键菜单 */
-
-  GraphCanvasEvent["onCanvasContextMenu"] = "canvas:contextmenu";
-  /** 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 */
-
-  GraphCanvasEvent["onCanvasDragStart"] = "canvas:dragstart";
-  /** 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 */
-
-  GraphCanvasEvent["onCanvasDrag"] = "canvas:drag";
-  /** 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 */
-
-  GraphCanvasEvent["onCanvasDragEnd"] = "canvas:dragend";
-  /** 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCanvasEvent["onCanvasDragEnter"] = "canvas:dragenter";
-  /** 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCanvasEvent["onCanvasDragLeave"] = "canvas:dragleave";
-})(GraphCanvasEvent || (GraphCanvasEvent = {}));
-
-var GraphCustomEvent;
-
-(function (GraphCustomEvent) {
-  /** 调用 add / addItem 方法之前触发 */
-  GraphCustomEvent["onBeforeAddItem"] = "beforeadditem";
-  /** 调用 add / addItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterAddItem"] = "afteradditem";
-  /** 调用 remove / removeItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeRemoveItem"] = "beforeremoveitem";
-  /** 调用 remove / removeItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterRemoveItem"] = "afterremoveitem";
-  /** 调用 update / updateItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeUpdateItem"] = "beforeupdateitem";
-  /** 调用 update / updateItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterUpdateItem"] = "afterupdateitem";
-  /** 调用 showItem / hideItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeItemVisibilityChange"] = "beforeitemvisibilitychange";
-  /** 调用 showItem / hideItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterItemVisibilityChange"] = "afteritemvisibilitychange";
-  /** 调用 setItemState 方法之前触发 */
-
-  GraphCustomEvent["onBeforeItemStateChange"] = "beforeitemstatechange";
-  /** 调用 setItemState 方法之后触发 */
-
-  GraphCustomEvent["onAfterItemStateChange"] = "afteritemstatechange";
-  /** 调用 refreshItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeRefreshItem"] = "beforerefreshitem";
-  /** 调用 refreshItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterRefreshItem"] = "afterrefreshitem";
-  /** 调用 clearItemStates 方法之前触发 */
-
-  GraphCustomEvent["onBeforeItemStatesClear"] = "beforeitemstatesclear";
-  /** 调用 clearItemStates 方法之后触发 */
-
-  GraphCustomEvent["onAfterItemStatesClear"] = "afteritemstatesclear";
-  /** 布局前触发。调用 render 时会进行布局，因此 render 时会触发。或用户主动调用图的 layout 时触发 */
-
-  GraphCustomEvent["onBeforeLayout"] = "beforelayout";
-  /** 布局完成后触发。调用 render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 layout 时布局完成后触发 */
-
-  GraphCustomEvent["onAfterLayout"] = "afterlayout";
-  /** 连线完成之前触发 */
-
-  GraphCustomEvent["onBeforeConnect"] = "beforeconnect";
-  /** 连线完成之后触发 */
-
-  GraphCustomEvent["onAfterConnect"] = "afterconnect";
-})(GraphCustomEvent || (GraphCustomEvent = {}));
-
-var index = /*#__PURE__*/Object.freeze({
-  __proto__: null,
-  FLOW_CONTAINER_ID: FLOW_CONTAINER_ID,
-  MIND_CONTAINER_ID: MIND_CONTAINER_ID,
-  LABEL_DEFAULT_TEXT: LABEL_DEFAULT_TEXT,
-  get RendererType () { return RendererType; },
-  get ItemType () { return ItemType; },
-  get ItemState () { return ItemState; },
-  get GraphType () { return GraphType; },
-  get GraphMode () { return GraphMode; },
-  get GraphState () { return GraphState; },
-  get LabelState () { return LabelState; },
-  get AnchorPointState () { return AnchorPointState; },
-  get EditorEvent () { return EditorEvent; },
-  get EditorCommand () { return EditorCommand; },
-  get GraphCommonEvent () { return GraphCommonEvent; },
-  get GraphNodeEvent () { return GraphNodeEvent; },
-  get GraphEdgeEvent () { return GraphEdgeEvent; },
-  get GraphCanvasEvent () { return GraphCanvasEvent; },
-  get GraphCustomEvent () { return GraphCustomEvent; }
-});
-
-function _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } i = o[Symbol.iterator](); return i.next.bind(i); }
-
-function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
-
-function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
-
-var canvas = document.createElement('canvas');
-var canvasContext = canvas.getContext('2d');
-function getNodeSide(item) {
-  var model = item.getModel();
-
-  if (model.side) {
-    return model.side;
-  }
-
-  var parent = item.get('parent');
-
-  if (parent) {
-    return getNodeSide(parent);
-  }
-
-  return 'right';
-}
-function getRectPath(x, y, w, h, r) {
-  if (r) {
-    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
-  }
-
-  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
-  res.toString = toString;
-  return res;
-}
-function getFoldButtonPath() {
-  var w = 14;
-  var h = 14;
-  var rect = getRectPath(0, 0, w, h, 2);
-  var hp = "M" + w * 3 / 14 + "," + h / 2 + "L" + w * 11 / 14 + "," + h / 2;
-  var vp = '';
-  return rect + hp + vp;
-}
-function getUnfoldButtonPath() {
-  var w = 14;
-  var h = 14;
-  var rect = getRectPath(0, 0, w, h, 2);
-  var hp = "M" + w * 3 / 14 + "," + h / 2 + "L" + w * 11 / 14 + "," + h / 2;
-  var vp = "M" + w / 2 + "," + h * 3 / 14 + "L" + w / 2 + "," + h * 11 / 14;
-  return rect + hp + vp;
-}
-function optimizeMultilineText(text, font, maxRows, maxWidth) {
-  canvasContext.font = font;
-
-  if (canvasContext.measureText(text).width <= maxWidth) {
-    return text;
-  }
-
-  var multilineText = [];
-  var tempText = '';
-  var tempTextWidth = 0;
-
-  for (var _iterator = _createForOfIteratorHelperLoose(text), _step; !(_step = _iterator()).done;) {
-    var _char2 = _step.value;
-
-    var _canvasContext$measur2 = canvasContext.measureText(_char2),
-        _width = _canvasContext$measur2.width;
-
-    if (tempTextWidth + _width >= maxWidth) {
-      multilineText.push(tempText);
-      tempText = '';
-      tempTextWidth = 0;
-    }
-
-    tempText += _char2;
-    tempTextWidth += _width;
-  }
-
-  if (tempText) {
-    multilineText.push(tempText);
-  }
-
-  if (multilineText.length > maxRows) {
-    var ellipsis = '...';
-    var ellipsisWidth = canvasContext.measureText(ellipsis).width;
-    var _tempText = '';
-    var _tempTextWidth = 0;
-
-    for (var _iterator2 = _createForOfIteratorHelperLoose(multilineText[maxRows - 1]), _step2; !(_step2 = _iterator2()).done;) {
-      var _char = _step2.value;
-
-      var _canvasContext$measur = canvasContext.measureText(_char),
-          width = _canvasContext$measur.width;
-
-      if (_tempTextWidth + width > maxWidth - ellipsisWidth) {
-        break;
-      }
-
-      _tempText += _char;
-      _tempTextWidth += width;
-    }
-
-    multilineText = multilineText.slice(0, maxRows - 1).concat("" + _tempText + ellipsis);
-  }
-
-  return multilineText.join('\n');
-}
-
-var _stateStyles;
-var WRAPPER_BORDER_WIDTH = 2;
-var WRAPPER_HORIZONTAL_PADDING = 10;
-var WRAPPER_CLASS_NAME = 'node-wrapper';
-var CONTENT_CLASS_NAME = 'node-content';
-var LABEL_CLASS_NAME = 'node-label';
-var bizNode = {
-  options: {
-    size: [120, 60],
-    wrapperStyle: {
-      fill: '#5487ea',
-      radius: 8
-    },
-    contentStyle: {
-      fill: '#ffffff',
-      radius: 6
-    },
-    labelStyle: {
-      fill: '#000000',
-      textAlign: 'center',
-      textBaseline: 'middle'
-    },
-    stateStyles: (_stateStyles = {}, _stateStyles[ItemState.Active] = {
-      wrapperStyle: {},
-      contentStyle: {},
-      labelStyle: {}
-    }, _stateStyles[ItemState.Selected] = {
-      wrapperStyle: {},
-      contentStyle: {},
-      labelStyle: {}
-    }, _stateStyles)
-  },
-  getOptions: function getOptions(model) {
-    return merge({}, this.options, this.getCustomConfig(model) || {}, model);
-  },
-  draw: function draw(model, group) {
-    var keyShape = this.drawWrapper(model, group);
-    this.drawContent(model, group);
-    this.drawLabel(model, group);
-    return keyShape;
-  },
-  drawWrapper: function drawWrapper(model, group) {
-    var _this$getSize = this.getSize(model),
-        width = _this$getSize[0],
-        height = _this$getSize[1];
-
-    var _this$getOptions = this.getOptions(model),
-        wrapperStyle = _this$getOptions.wrapperStyle;
-
-    var shape = group.addShape('rect', {
-      className: WRAPPER_CLASS_NAME,
-      draggable: true,
-      attrs: _extends({
-        x: 0,
-        y: -WRAPPER_BORDER_WIDTH * 2,
-        width: width,
-        height: height + WRAPPER_BORDER_WIDTH * 2
-      }, wrapperStyle)
-    });
-    return shape;
-  },
-  drawContent: function drawContent(model, group) {
-    var _this$getSize2 = this.getSize(model),
-        width = _this$getSize2[0],
-        height = _this$getSize2[1];
-
-    var _this$getOptions2 = this.getOptions(model),
-        contentStyle = _this$getOptions2.contentStyle;
-
-    var shape = group.addShape('rect', {
-      className: CONTENT_CLASS_NAME,
-      draggable: true,
-      attrs: _extends({
-        x: 0,
-        y: 0,
-        width: width,
-        height: height
-      }, contentStyle)
-    });
-    return shape;
-  },
-  drawLabel: function drawLabel(model, group) {
-    var _this$getSize3 = this.getSize(model),
-        width = _this$getSize3[0],
-        height = _this$getSize3[1];
-
-    var _this$getOptions3 = this.getOptions(model),
-        labelStyle = _this$getOptions3.labelStyle;
-
-    var shape = group.addShape('text', {
-      className: LABEL_CLASS_NAME,
-      draggable: true,
-      attrs: _extends({
-        x: width / 2,
-        y: height / 2,
-        text: model.label
-      }, labelStyle)
-    });
-    return shape;
-  },
-  setLabelText: function setLabelText(model, group) {
-    var shape = group.findByClassName(LABEL_CLASS_NAME);
-
-    if (!shape) {
-      return;
-    }
-
-    var _this$getSize4 = this.getSize(model),
-        width = _this$getSize4[0];
-
-    var _shape$attr = shape.attr(),
-        fontStyle = _shape$attr.fontStyle,
-        fontWeight = _shape$attr.fontWeight,
-        fontSize = _shape$attr.fontSize,
-        fontFamily = _shape$attr.fontFamily;
-
-    var text = model.label;
-    var font = fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily;
-    shape.attr('text', optimizeMultilineText(text, font, 2, width - WRAPPER_HORIZONTAL_PADDING * 2));
-  },
-  update: function update(model, item) {
-    var group = item.getContainer();
-    this.setLabelText(model, group);
-  },
-  setState: function setState(name, value, item) {
-    var _this = this;
-
-    var group = item.getContainer();
-    var model = item.getModel();
-    var states = item.getStates();
-    [WRAPPER_CLASS_NAME, CONTENT_CLASS_NAME, LABEL_CLASS_NAME].forEach(function (className) {
-      var shape = group.findByClassName(className);
-
-      var options = _this.getOptions(model);
-
-      var shapeName = className.split('-')[1];
-      shape.attr(_extends({}, options[shapeName + "Style"]));
-      states.forEach(function (state) {
-        if (options.stateStyles[state] && options.stateStyles[state][shapeName + "Style"]) {
-          shape.attr(_extends({}, options.stateStyles[state][shapeName + "Style"]));
-        }
-      });
-    });
-
-    if (name === ItemState.Selected) {
-      var wrapperShape = group.findByClassName(WRAPPER_CLASS_NAME);
-
-      var _this$getSize5 = this.getSize(model),
-          width = _this$getSize5[0],
-          height = _this$getSize5[1];
-
-      if (value) {
-        wrapperShape.attr({
-          x: -WRAPPER_BORDER_WIDTH,
-          y: -WRAPPER_BORDER_WIDTH * 2,
-          width: width + WRAPPER_BORDER_WIDTH * 2,
-          height: height + WRAPPER_BORDER_WIDTH * 3
-        });
-      } else {
-        wrapperShape.attr({
-          x: 0,
-          y: -WRAPPER_BORDER_WIDTH * 2,
-          width: width,
-          height: height + WRAPPER_BORDER_WIDTH * 2
-        });
-      }
-    }
-
-    if (this.afterSetState) {
-      this.afterSetState(name, value, item);
-    }
-  },
-  getSize: function getSize(model) {
-    var _this$getOptions4 = this.getOptions(model),
-        size = _this$getOptions4.size;
-
-    if (!isArray(size)) {
-      return [size, size];
-    }
-
-    return size;
-  },
-  getCustomConfig: function getCustomConfig() {
-    return {};
-  },
-  getAnchorPoints: function getAnchorPoints() {
-    return [];
-  }
-};
-G6.registerNode('bizNode', bizNode);
-
-var ANCHOR_POINT_NAME = 'anchorPoint';
-
-var getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {
-  var _item$getKeyShape$get = item.getKeyShape().getBBox(),
-      width = _item$getKeyShape$get.width,
-      height = _item$getKeyShape$get.height;
-
-  var x = anchorPoint[0],
-      y = anchorPoint[1];
-  return {
-    x: width * x,
-    y: height * y - 3,
-    r: 3,
-    lineWidth: 2,
-    fill: '#FFFFFF',
-    stroke: '#5AAAFF'
-  };
-};
-
-var getAnchorPointDefaultDisabledStyle = function getAnchorPointDefaultDisabledStyle(item, anchorPoint) {
-  var _item$getKeyShape$get2 = item.getKeyShape().getBBox(),
-      width = _item$getKeyShape$get2.width,
-      height = _item$getKeyShape$get2.height;
-
-  var x = anchorPoint[0],
-      y = anchorPoint[1];
-  return {
-    img: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0xLjUxNSAxLjE3Mmw1LjY1NyA1LjY1Nm0wLTUuNjU2TDEuNTE1IDYuODI4IiBzdHJva2U9IiNGRjYwNjAiIHN0cm9rZS13aWR0aD0iMS42IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIi8+PC9zdmc+',
-    x: width * x - 4,
-    y: height * y - 8,
-    width: 8,
-    height: 8
-  };
-};
-
-function drawAnchorPoints(item, getAnchorPointStyle, getAnchorPointDisabledStyle) {
-  var group = item.getContainer();
-  var model = item.getModel();
-  var anchorPoints = this.getAnchorPoints ? this.getAnchorPoints(model) : [];
-  var anchorPointsState = item.get('anchorPointsState') || [];
-  anchorPoints.forEach(function (anchorPoint, index) {
-    if (anchorPointsState[index] === AnchorPointState.Enabled) {
-      group.addShape('circle', {
-        name: ANCHOR_POINT_NAME,
-        attrs: _extends({}, getAnchorPointDefaultStyle(item, anchorPoint), {}, getAnchorPointStyle(item, anchorPoint)),
-        isAnchorPoint: true,
-        anchorPointIndex: index,
-        anchorPointState: AnchorPointState.Enabled
-      });
-    } else {
-      group.addShape('image', {
-        name: ANCHOR_POINT_NAME,
-        attrs: _extends({}, getAnchorPointDefaultDisabledStyle(item, anchorPoint), {}, getAnchorPointDisabledStyle(item, anchorPoint)),
-        isAnchorPoint: true,
-        anchorPointIndex: index,
-        anchorPointState: AnchorPointState.Disabled
-      });
-    }
-  });
-}
-
-function removeAnchorPoints(item) {
-  var group = item.getContainer();
-  var anchorPoints = group.findAllByName(ANCHOR_POINT_NAME);
-  anchorPoints.forEach(function (anchorPoint) {
-    group.removeChild(anchorPoint);
-  });
-}
-
-function setAnchorPointsState(name, value, item, getAnchorPointStyle, getAnchorPointDisabledStyle) {
-  if (getAnchorPointStyle === void 0) {
-    getAnchorPointStyle = function getAnchorPointStyle() {
-      return {};
-    };
-  }
-
-  if (getAnchorPointDisabledStyle === void 0) {
-    getAnchorPointDisabledStyle = function getAnchorPointDisabledStyle() {
-      return {};
-    };
-  }
-
-  if (name !== ItemState.ActiveAnchorPoints) {
-    return;
-  }
-
-  if (value) {
-    drawAnchorPoints.call(this, item, getAnchorPointStyle, getAnchorPointDisabledStyle);
-  } else {
-    removeAnchorPoints.call(this, item);
-  }
-}
-
-var bizFlowNode = {
-  afterSetState: function afterSetState(name, value, item) {
-    setAnchorPointsState.call(this, name, value, item);
-  },
-  getAnchorPoints: function getAnchorPoints() {
-    return [[0.5, 0], [0.5, 1], [0, 0.5], [1, 0.5]];
-  }
-};
-G6.registerNode('bizFlowNode', bizFlowNode, 'bizNode');
-
-var FOLD_BUTTON_CLASS_NAME = 'node-fold-button';
-var UNFOLD_BUTTON_CLASS_NAME = 'node-unfold-button';
-var bizMindNode = {
-  afterDraw: function afterDraw(model, group) {
-    this.drawButton(model, group);
-  },
-  afterUpdate: function afterUpdate(model, item) {
-    var group = item.getContainer();
-    this.drawButton(model, group);
-    this.adjustButton(model, item);
-  },
-  drawButton: function drawButton(model, group) {
-    var children = model.children,
-        collapsed = model.collapsed;
-    [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].forEach(function (className) {
-      var shape = group.findByClassName(className);
-
-      if (shape) {
-        shape.destroy();
-      }
-    });
-
-    if (!children || !children.length) {
-      return;
-    }
-
-    if (!collapsed) {
-      group.addShape('path', {
-        className: FOLD_BUTTON_CLASS_NAME,
-        attrs: {
-          path: getFoldButtonPath(),
-          fill: '#ffffff',
-          stroke: '#ccc1d8'
-        }
-      });
-    } else {
-      group.addShape('path', {
-        className: UNFOLD_BUTTON_CLASS_NAME,
-        attrs: {
-          path: getUnfoldButtonPath(),
-          fill: '#ffffff',
-          stroke: '#ccc1d8'
-        }
-      });
-    }
-  },
-  adjustButton: function adjustButton(model, item) {
-    var children = model.children,
-        collapsed = model.collapsed;
-
-    if (!children || !children.length) {
-      return;
-    }
-
-    var group = item.getContainer();
-    var shape = group.findByClassName(!collapsed ? FOLD_BUTTON_CLASS_NAME : UNFOLD_BUTTON_CLASS_NAME);
-
-    var _this$getSize = this.getSize(model),
-        width = _this$getSize[0],
-        height = _this$getSize[1];
-
-    var x = getNodeSide(item) === 'left' ? -24 : width + 10;
-    var y = height / 2 - 9;
-    shape.translate(x, y);
-  },
-  getAnchorPoints: function getAnchorPoints() {
-    return [[0, 0.5], [1, 0.5]];
-  }
-};
-G6.registerNode('bizMindNode', bizMindNode, 'bizNode');
-
-var _stateStyles$1;
-var EDGE_LABEL_CLASS_NAME = 'edge-label';
-var EDGE_LABEL_WRAPPER_CLASS_NAME = 'edge-label-wrapper-label';
-var bizFlowEdge = {
-  options: {
-    style: {
-      stroke: '#ccc1d8',
-      lineWidth: 2,
-      shadowColor: null,
-      shadowBlur: 0,
-      radius: 8,
-      offset: 24,
-      // startArrow: {
-      //   path: 'M 3,0 A 3,3,0,1,1,-3,0 A 3,3,0,1,1,3,0 Z',
-      //   d: 7,
-      // },
-      // endArrow: {
-      //   path: 'M 3,0 L -3,-3 L -3,3 Z',
-      //   d: 5,
-      // },
-      endArrow: {
-        path: 'M 0,0 L 4,3 L 4,-3 Z'
-      }
-    },
-    labelCfg: {
-      style: {
-        fill: '#000000',
-        fontSize: 10
-      }
-    },
-    stateStyles: (_stateStyles$1 = {}, _stateStyles$1[ItemState.Selected] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$1[ItemState.HighLight] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$1)
-  },
-  createLabelWrapper: function createLabelWrapper(group) {
-    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
-    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
-
-    if (!label) {
-      return;
-    }
-
-    if (labelWrapper) {
-      return;
-    }
-
-    group.addShape('rect', {
-      className: EDGE_LABEL_WRAPPER_CLASS_NAME,
-      attrs: {
-        fill: '#e1e5e8',
-        radius: 2
-      }
-    });
-    label.set('zIndex', 1);
-    group.sort();
-  },
-  updateLabelWrapper: function updateLabelWrapper(group) {
-    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
-    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
-
-    if (!label) {
-      labelWrapper && labelWrapper.hide();
-      return;
-    } else {
-      labelWrapper && labelWrapper.show();
-    }
-
-    if (!labelWrapper) {
-      return;
-    }
-
-    var _label$getBBox = label.getBBox(),
-        minX = _label$getBBox.minX,
-        minY = _label$getBBox.minY,
-        width = _label$getBBox.width,
-        height = _label$getBBox.height;
-
-    labelWrapper.attr({
-      x: minX - 5,
-      y: minY - 3,
-      width: width + 10,
-      height: height + 6
-    });
-  },
-  afterDraw: function afterDraw(model, group) {
-    this.createLabelWrapper(group);
-    this.updateLabelWrapper(group);
-  },
-  afterUpdate: function afterUpdate(model, item) {
-    var group = item.getContainer();
-    this.createLabelWrapper(group);
-    this.updateLabelWrapper(group);
-  },
-  setState: function setState(name, value, item) {
-    var shape = item.get('keyShape');
-
-    if (!shape) {
-      return;
-    }
-
-    var _this$options = this.options,
-        style = _this$options.style,
-        stateStyles = _this$options.stateStyles;
-    var stateStyle = stateStyles[name];
-
-    if (!stateStyle) {
-      return;
-    }
-
-    if (value) {
-      shape.attr(_extends({}, style, {}, stateStyle));
-    } else {
-      shape.attr(style);
-    }
-  }
-};
-G6.registerEdge('bizFlowEdge', bizFlowEdge, 'polyline');
-
-var _stateStyles$2;
-var bizMindEdge = {
-  options: {
-    style: {
-      stroke: '#ccc1d8',
-      lineWidth: 2,
-      shadowColor: null,
-      shadowBlur: 0
-    },
-    stateStyles: (_stateStyles$2 = {}, _stateStyles$2[ItemState.Selected] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$2[ItemState.HighLight] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$2)
-  }
-};
-G6.registerEdge('bizMindEdge', bizMindEdge, 'cubic-horizontal');
-
-/** 生成唯一标识 */
-
-function guid() {
-  return 'xxxxxxxx'.replace(/[xy]/g, function (c) {
-    var r = Math.random() * 16 | 0;
-    var v = c === 'x' ? r : r & 0x3 | 0x8;
-    return v.toString(16);
-  });
-}
-/** 拼接查询字符 */
-
-var toQueryString = function toQueryString(obj) {
-  return Object.keys(obj).map(function (key) {
-    return encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]);
-  }).join('&');
-};
-/** 执行批量处理 */
-
-function executeBatch(graph, execute) {
-  var autoPaint = graph.get('autoPaint');
-  graph.setAutoPaint(false);
-  execute();
-  graph.paint();
-  graph.setAutoPaint(autoPaint);
-}
-/** 执行递归遍历 */
-
-function recursiveTraversal(root, callback) {
-  if (!root) {
-    return;
-  }
-
-  callback(root);
-
-  if (!root.children) {
-    return;
-  }
-
-  root.children.forEach(function (item) {
-    return recursiveTraversal(item, callback);
-  });
-}
-/** 判断是否流程图 */
-
-function isFlow(graph) {
-  return graph.constructor === G6.Graph;
-}
-/** 判断是否脑图 */
-
-function isMind(graph) {
-  return graph.constructor === G6.TreeGraph;
-}
-/** 判断是否节点 */
-
-function isNode(item) {
-  return item.getType() === ItemType.Node;
-}
-/** 判断是否边线 */
-
-function isEdge(item) {
-  return item.getType() === ItemType.Edge;
-}
-/** 获取选中节点 */
-
-function getSelectedNodes(graph) {
-  return graph.findAllByState(ItemType.Node, ItemState.Selected);
-}
-/** 获取选中边线 */
-
-function getSelectedEdges(graph) {
-  return graph.findAllByState(ItemType.Edge, ItemState.Selected);
-}
-/** 获取高亮边线 */
-
-function getHighlightEdges(graph) {
-  return graph.findAllByState(ItemType.Edge, ItemState.HighLight);
-}
-/** 获取图表状态 */
-
-function getGraphState(graph) {
-  var graphState = GraphState.MultiSelected;
-  var selectedNodes = getSelectedNodes(graph);
-  var selectedEdges = getSelectedEdges(graph);
-
-  if (selectedNodes.length === 1 && !selectedEdges.length) {
-    graphState = GraphState.NodeSelected;
-  }
-
-  if (selectedEdges.length === 1 && !selectedNodes.length) {
-    graphState = GraphState.EdgeSelected;
-  }
-
-  if (!selectedNodes.length && !selectedEdges.length) {
-    graphState = GraphState.CanvasSelected;
-  }
-
-  return graphState;
-}
-/** 设置选中元素 */
-
-function setSelectedItems(graph, items) {
-  executeBatch(graph, function () {
-    var selectedNodes = getSelectedNodes(graph);
-    var selectedEdges = getSelectedEdges(graph);
-    [].concat(selectedNodes, selectedEdges).forEach(function (node) {
-      graph.setItemState(node, ItemState.Selected, false);
-    });
-    items.forEach(function (item) {
-      graph.setItemState(item, ItemState.Selected, true);
-    });
-  });
-  graph.emit(EditorEvent.onGraphStateChange, {
-    graphState: getGraphState(graph)
-  });
-}
-/** 清除选中状态 */
-
-function clearSelectedState(graph, shouldUpdate) {
-  if (shouldUpdate === void 0) {
-    shouldUpdate = function shouldUpdate() {
-      return true;
-    };
-  }
-
-  var selectedNodes = getSelectedNodes(graph);
-  var selectedEdges = getSelectedEdges(graph);
-  executeBatch(graph, function () {
-    [].concat(selectedNodes, selectedEdges).forEach(function (item) {
-      if (shouldUpdate(item)) {
-        graph.setItemState(item, ItemState.Selected, false);
-      }
-    });
-  });
-}
-/** 获取回溯路径 - Flow */
-
-function getFlowRecallEdges(graph, node, targetIds, edges) {
-  if (targetIds === void 0) {
-    targetIds = [];
-  }
-
-  if (edges === void 0) {
-    edges = [];
-  }
-
-  var inEdges = node.getInEdges();
-
-  if (!inEdges.length) {
-    return [];
-  }
-
-  inEdges.map(function (edge) {
-    var sourceId = edge.getModel().source;
-    var sourceNode = graph.findById(sourceId);
-    edges.push(edge);
-    var targetId = node.get('id');
-    targetIds.push(targetId);
-
-    if (!targetIds.includes(sourceId)) {
-      getFlowRecallEdges(graph, sourceNode, targetIds, edges);
-    }
-  });
-  return edges;
-}
-/** 获取回溯路径 - Mind */
-
-function getMindRecallEdges(graph, node, edges) {
-  if (edges === void 0) {
-    edges = [];
-  }
-
-  var parentNode = node.get('parent');
-
-  if (!parentNode) {
-    return edges;
-  }
-
-  node.getEdges().forEach(function (edge) {
-    var sourceId = edge.getModel().source;
-
-    if (sourceId === parentNode.get('id')) {
-      edges.push(edge);
-    }
-  });
-  return getMindRecallEdges(graph, parentNode, edges);
-}
-
-var index$1 = /*#__PURE__*/Object.freeze({
-  __proto__: null,
-  guid: guid,
-  toQueryString: toQueryString,
-  executeBatch: executeBatch,
-  recursiveTraversal: recursiveTraversal,
-  isFlow: isFlow,
-  isMind: isMind,
-  isNode: isNode,
-  isEdge: isEdge,
-  getSelectedNodes: getSelectedNodes,
-  getSelectedEdges: getSelectedEdges,
-  getHighlightEdges: getHighlightEdges,
-  getGraphState: getGraphState,
-  setSelectedItems: setSelectedItems,
-  clearSelectedState: clearSelectedState,
-  getFlowRecallEdges: getFlowRecallEdges,
-  getMindRecallEdges: getMindRecallEdges
-});
-
-var Global = function Global() {
-  /** 当前版本 */
-  this.version = "3.1.1";
-  /** 埋点开关 */
-
-  this.trackable = true;
-  /** 剪贴板 */
-
-  this.clipboard = {
-    point: {
-      x: 0,
-      y: 0
-    },
-    models: []
-  };
-  /** 组件数据 */
-
-  this.component = {
-    itemPanel: {
-      model: null,
-      delegateShapeClassName: "delegateShape_" + guid()
-    }
-  };
-  /** 插件数据 */
-
-  this.plugin = {
-    itemPopover: {
-      state: 'hide'
-    },
-    contextMenu: {
-      state: 'hide'
-    },
-    editableLabel: {
-      state: 'hide'
-    }
-  };
-};
-
-var global = new Global();
-
-var CommandManager = /*#__PURE__*/function () {
-  function CommandManager() {
-    this.command = {};
-    this.commandQueue = [];
-    this.commandIndex = 0;
-  }
-  /** 注册命令 */
-
-
-  var _proto = CommandManager.prototype;
-
-  _proto.register = function register(name, command) {
-    this.command[name] = _extends({}, command, {
-      name: name
-    });
-  }
-  /** 执行命令 */
-  ;
-
-  _proto.execute = function execute(graph, name, params) {
-    var Command = this.command[name];
-
-    if (!Command) {
-      return;
-    }
-
-    var command = Object.create(Command);
-    command.params = cloneDeep(Command.params);
-
-    if (params) {
-      command.params = _extends({}, command.params, {}, params);
-    }
-
-    if (!command.canExecute(graph)) {
-      return;
-    }
-
-    if (!command.shouldExecute(graph)) {
-      return;
-    }
-
-    command.init(graph);
-    graph.emit(EditorEvent.onBeforeExecuteCommand, {
-      name: command.name,
-      params: command.params
-    });
-    command.execute(graph);
-    graph.emit(EditorEvent.onAfterExecuteCommand, {
-      name: command.name,
-      params: command.params
-    });
-
-    if (command.canUndo(graph)) {
-      var commandQueue = this.commandQueue,
-          commandIndex = this.commandIndex;
-      commandQueue.splice(commandIndex, commandQueue.length - commandIndex, command);
-      this.commandIndex += 1;
-    }
-
-    graph.emit(EditorEvent.onGraphStateChange, {
-      graphState: getGraphState(graph)
-    });
-  }
-  /** 判断是否可以执行 */
-  ;
-
-  _proto.canExecute = function canExecute(graph, name) {
-    return this.command[name].canExecute(graph);
-  }
-  /** 注入是否应该执行 */
-  ;
-
-  _proto.injectShouldExecute = function injectShouldExecute(name, shouldExecute) {
-    this.command[name].shouldExecute = shouldExecute;
-  };
-
-  return CommandManager;
-}();
-
-function withContext (Context, shouldRender) {
-  if (shouldRender === void 0) {
-    shouldRender = function shouldRender() {
-      return true;
-    };
-  }
-
-  return function (WrappedComponent) {
-    var InjectContext = function InjectContext(props) {
-      var forwardRef = props.forwardRef,
-          rest = _objectWithoutPropertiesLoose(props, ["forwardRef"]);
-
-      var refProp = {};
-
-      if (WrappedComponent.prototype.isReactComponent) {
-        refProp = {
-          ref: forwardRef
-        };
-      } else {
-        refProp = {
-          forwardRef: forwardRef
-        };
-      }
-
-      return React.createElement(Context.Consumer, null, function (context) {
-        return shouldRender(context) ? React.createElement(WrappedComponent, Object.assign({}, refProp, rest, context)) : null;
-      });
-    };
-
-    return React.forwardRef(function (props, ref) {
-      return React.createElement(InjectContext, Object.assign({
-        forwardRef: ref
-      }, props));
-    });
-  };
-}
-
-var EditorContext = React.createContext({});
-var EditorPrivateContext = React.createContext({});
-var withEditorContext = withContext(EditorContext, function (context) {
-  return !!context.graph;
-});
-var withEditorPrivateContext = withContext(EditorPrivateContext);
-
-var _Editor$defaultProps;
-
-var Editor = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Editor, _React$Component);
-
-  function Editor(props) {
-    var _this;
-
-    _this = _React$Component.call(this, props) || this;
-    _this.lastMousedownTarget = null;
-
-    _this.setGraph = function (graph) {
-      _this.setState({
-        graph: graph
-      });
-
-      _this.bindEvent(graph);
-
-      _this.bindShortcut(graph);
-    };
-
-    _this.executeCommand = function (name, params) {
-      var _this$state = _this.state,
-          graph = _this$state.graph,
-          commandManager = _this$state.commandManager;
-
-      if (graph) {
-        commandManager.execute(graph, name, params);
-      }
-    };
-
-    _this.state = {
-      graph: null,
-      setGraph: _this.setGraph,
-      executeCommand: _this.executeCommand,
-      commandManager: new CommandManager()
-    };
-    _this.lastMousedownTarget = null;
-    return _this;
-  }
-
-  Editor.setTrackable = function setTrackable(trackable) {
-    global.trackable = trackable;
-  };
-
-  var _proto = Editor.prototype;
-
-  _proto.shouldTriggerShortcut = function shouldTriggerShortcut(graph, target) {
-    var renderer = graph.get('renderer');
-    var canvasElement = graph.get('canvas').get('el');
-
-    if (!target) {
-      return false;
-    }
-
-    if (target === canvasElement) {
-      return true;
-    }
-
-    if (renderer === RendererType.Svg) {
-      if (target.nodeName === 'svg') {
-        return true;
-      }
-
-      var parentNode = target.parentNode;
-
-      while (parentNode && parentNode.nodeName !== 'BODY') {
-        if (parentNode.nodeName === 'svg') {
-          return true;
-        } else {
-          parentNode = parentNode.parentNode;
-        }
-      }
-
-      return false;
-    }
-  };
-
-  _proto.bindEvent = function bindEvent(graph) {
-    var props = this.props;
-    graph.on(EditorEvent.onBeforeExecuteCommand, props[EditorEvent.onBeforeExecuteCommand]);
-    graph.on(EditorEvent.onAfterExecuteCommand, props[EditorEvent.onAfterExecuteCommand]);
-  };
-
-  _proto.bindShortcut = function bindShortcut(graph) {
-    var _this2 = this;
-
-    var commandManager = this.state.commandManager;
-    window.addEventListener(GraphCommonEvent.onMouseDown, function (e) {
-      _this2.lastMousedownTarget = e.target;
-    });
-    graph.on(GraphCommonEvent.onKeyDown, function (e) {
-      if (!_this2.shouldTriggerShortcut(graph, _this2.lastMousedownTarget)) {
-        return;
-      }
-
-      Object.values(commandManager.command).some(function (command) {
-        var name = command.name,
-            shortcuts = command.shortcuts;
-        var flag = shortcuts.some(function (shortcut) {
-          var key = e.key;
-
-          if (!isArray(shortcut)) {
-            return shortcut === key;
-          }
-
-          return shortcut.every(function (item, index) {
-            if (index === shortcut.length - 1) {
-              return item === key;
-            }
-
-            return e[item];
-          });
-        });
-
-        if (flag) {
-          if (commandManager.canExecute(graph, name)) {
-            // Prevent default
-            e.preventDefault(); // Execute command
-
-            _this2.executeCommand(name);
-
-            return true;
-          }
-        }
-
-        return false;
-      });
-    });
-  };
-
-  _proto.render = function render() {
-    var children = this.props.children;
-    var _this$state2 = this.state,
-        graph = _this$state2.graph,
-        setGraph = _this$state2.setGraph,
-        executeCommand = _this$state2.executeCommand,
-        commandManager = _this$state2.commandManager;
-    return React.createElement(EditorContext.Provider, {
-      value: {
-        graph: graph,
-        executeCommand: executeCommand,
-        commandManager: commandManager
-      }
-    }, React.createElement(EditorPrivateContext.Provider, {
-      value: {
-        setGraph: setGraph,
-        commandManager: commandManager
-      }
-    }, React.createElement("div", Object.assign({}, pick(this.props, ['className', 'style'])), children)));
-  };
-
-  return Editor;
-}(React.Component);
-
-Editor.defaultProps = (_Editor$defaultProps = {}, _Editor$defaultProps[EditorEvent.onBeforeExecuteCommand] = function () {}, _Editor$defaultProps[EditorEvent.onAfterExecuteCommand] = function () {}, _Editor$defaultProps);
-
-var BehaviorManager = /*#__PURE__*/function () {
-  function BehaviorManager() {
-    this.behaviors = {};
-  }
-
-  var _proto = BehaviorManager.prototype;
-
-  _proto.getRegisteredBehaviors = function getRegisteredBehaviors(type) {
-    var _this = this;
-
-    var registeredBehaviors = {};
-    Object.keys(this.behaviors).forEach(function (name) {
-      var behavior = _this.behaviors[name];
-      var graphType = behavior.graphType;
-
-      if (graphType && graphType !== type) {
-        return;
-      }
-
-      var _behavior$graphMode = behavior.graphMode,
-          graphMode = _behavior$graphMode === void 0 ? 'default' : _behavior$graphMode;
-
-      if (!registeredBehaviors[graphMode]) {
-        registeredBehaviors[graphMode] = {};
-      }
-
-      registeredBehaviors[graphMode][name] = name;
-    });
-    return registeredBehaviors;
-  };
-
-  _proto.wrapEventHandler = function wrapEventHandler(type, behavior) {
-    var events = behavior.getEvents();
-    Object.keys(events).forEach(function (event) {
-      var handlerName = events[event];
-      var handler = behavior[handlerName];
-
-      behavior[handlerName] = function () {
-        var graph = this.graph;
-
-        if (type === GraphType.Flow && isMind(graph) === false || type === GraphType.Mind && isMind(graph)) {
-          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
-            params[_key] = arguments[_key];
-          }
-
-          handler.apply(this, params);
-        }
-      };
-    });
-    return behavior;
-  };
-
-  _proto.register = function register(name, behavior) {
-    var graphType = behavior.graphType;
-    this.behaviors[name] = behavior;
-
-    switch (graphType) {
-      case GraphType.Flow:
-        G6.registerBehavior(name, this.wrapEventHandler(GraphType.Flow, behavior));
-        break;
-
-      case GraphType.Mind:
-        G6.registerBehavior(name, this.wrapEventHandler(GraphType.Mind, behavior));
-        break;
-
-      default:
-        G6.registerBehavior(name, behavior);
-        break;
-    }
-  };
-
-  return BehaviorManager;
-}();
-
-var behaviorManager = new BehaviorManager();
-
-var BASE_URL = 'http://gm.mmstat.com/fsp.1.1';
-function track(graphType) {
-  var version = global.version;
-  var trackable = global.trackable;
-
-  if (!trackable) {
-    return;
-  }
-
-  var _window = window,
-      location = _window.location,
-      navigator = _window.navigator;
-  var image = new Image();
-  var params = toQueryString({
-    pid: 'ggeditor',
-    code: '11',
-    msg: 'syslog',
-    page: location.protocol + "//" + location.host + location.pathname,
-    hash: location.hash,
-    ua: navigator.userAgent,
-    rel: version,
-    c1: graphType
-  });
-  image.src = BASE_URL + "?" + params;
-}
-
-var redoCommand = {
-  name: 'redo',
-  params: {},
-  canExecute: function canExecute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandQueue = commandManager.commandQueue,
-        commandIndex = commandManager.commandIndex;
-    return commandIndex < commandQueue.length;
-  },
-  shouldExecute: function shouldExecute() {
-    return true;
-  },
-  canUndo: function canUndo() {
-    return false;
-  },
-  init: function init() {},
-  execute: function execute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandQueue = commandManager.commandQueue,
-        commandIndex = commandManager.commandIndex;
-    commandQueue[commandIndex].execute(graph);
-    commandManager.commandIndex += 1;
-  },
-  undo: function undo() {},
-  shortcuts: [['metaKey', 'shiftKey', 'z'], ['ctrlKey', 'shiftKey', 'z']]
-};
-
-var undoCommand = {
-  name: 'undo',
-  params: {},
-  canExecute: function canExecute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandIndex = commandManager.commandIndex;
-    return commandIndex > 0;
-  },
-  shouldExecute: function shouldExecute() {
-    return true;
-  },
-  canUndo: function canUndo() {
-    return false;
-  },
-  init: function init() {},
-  execute: function execute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandQueue = commandManager.commandQueue,
-        commandIndex = commandManager.commandIndex;
-    commandQueue[commandIndex - 1].undo(graph);
-    commandManager.commandIndex -= 1;
-  },
-  undo: function undo() {},
-  shortcuts: [['metaKey', 'z'], ['ctrlKey', 'z']]
-};
-
-var baseCommand = {
-  name: '',
-  params: {},
-  canExecute: function canExecute() {
-    return true;
-  },
-  shouldExecute: function shouldExecute() {
-    return true;
-  },
-  canUndo: function canUndo() {
-    return true;
-  },
-  init: function init() {},
-  execute: function execute() {},
-  undo: function undo() {},
-  shortcuts: [],
-  isMind: isMind,
-  getSelectedNodes: getSelectedNodes,
-  getSelectedEdges: getSelectedEdges,
-  setSelectedItems: setSelectedItems,
-  editSelectedNode: function editSelectedNode(graph) {
-    graph.emit(EditorEvent.onLabelStateChange, {
-      labelState: LabelState.Show
-    });
-  }
-};
-
-var addCommand = _extends({}, baseCommand, {
-  params: {
-    type: ItemType.Node,
-    model: {
-      id: ''
-    }
-  },
-  init: function init() {
-    var model = this.params.model;
-
-    if (model.id) {
-      return;
-    }
-
-    model.id = guid();
-  },
-  execute: function execute(graph) {
-    var _this$params = this.params,
-        type = _this$params.type,
-        model = _this$params.model;
-    graph.add(type, model);
-    this.setSelectedItems(graph, [model.id]);
-  },
-  undo: function undo(graph) {
-    var model = this.params.model;
-    graph.remove(model.id);
-  }
-});
-
-var removeCommand = _extends({}, baseCommand, {
-  params: {
-    flow: {
-      nodes: {},
-      edges: {}
-    },
-    mind: {
-      model: null,
-      parent: ''
-    }
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    var selectedEdges = this.getSelectedEdges(graph);
-    return !!(selectedNodes.length || selectedEdges.length);
-  },
-  init: function init(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    var selectedEdges = this.getSelectedEdges(graph);
-
-    if (isMind(graph)) {
-      var selectedNode = selectedNodes[0];
-      var selectedNodeModel = selectedNode.getModel();
-      var selectedNodeParent = selectedNode.get('parent');
-      var selectedNodeParentModel = selectedNodeParent ? selectedNodeParent.getModel() : {};
-      this.params.mind = {
-        model: selectedNodeModel,
-        parent: selectedNodeParentModel.id
-      };
-    } else {
-      var _this$params$flow = this.params.flow,
-          nodes = _this$params$flow.nodes,
-          edges = _this$params$flow.edges;
-      selectedNodes.forEach(function (node) {
-        var nodeModel = node.getModel();
-        var nodeEdges = node.getEdges();
-        nodes[nodeModel.id] = nodeModel;
-        nodeEdges.forEach(function (edge) {
-          var edgeModel = edge.getModel();
-          edges[edgeModel.id] = edgeModel;
-        });
-      });
-      selectedEdges.forEach(function (edge) {
-        var edgeModel = edge.getModel();
-        edges[edgeModel.id] = edgeModel;
-      });
-    }
-  },
-  execute: function execute(graph) {
-    if (isMind(graph)) {
-      var model = this.params.mind.model;
-
-      if (!model) {
-        return;
-      }
-
-      graph.removeChild(model.id);
-    } else {
-      var _this$params$flow2 = this.params.flow,
-          nodes = _this$params$flow2.nodes,
-          edges = _this$params$flow2.edges;
-      executeBatch(graph, function () {
-        [].concat(Object.keys(nodes), Object.keys(edges)).forEach(function (id) {
-          graph.removeItem(id);
-        });
-      });
-    }
-  },
-  undo: function undo(graph) {
-    if (isMind(graph)) {
-      var _this$params$mind = this.params.mind,
-          model = _this$params$mind.model,
-          parent = _this$params$mind.parent;
-
-      if (!model) {
-        return;
-      }
-
-      graph.addChild(model, parent);
-    } else {
-      var _this$params$flow3 = this.params.flow,
-          nodes = _this$params$flow3.nodes,
-          edges = _this$params$flow3.edges;
-      executeBatch(graph, function () {
-        Object.keys(nodes).forEach(function (id) {
-          var model = nodes[id];
-          graph.addItem(ItemType.Node, model);
-        });
-        Object.keys(edges).forEach(function (id) {
-          var model = edges[id];
-          graph.addItem(ItemType.Edge, model);
-        });
-      });
-    }
-  },
-  shortcuts: ['Delete', 'Backspace']
-});
-
-var updateCommand = _extends({}, baseCommand, {
-  params: {
-    id: '',
-    originModel: {},
-    updateModel: {},
-    forceRefreshLayout: false
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    var selectedEdges = this.getSelectedEdges(graph);
-    return (selectedNodes.length || selectedEdges.length) && (selectedNodes.length === 1 || selectedEdges.length === 1) ? true : false;
-  },
-  init: function init(graph) {
-    var _this$params = this.params,
-        id = _this$params.id,
-        updateModel = _this$params.updateModel;
-    var updatePaths = Object.keys(updateModel);
-    var originModel = pick(graph.findById(id).getModel(), updatePaths);
-    this.params.originModel = originModel;
-  },
-  execute: function execute(graph) {
-    var _this$params2 = this.params,
-        id = _this$params2.id,
-        updateModel = _this$params2.updateModel,
-        forceRefreshLayout = _this$params2.forceRefreshLayout;
-    graph.updateItem(id, updateModel);
-
-    if (forceRefreshLayout) {
-      graph.refreshLayout && graph.refreshLayout(false);
-    }
-  },
-  undo: function undo(graph) {
-    var _this$params3 = this.params,
-        id = _this$params3.id,
-        originModel = _this$params3.originModel;
-    graph.updateItem(id, originModel);
-  }
-});
-
-var copyCommand = _extends({}, baseCommand, {
-  canExecute: function canExecute(graph) {
-    return !!this.getSelectedNodes(graph).length;
-  },
-  canUndo: function canUndo() {
-    return false;
-  },
-  execute: function execute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    global.clipboard.models = cloneDeep(selectedNodes.map(function (node) {
-      return node.getModel();
-    }));
-  },
-  shortcuts: [['metaKey', 'c'], ['ctrlKey', 'c']]
-});
-
-var pasteCommand = _extends({}, baseCommand, {
-  params: {
-    models: []
-  },
-  canExecute: function canExecute() {
-    return !!global.clipboard.models.length;
-  },
-  init: function init() {
-    var models = global.clipboard.models;
-    var offsetX = 10;
-    var offsetY = 10;
-    this.params = {
-      models: models.map(function (model) {
-        var x = model.x,
-            y = model.y;
-        return _extends({}, model, {
-          id: guid(),
-          x: x + offsetX,
-          y: y + offsetY
-        });
-      })
-    };
-  },
-  execute: function execute(graph) {
-    var models = this.params.models;
-    executeBatch(graph, function () {
-      models.forEach(function (model) {
-        graph.addItem(ItemType.Node, model);
-      });
-    });
-    this.setSelectedItems(graph, models.map(function (model) {
-      return model.id;
-    }));
-  },
-  undo: function undo(graph) {
-    var models = this.params.models;
-    executeBatch(graph, function () {
-      models.forEach(function (model) {
-        graph.removeItem(model.id);
-      });
-    });
-  },
-  shortcuts: [['metaKey', 'v'], ['ctrlKey', 'v']]
-});
-
-var pasteHereCommand = _extends({}, pasteCommand, {
-  params: {
-    models: []
-  },
-  init: function init() {
-    var _global$clipboard = global.clipboard,
-        point = _global$clipboard.point,
-        models = _global$clipboard.models;
-    this.params = {
-      models: models.map(function (model) {
-        var x = model.x,
-            y = model.y;
-        var offsetX = point.x - x;
-        var offsetY = point.y - y;
-        return _extends({}, model, {
-          id: guid(),
-          x: x + offsetX,
-          y: y + offsetY
-        });
-      })
-    };
-  },
-  shortcuts: []
-});
-
-var DELTA = 0.05;
-
-var zoomInCommand = _extends({}, baseCommand, {
-  canUndo: function canUndo() {
-    return false;
-  },
-  execute: function execute(graph) {
-    var ratio = 1 + DELTA;
-    var zoom = graph.getZoom() * ratio;
-    var maxZoom = graph.get('maxZoom');
-
-    if (zoom > maxZoom) {
-      return;
-    }
-
-    graph.zoom(ratio);
-  },
-  shortcuts: [['metaKey', '='], ['ctrlKey', '=']]
-});
-
-var DELTA$1 = 0.05;
-
-var zoomOutCommand = _extends({}, baseCommand, {
-  canUndo: function canUndo() {
-    return false;
-  },
-  execute: function execute(graph) {
-    var ratio = 1 - DELTA$1;
-    var zoom = graph.getZoom() * ratio;
-    var minZoom = graph.get('minZoom');
-
-    if (zoom < minZoom) {
-      return;
-    }
-
-    graph.zoom(ratio);
-  },
-  shortcuts: [['metaKey', '-'], ['ctrlKey', '-']]
-});
-
-var baseCommands = {
-  redo: redoCommand,
-  undo: undoCommand,
-  add: addCommand,
-  remove: removeCommand,
-  update: updateCommand,
-  copy: copyCommand,
-  paste: pasteCommand,
-  pasteHere: pasteHereCommand,
-  zoomIn: zoomInCommand,
-  zoomOut: zoomOutCommand
-};
-
-var topicCommand = _extends({}, baseCommand, {
-  params: {
-    id: '',
-    model: {
-      id: ''
-    }
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    return selectedNodes.length && selectedNodes.length === 1 && selectedNodes[0].get('parent');
-  },
-  init: function init(graph) {
-    if (this.params.id) {
-      return;
-    }
-
-    var selectedNode = this.getSelectedNodes(graph)[0];
-    this.params = {
-      id: selectedNode.get('id'),
-      model: {
-        id: guid(),
-        label: LABEL_DEFAULT_TEXT
-      }
-    };
-  },
-  execute: function execute(graph) {
-    var _this$params = this.params,
-        id = _this$params.id,
-        model = _this$params.model;
-    var parent = graph.findById(id).get('parent'); // 添加节点
-
-    graph.addChild(model, parent); // 选中节点
-
-    this.setSelectedItems(graph, [model.id]); // 编辑节点
-
-    this.editSelectedNode(graph);
-  },
-  undo: function undo(graph) {
-    var _this$params2 = this.params,
-        id = _this$params2.id,
-        model = _this$params2.model;
-    this.setSelectedItems(graph, [id]);
-    graph.removeChild(model.id);
-  },
-  shortcuts: ['Enter']
-});
-
-var subtopicCommand = _extends({}, topicCommand, {
-  canExecute: function canExecute(graph) {
-    return this.getSelectedNodes(graph)[0] ? true : false;
-  },
-  execute: function execute(graph) {
-    var _this$params = this.params,
-        id = _this$params.id,
-        model = _this$params.model; // 添加节点
-
-    graph.addChild(model, id); // 选中节点
-
-    this.setSelectedItems(graph, [model.id]); // 编辑节点
-
-    this.editSelectedNode(graph);
-  },
-  shortcuts: ['Tab']
-});
-
-var foldCommand = _extends({}, baseCommand, {
-  params: {
-    id: ''
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-
-    if (!selectedNodes.length) {
-      return false;
-    }
-
-    var selectedNode = selectedNodes[0];
-    var selectedNodeModel = selectedNode.getModel();
-
-    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
-      return false;
-    }
-
-    if (selectedNodeModel.collapsed) {
-      return false;
-    }
-
-    return true;
-  },
-  init: function init(graph) {
-    var selectedNode = this.getSelectedNodes(graph)[0];
-    var selectedNodeModel = selectedNode.getModel();
-    this.params = {
-      id: selectedNodeModel.id
-    };
-  },
-  execute: function execute(graph) {
-    var id = this.params.id;
-    var sourceData = graph.findDataById(id);
-    sourceData.collapsed = !sourceData.collapsed;
-    graph.refreshLayout(false);
-  },
-  undo: function undo(graph) {
-    this.execute(graph);
-  },
-  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
-});
-
-var unfoldCommand = _extends({}, foldCommand, {
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-
-    if (!selectedNodes.length) {
-      return false;
-    }
-
-    var selectedNode = selectedNodes[0];
-    var selectedNodeModel = selectedNode.getModel();
-
-    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
-      return false;
-    }
-
-    if (!selectedNodeModel.collapsed) {
-      return false;
-    }
-
-    return true;
-  },
-  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
-});
-
-var mindCommands = {
-  topic: topicCommand,
-  subtopic: subtopicCommand,
-  fold: foldCommand,
-  unfold: unfoldCommand
-};
-
-var clickItemBehavior = {
-  getDefaultCfg: function getDefaultCfg() {
-    return {
-      multiple: true,
-      keydown: false,
-      keyCode: 17
-    };
-  },
-  getEvents: function getEvents() {
-    return {
-      'node:click': 'handleItemClick',
-      'edge:click': 'handleItemClick',
-      'canvas:click': 'handleCanvasClick',
-      keydown: 'handleKeyDown',
-      keyup: 'handleKeyUp'
-    };
-  },
-  handleItemClick: function handleItemClick(_ref) {
-    var item = _ref.item;
-    var graph = this.graph;
-
-    if (isMind(graph) && isEdge(item)) {
-      return;
-    }
-
-    var isSelected = item.hasState(ItemState.Selected);
-
-    if (this.multiple && this.keydown) {
-      graph.setItemState(item, ItemState.Selected, !isSelected);
-    } else {
-      clearSelectedState(graph, function (selectedItem) {
-        return selectedItem !== item;
-      });
-
-      if (!isSelected) {
-        graph.setItemState(item, ItemState.Selected, true);
-      }
-    }
-
-    graph.emit(EditorEvent.onGraphStateChange, {
-      graphState: getGraphState(graph)
-    });
-  },
-  handleCanvasClick: function handleCanvasClick() {
-    var graph = this.graph;
-    clearSelectedState(graph);
-    graph.emit(EditorEvent.onGraphStateChange, {
-      graphState: GraphState.CanvasSelected
-    });
-  },
-  handleKeyDown: function handleKeyDown(e) {
-    this.keydown = (e.keyCode || e.which) === this.keyCode;
-  },
-  handleKeyUp: function handleKeyUp() {
-    this.keydown = false;
-  }
-};
-behaviorManager.register('click-item', clickItemBehavior);
-
-var hoverItemBehavior = {
-  getEvents: function getEvents() {
-    return {
-      'node:mouseenter': 'handleItemMouseenter',
-      'edge:mouseenter': 'handleItemMouseenter',
-      'node:mouseleave': 'handleItemMouseleave',
-      'edge:mouseleave': 'handleItemMouseleave'
-    };
-  },
-  handleItemMouseenter: function handleItemMouseenter(_ref) {
-    var item = _ref.item;
-    var graph = this.graph;
-    graph.setItemState(item, ItemState.Active, true);
-  },
-  handleItemMouseleave: function handleItemMouseleave(_ref2) {
-    var item = _ref2.item;
-    var graph = this.graph;
-    graph.setItemState(item, ItemState.Active, false);
-  }
-};
-behaviorManager.register('hover-item', hoverItemBehavior);
-
-var dragCanvasBehavior = {
-  origin: null,
-  keyCode: null,
-  dragging: false,
-  handleWindowMouseUp: null,
-  getDefaultCfg: function getDefaultCfg() {
-    return {
-      allowKeyCode: [],
-      notAllowKeyCode: [16]
-    };
-  },
-  getEvents: function getEvents() {
-    return {
-      'canvas:dragstart': 'handleCanvasDragStart',
-      'canvas:drag': 'handleCanvasDrag',
-      'canvas:dragend': 'handleCanvasDragEnd',
-      'canvas:mouseleave': 'handleCanvasMouseLeave',
-      'canvas:contextmenu': 'handleCanvasContextMenu',
-      keydown: 'handleKeyDown',
-      keyup: 'handleKeyUp'
-    };
-  },
-  canDrag: function canDrag() {
-    var keyCode = this.keyCode,
-        allowKeyCode = this.allowKeyCode,
-        notAllowKeyCode = this.notAllowKeyCode;
-    var isAllow = !!!allowKeyCode.length;
-
-    if (!keyCode) {
-      return isAllow;
-    }
-
-    if (allowKeyCode.length && allowKeyCode.includes(keyCode)) {
-      isAllow = true;
-    }
-
-    if (notAllowKeyCode.includes(keyCode)) {
-      isAllow = false;
-    }
-
-    return isAllow;
-  },
-  updateViewport: function updateViewport(e) {
-    var clientX = e.clientX,
-        clientY = e.clientY;
-    var dx = clientX - this.origin.x;
-    var dy = clientY - this.origin.y;
-    this.origin = {
-      x: clientX,
-      y: clientY
-    };
-    this.graph.translate(dx, dy);
-    this.graph.paint();
-  },
-  handleCanvasDragStart: function handleCanvasDragStart(e) {
-    if (!this.shouldBegin.call(this, e)) {
-      return;
-    }
-
-    if (!this.canDrag()) {
-      return;
-    }
-
-    this.origin = {
-      x: e.clientX,
-      y: e.clientY
-    };
-    this.dragging = false;
-  },
-  handleCanvasDrag: function handleCanvasDrag(e) {
-    if (!this.shouldUpdate.call(this, e)) {
-      return;
-    }
-
-    if (!this.canDrag()) {
-      return;
-    }
-
-    if (!this.origin) {
-      return;
-    }
-
-    if (!this.dragging) {
-      this.dragging = true;
-    } else {
-      this.updateViewport(e);
-    }
-  },
-  handleCanvasDragEnd: function handleCanvasDragEnd(e) {
-    if (!this.shouldEnd.call(this, e)) {
-      return;
-    }
-
-    if (!this.canDrag()) {
-      return;
-    }
-
-    this.origin = null;
-    this.dragging = false;
-
-    if (this.handleWindowMouseUp) {
-      document.body.removeEventListener('mouseup', this.handleWindowMouseUp, false);
-      this.handleWindowMouseUp = null;
-    }
-  },
-  handleCanvasMouseLeave: function handleCanvasMouseLeave() {
-    var _this = this;
-
-    var canvasElement = this.graph.get('canvas').get('el');
-
-    if (this.handleWindowMouseUp) {
-      return;
-    }
-
-    this.handleWindowMouseUp = function (e) {
-      if (e.target !== canvasElement) {
-        _this.handleCanvasDragEnd();
-      }
-    };
-
-    document.body.addEventListener('mouseup', this.handleWindowMouseUp, false);
-  },
-  handleCanvasContextMenu: function handleCanvasContextMenu() {
-    this.origin = null;
-    this.dragging = false;
-  },
-  handleKeyDown: function handleKeyDown(e) {
-    this.keyCode = e.keyCode || e.which;
-  },
-  handleKeyUp: function handleKeyUp() {
-    this.keyCode = null;
-  }
-};
-behaviorManager.register('drag-canvas', dragCanvasBehavior);
-
-var recallEdgeBehavior = {
-  edgeIds: [],
-  getEvents: function getEvents() {
-    return {
-      'node:click': 'handleNodeClick',
-      'edge:click': 'handleEdgeClick',
-      'canvas:click': 'handleCanvasClick'
-    };
-  },
-  setHighLightState: function setHighLightState(edges) {
-    var graph = this.graph;
-    this.clearHighLightState();
-    executeBatch(graph, function () {
-      edges.forEach(function (item) {
-        graph.setItemState(item, ItemState.HighLight, true);
-      });
-    });
-    this.edgeIds = edges.map(function (edge) {
-      return edge.get('id');
-    });
-  },
-  clearHighLightState: function clearHighLightState() {
-    var _this = this;
-
-    var graph = this.graph;
-    executeBatch(graph, function () {
-      _this.edgeIds.forEach(function (id) {
-        var item = graph.findById(id);
-
-        if (item && !item.destroyed) {
-          graph.setItemState(item, ItemState.HighLight, false);
-        }
-      });
-    });
-    this.edgeIds = [];
-  },
-  handleNodeClick: function handleNodeClick(_ref) {
-    var item = _ref.item;
-    var graph = this.graph;
-    var edges = [];
-
-    if (isFlow(graph)) {
-      edges = getFlowRecallEdges(graph, item);
-    }
-
-    if (isMind(graph)) {
-      edges = getMindRecallEdges(graph, item);
-    }
-
-    this.setHighLightState(edges);
-  },
-  handleEdgeClick: function handleEdgeClick() {
-    this.clearHighLightState();
-  },
-  handleCanvasClick: function handleCanvasClick() {
-    this.clearHighLightState();
-  }
-};
-behaviorManager.register('recall-edge', recallEdgeBehavior);
-
-var GraphComponent = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(GraphComponent, _React$Component);
-
-  function GraphComponent() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.graph = null;
-    return _this;
-  }
-
-  var _proto = GraphComponent.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    this.initGraph();
-    this.bindEvent();
-  };
-
-  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
-    var data = this.props.data;
-
-    if (data !== prevProps.data) {
-      this.changeData(data);
-    }
-  };
-
-  _proto.focusRootNode = function focusRootNode(graph, data) {
-    if (!isMind(graph)) {
-      return;
-    }
-
-    var id = data.id;
-    graph.focusItem(id);
-  };
-
-  _proto.initGraph = function initGraph() {
-    var _this$props = this.props,
-        containerId = _this$props.containerId,
-        parseData = _this$props.parseData,
-        initGraph = _this$props.initGraph,
-        setGraph = _this$props.setGraph,
-        commandManager = _this$props.commandManager;
-
-    var _ref = document.getElementById(containerId) || {},
-        _ref$clientWidth = _ref.clientWidth,
-        clientWidth = _ref$clientWidth === void 0 ? 0 : _ref$clientWidth,
-        _ref$clientHeight = _ref.clientHeight,
-        clientHeight = _ref$clientHeight === void 0 ? 0 : _ref$clientHeight; // 解析数据
-
-
-    var data = _extends({}, this.props.data);
-
-    parseData(data); // 初始画布
-
-    this.graph = initGraph(clientWidth, clientHeight);
-    this.graph.data(data);
-    this.graph.render();
-    this.focusRootNode(this.graph, data);
-    this.graph.setMode('default');
-    setGraph(this.graph); // 设置命令管理器
-
-    this.graph.set('commandManager', commandManager); // 注册命令
-
-    var commands = baseCommands;
-
-    if (isMind(this.graph)) {
-      commands = _extends({}, commands, {}, mindCommands);
-    }
-
-    Object.keys(commands).forEach(function (name) {
-      commandManager.register(name, commands[name]);
-    }); // 发送埋点
-
-    if (global.trackable) {
-      var graphType = isMind(this.graph) ? GraphType.Mind : GraphType.Flow;
-      track(graphType);
-    }
-  };
-
-  _proto.bindEvent = function bindEvent() {
-    var graph = this.graph,
-        props = this.props;
-
-    if (!graph) {
-      return;
-    }
-
-    var events = _extends({}, GraphCommonEvent, {}, GraphNodeEvent, {}, GraphEdgeEvent, {}, GraphCanvasEvent, {}, GraphCustomEvent);
-
-    Object.keys(events).forEach(function (event) {
-      if (typeof props[event] === 'function') {
-        graph.on(events[event], props[event]);
-      }
-    });
-  };
-
-  _proto.changeData = function changeData(data) {
-    var graph = this.graph;
-    var parseData = this.props.parseData;
-
-    if (!graph) {
-      return;
-    }
-
-    parseData(data);
-    graph.changeData(data);
-    this.focusRootNode(graph, data);
-  };
-
-  _proto.render = function render() {
-    var _this$props2 = this.props,
-        containerId = _this$props2.containerId,
-        children = _this$props2.children;
-    return React.createElement("div", Object.assign({
-      id: containerId
-    }, pick(this.props, ['className', 'style'])), children);
-  };
-
-  return GraphComponent;
-}(React.Component);
-
-var GraphComponent$1 = withEditorPrivateContext(GraphComponent);
-
-var dragAddNodeBehavior = {
-  shape: null,
-  graphType: GraphType.Flow,
-  graphMode: GraphMode.AddNode,
-  getEvents: function getEvents() {
-    return {
-      'canvas:mouseenter': 'handleCanvasMouseEnter',
-      mousemove: 'handleMouseMove',
-      mouseup: 'handleMouseUp'
-    };
-  },
-  handleCanvasMouseEnter: function handleCanvasMouseEnter(e) {
-    var graph = this.graph,
-        shape = this.shape;
-
-    if (shape) {
-      return;
-    }
-
-    var group = graph.get('group');
-    var model = global.component.itemPanel.model;
-    var _model$size = model.size,
-        size = _model$size === void 0 ? 100 : _model$size;
-    var width = 0;
-    var height = 0;
-
-    if (isArray(size)) {
-      width = size[0];
-      height = size[1];
-    } else {
-      width = size;
-      height = size;
-    }
-
-    var x = e.x - width / 2;
-    var y = e.y - height / 2;
-    this.shape = group.addShape('rect', {
-      className: global.component.itemPanel.delegateShapeClassName,
-      attrs: {
-        x: x,
-        y: y,
-        width: width,
-        height: height,
-        fill: '#f3f9ff',
-        fillOpacity: 0.5,
-        stroke: '#1890ff',
-        strokeOpacity: 0.9,
-        lineDash: [5, 5]
-      }
-    });
-    graph.paint();
-  },
-  handleMouseMove: function handleMouseMove(e) {
-    var graph = this.graph;
-
-    var _this$shape$getBBox = this.shape.getBBox(),
-        width = _this$shape$getBBox.width,
-        height = _this$shape$getBBox.height;
-
-    var x = e.x - width / 2;
-    var y = e.y - height / 2;
-    this.shape.attr({
-      x: x,
-      y: y
-    });
-    graph.paint();
-  },
-  handleMouseUp: function handleMouseUp(e) {
-    var graph = this.graph;
-
-    var _this$shape$getBBox2 = this.shape.getBBox(),
-        width = _this$shape$getBBox2.width,
-        height = _this$shape$getBBox2.height;
-
-    var x = e.x;
-    var y = e.y;
-    var model = global.component.itemPanel.model;
-
-    if (model.center === 'topLeft') {
-      x -= width / 2;
-      y -= height / 2;
-    }
-
-    this.shape.remove(true);
-    var commandManager = graph.get('commandManager');
-    commandManager.execute(graph, EditorCommand.Add, {
-      type: ItemType.Node,
-      model: _extends({
-        id: guid(),
-        x: x,
-        y: y
-      }, model)
-    });
-  }
-};
-behaviorManager.register('drag-add-node', dragAddNodeBehavior);
-
-var dragAddEdgeBehavior = {
-  edge: null,
-  graphType: GraphType.Flow,
-  getDefaultCfg: function getDefaultCfg() {
-    return {
-      edgeType: 'bizFlowEdge',
-      getAnchorPointStateOfSourceNode: function getAnchorPointStateOfSourceNode() {
-        return AnchorPointState.Enabled;
-      },
-      getAnchorPointStateOfTargetNode: function getAnchorPointStateOfTargetNode() {
-        return AnchorPointState.Enabled;
-      }
-    };
-  },
-  getEvents: function getEvents() {
-    return {
-      'node:mouseenter': 'handleNodeMouseEnter',
-      'node:mouseleave': 'handleNodeMouseLeave',
-      'node:mousedown': 'handleNodeMouseDown',
-      mousemove: 'handleMouseMove',
-      mouseup: 'handleMouseUp'
-    };
-  },
-  isEnabledAnchorPoint: function isEnabledAnchorPoint(e) {
-    var target = e.target;
-    return !!target.get('isAnchorPoint') && target.get('anchorPointState') === AnchorPointState.Enabled;
-  },
-  isNotSelf: function isNotSelf(e) {
-    var edge = this.edge;
-    var item = e.item;
-    return item.getModel().id !== edge.getSource().getModel().id;
-  },
-  getTargetNodes: function getTargetNodes(sourceId) {
-    var graph = this.graph;
-    var nodes = graph.getNodes();
-    return nodes.filter(function (node) {
-      return node.getModel().id !== sourceId;
-    });
-  },
-  canFindTargetAnchorPoint: function canFindTargetAnchorPoint(e) {
-    return this.isEnabledAnchorPoint(e) && this.isNotSelf(e);
-  },
-  shouldAddDelegateEdge: function shouldAddDelegateEdge(e) {
-    return this.isEnabledAnchorPoint(e);
-  },
-  shouldAddRealEdge: function shouldAddRealEdge() {
-    var edge = this.edge;
-    var target = edge.getTarget();
-    return !isPlainObject(target);
-  },
-  handleNodeMouseEnter: function handleNodeMouseEnter(e) {
-    var graph = this.graph,
-        getAnchorPointStateOfSourceNode = this.getAnchorPointStateOfSourceNode;
-    var sourceNode = e.item;
-    var sourceAnchorPoints = sourceNode.getAnchorPoints();
-    var sourceAnchorPointsState = [];
-    sourceAnchorPoints.forEach(function (sourceAnchorPoint) {
-      sourceAnchorPointsState.push(getAnchorPointStateOfSourceNode(sourceNode, sourceAnchorPoint));
-    });
-    sourceNode.set('anchorPointsState', sourceAnchorPointsState);
-    graph.setItemState(sourceNode, ItemState.ActiveAnchorPoints, true);
-  },
-  handleNodeMouseLeave: function handleNodeMouseLeave(e) {
-    var graph = this.graph,
-        edge = this.edge;
-    var item = e.item;
-
-    if (!edge) {
-      item.set('anchorPointsState', []);
-      graph.setItemState(item, ItemState.ActiveAnchorPoints, false);
-    }
-  },
-  handleNodeMouseDown: function handleNodeMouseDown(e) {
-    if (!this.shouldBegin(e) || !this.shouldAddDelegateEdge(e)) {
-      return;
-    }
-
-    var graph = this.graph,
-        edgeType = this.edgeType,
-        getAnchorPointStateOfTargetNode = this.getAnchorPointStateOfTargetNode;
-    var target = e.target;
-    var sourceNode = e.item;
-    var sourceNodeId = sourceNode.getModel().id;
-    var sourceAnchorPointIndex = target.get('anchorPointIndex');
-    var sourceAnchorPoint = sourceNode.getAnchorPoints()[sourceAnchorPointIndex];
-    var model = {
-      id: guid(),
-      type: edgeType,
-      source: sourceNodeId,
-      sourceAnchor: sourceAnchorPointIndex,
-      target: {
-        x: e.x,
-        y: e.y
-      }
-    };
-    this.edge = graph.addItem(ItemType.Edge, model);
-    graph.getNodes().forEach(function (targetNode) {
-      if (targetNode.getModel().id === sourceNodeId) {
-        return;
-      }
-
-      var targetAnchorPoints = targetNode.getAnchorPoints();
-      var targetAnchorPointsState = [];
-      targetAnchorPoints.forEach(function (targetAnchorPoint) {
-        targetAnchorPointsState.push(getAnchorPointStateOfTargetNode(sourceNode, sourceAnchorPoint, targetNode, targetAnchorPoint));
-      });
-      targetNode.set('anchorPointsState', targetAnchorPointsState);
-      graph.setItemState(targetNode, ItemState.ActiveAnchorPoints, true);
-    });
-  },
-  handleMouseMove: function handleMouseMove(e) {
-    var graph = this.graph,
-        edge = this.edge;
-
-    if (!edge) {
-      return;
-    }
-
-    if (this.canFindTargetAnchorPoint(e)) {
-      var item = e.item,
-          target = e.target;
-      var targetId = item.getModel().id;
-      var targetAnchor = target.get('anchorPointIndex');
-      graph.updateItem(edge, {
-        target: targetId,
-        targetAnchor: targetAnchor
-      });
-    } else {
-      graph.updateItem(edge, {
-        target: {
-          x: e.x,
-          y: e.y
-        },
-        targetAnchor: undefined
-      });
-    }
-  },
-  handleMouseUp: function handleMouseUp() {
-    var graph = this.graph,
-        edge = this.edge;
-
-    if (!edge) {
-      return;
-    }
-
-    if (!this.shouldAddRealEdge()) {
-      graph.removeItem(this.edge);
-    }
-
-    this.edge = null;
-    graph.getNodes().forEach(function (node) {
-      node.set('anchorPointsState', []);
-      graph.setItemState(node, ItemState.ActiveAnchorPoints, false);
-    });
-  }
-};
-behaviorManager.register('drag-add-edge', dragAddEdgeBehavior);
-
-var Flow = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Flow, _React$Component);
-
-  function Flow() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.graph = null;
-    _this.containerId = FLOW_CONTAINER_ID + "_" + guid();
-
-    _this.canDragNode = function (e) {
-      return !['anchor', 'banAnchor'].some(function (item) {
-        return item === e.target.get('className');
-      });
-    };
-
-    _this.canDragOrZoomCanvas = function () {
-      var _assertThisInitialize = _assertThisInitialized(_this),
-          graph = _assertThisInitialize.graph;
-
-      if (!graph) {
-        return false;
-      }
-
-      return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';
-    };
-
-    _this.parseData = function (data) {
-      var nodes = data.nodes,
-          edges = data.edges;
-      [].concat(nodes, edges).forEach(function (item) {
-        var id = item.id;
-
-        if (id) {
-          return;
-        }
-
-        item.id = guid();
-      });
-    };
-
-    _this.initGraph = function (width, height) {
-      var _assertThisInitialize2 = _assertThisInitialized(_this),
-          containerId = _assertThisInitialize2.containerId;
-
-      var _this$props = _this.props,
-          graphConfig = _this$props.graphConfig,
-          customModes = _this$props.customModes;
-      var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Flow), {
-        "default": {
-          'drag-node': {
-            type: 'drag-node',
-            enableDelegate: true,
-            shouldBegin: _this.canDragNode
-          },
-          'drag-canvas': {
-            type: 'drag-canvas',
-            shouldBegin: _this.canDragOrZoomCanvas,
-            shouldUpdate: _this.canDragOrZoomCanvas
-          },
-          'zoom-canvas': {
-            type: 'zoom-canvas',
-            shouldUpdate: _this.canDragOrZoomCanvas
-          },
-          'recall-edge': 'recall-edge',
-          'brush-select': 'brush-select'
-        }
-      });
-      Object.keys(modes).forEach(function (mode) {
-        var behaviors = modes[mode];
-        modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
-      });
-      _this.graph = new G6.Graph(_extends({
-        container: containerId,
-        width: width,
-        height: height,
-        modes: modes,
-        defaultNode: {
-          type: 'bizFlowNode'
-        },
-        defaultEdge: {
-          type: 'bizFlowEdge'
-        }
-      }, graphConfig));
-      return _this.graph;
-    };
-
-    return _this;
-  }
-
-  var _proto = Flow.prototype;
-
-  _proto.render = function render() {
-    var containerId = this.containerId,
-        parseData = this.parseData,
-        initGraph = this.initGraph;
-    return React.createElement(GraphComponent$1, Object.assign({
-      containerId: containerId,
-      parseData: parseData,
-      initGraph: initGraph
-    }, omit(this.props, ['graphConfig', 'customModes'])));
-  };
-
-  return Flow;
-}(React.Component);
-
-Flow.defaultProps = {
-  graphConfig: {}
-};
-
-var Mind = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Mind, _React$Component);
-
-  function Mind() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.graph = null;
-    _this.containerId = MIND_CONTAINER_ID + "_" + guid();
-
-    _this.canDragOrZoomCanvas = function () {
-      var _assertThisInitialize = _assertThisInitialized(_this),
-          graph = _assertThisInitialize.graph;
-
-      if (!graph) {
-        return false;
-      }
-
-      return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';
-    };
-
-    _this.canCollapseExpand = function (_ref) {
-      var target = _ref.target;
-      return target && [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].includes(target.get('className'));
-    };
-
-    _this.parseData = function (data) {
-      recursiveTraversal(data, function (item) {
-        var id = item.id;
-
-        if (id) {
-          return;
-        }
-
-        item.id = guid();
-      });
-    };
-
-    _this.initGraph = function (width, height) {
-      var _assertThisInitialize2 = _assertThisInitialized(_this),
-          containerId = _assertThisInitialize2.containerId;
-
-      var _this$props = _this.props,
-          graphConfig = _this$props.graphConfig,
-          customModes = _this$props.customModes;
-      var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Mind), {
-        "default": {
-          'click-item': {
-            type: 'click-item',
-            multiple: false
-          },
-          'collapse-expand': {
-            type: 'collapse-expand',
-            shouldBegin: _this.canCollapseExpand
-          },
-          'drag-canvas': {
-            type: 'drag-canvas',
-            shouldBegin: _this.canDragOrZoomCanvas,
-            shouldUpdate: _this.canDragOrZoomCanvas
-          },
-          'zoom-canvas': {
-            type: 'zoom-canvas',
-            shouldUpdate: _this.canDragOrZoomCanvas
-          }
-        }
-      });
-      Object.keys(modes).forEach(function (mode) {
-        var behaviors = modes[mode];
-        modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
-      });
-      _this.graph = new G6.TreeGraph(_extends({
-        container: containerId,
-        width: width,
-        height: height,
-        modes: modes,
-        layout: {
-          type: 'mindmap',
-          direction: 'H',
-          getWidth: function getWidth() {
-            return 120;
-          },
-          getHeight: function getHeight() {
-            return 60;
-          },
-          getHGap: function getHGap() {
-            return 100;
-          },
-          getVGap: function getVGap() {
-            return 50;
-          },
-          getSide: function getSide(_ref2) {
-            var data = _ref2.data;
-
-            if (data.side) {
-              return data.side;
-            }
-
-            return 'right';
-          }
-        },
-        animate: false,
-        defaultNode: {
-          type: 'bizMindNode'
-        },
-        defaultEdge: {
-          type: 'bizMindEdge'
-        }
-      }, graphConfig));
-      return _this.graph;
-    };
-
-    return _this;
-  }
-
-  var _proto = Mind.prototype;
-
-  _proto.render = function render() {
-    var containerId = this.containerId,
-        parseData = this.parseData,
-        initGraph = this.initGraph;
-    var data = this.props.data;
-    return React.createElement(GraphComponent$1, Object.assign({
-      containerId: containerId,
-      data: data,
-      parseData: parseData,
-      initGraph: initGraph
-    }, omit(this.props, ['graphConfig', 'customModes'])));
-  };
-
-  return Mind;
-}(React.Component);
-
-Mind.defaultProps = {
-  graphConfig: {}
-};
-
-var Command = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Command, _React$Component);
-
-  function Command() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.state = {
-      disabled: false
-    };
-
-    _this.handleClick = function () {
-      var _this$props = _this.props,
-          name = _this$props.name,
-          executeCommand = _this$props.executeCommand;
-      executeCommand(name);
-    };
-
-    return _this;
-  }
-
-  var _proto = Command.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        name = _this$props2.name;
-    var commandManager = graph.get('commandManager');
-    this.setState({
-      disabled: !commandManager.canExecute(graph, name)
-    });
-    graph.on(EditorEvent.onGraphStateChange, function () {
-      _this2.setState({
-        disabled: !commandManager.canExecute(graph, name)
-      });
-    });
-  };
-
-  _proto.render = function render() {
-    var graph = this.props.graph;
-
-    if (!graph) {
-      return null;
-    }
-
-    var _this$props3 = this.props,
-        className = _this$props3.className,
-        disabledClassName = _this$props3.disabledClassName,
-        children = _this$props3.children;
-    var disabled = this.state.disabled;
-    return React.createElement("div", {
-      className: "" + className + (disabled ? " " + disabledClassName : ''),
-      onClick: this.handleClick
-    }, children);
-  };
-
-  return Command;
-}(React.Component);
-
-Command.defaultProps = {
-  className: 'command',
-  disabledClassName: 'command-disabled'
-};
-var index$2 = withEditorContext(Command);
-
-var Item = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Item, _React$Component);
-
-  function Item() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-
-    _this.handleMouseDown = function () {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          type = _this$props.type,
-          model = _this$props.model;
-
-      if (type === ItemType.Node) {
-        global.component.itemPanel.model = model;
-        graph.setMode(GraphMode.AddNode);
-      }
-    };
-
-    return _this;
-  }
-
-  var _proto = Item.prototype;
-
-  _proto.render = function render() {
-    var children = this.props.children;
-    return React.createElement("div", Object.assign({}, pick(this.props, ['style', 'className']), {
-      onMouseDown: this.handleMouseDown
-    }), children);
-  };
-
-  return Item;
-}(React.Component);
-
-Item.defaultProps = {
-  type: ItemType.Node
-};
-var Item$1 = withEditorContext(Item);
-
-var ItemPanel = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(ItemPanel, _React$Component);
-
-  function ItemPanel() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-
-    _this.handleMouseUp = function () {
-      var graph = _this.props.graph;
-
-      if (graph.getCurrentMode() === GraphMode.Default) {
-        return;
-      }
-
-      var group = graph.get('group');
-      var shape = group.findByClassName(global.component.itemPanel.delegateShapeClassName);
-
-      if (shape) {
-        shape.remove(true);
-        graph.paint();
-      }
-
-      global.component.itemPanel.model = null;
-      graph.setMode(GraphMode.Default);
-    };
-
-    return _this;
-  }
-
-  var _proto = ItemPanel.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    document.addEventListener('mouseup', this.handleMouseUp, false);
-  };
-
-  _proto.componentWillUnmount = function componentWillUnmount() {
-    document.removeEventListener('mouseup', this.handleMouseUp, false);
-  };
-
-  _proto.render = function render() {
-    var children = this.props.children;
-    return React.createElement("div", Object.assign({}, pick(this.props, ['style', 'className'])), children);
-  };
-
-  return ItemPanel;
-}(React.Component);
-
-ItemPanel.Item = Item$1;
-var index$3 = withEditorContext(ItemPanel);
-
-var DetailPanel = function DetailPanel() {};
-
-DetailPanel.create = function (type) {
-  return function (WrappedComponent) {
-    var TypedPanel = /*#__PURE__*/function (_React$Component) {
-      _inheritsLoose(TypedPanel, _React$Component);
-
-      function TypedPanel() {
-        var _this;
-
-        _this = _React$Component.apply(this, arguments) || this;
-        _this.state = {
-          graphState: GraphState.CanvasSelected
-        };
-        return _this;
-      }
-
-      var _proto = TypedPanel.prototype;
-
-      _proto.componentDidMount = function componentDidMount() {
-        var _this2 = this;
-
-        var graph = this.props.graph;
-        graph.on(EditorEvent.onGraphStateChange, function (_ref) {
-          var graphState = _ref.graphState;
-
-          _this2.setState({
-            graphState: graphState
-          });
-        });
-      };
-
-      _proto.render = function render() {
-        var graph = this.props.graph;
-        var graphState = this.state.graphState;
-
-        if (graphState !== type + "Selected") {
-          return null;
-        }
-
-        var nodes = getSelectedNodes(graph);
-        var edges = getSelectedEdges(graph);
-        return React.createElement(WrappedComponent, Object.assign({
-          type: type,
-          nodes: nodes,
-          edges: edges
-        }, this.props));
-      };
-
-      return TypedPanel;
-    }(React.Component);
-
-    return withEditorContext(TypedPanel);
-  };
-};
-
-var Register = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Register, _React$Component);
-
-  function Register(props, type) {
-    var _this;
-
-    _this = _React$Component.call(this, props) || this;
-    var name = props.name,
-        config = props.config,
-        extend = props.extend,
-        commandManager = props.commandManager;
-
-    switch (type) {
-      case 'node':
-        G6.registerNode(name, config, extend);
-        break;
-
-      case 'edge':
-        G6.registerEdge(name, config, extend);
-        break;
-
-      case 'command':
-        commandManager.register(name, config);
-        break;
-
-      case 'behavior':
-        behaviorManager.register(name, config);
-        break;
-    }
-
-    return _this;
-  }
-
-  var _proto = Register.prototype;
-
-  _proto.render = function render() {
-    return null;
-  };
-
-  return Register;
-}(React.Component);
-
-Register.create = function (type) {
-  var TypedRegister = /*#__PURE__*/function (_Register) {
-    _inheritsLoose(TypedRegister, _Register);
-
-    function TypedRegister(props) {
-      return _Register.call(this, props, type) || this;
-    }
-
-    return TypedRegister;
-  }(Register);
-
-  return withEditorPrivateContext(TypedRegister);
-};
-
-var RegisterNode = Register.create('node');
-var RegisterEdge = Register.create('edge');
-var RegisterCommand = Register.create('command');
-var RegisterBehavior = Register.create('behavior');
-
-var ItemPopoverType;
-
-(function (ItemPopoverType) {
-  ItemPopoverType["Node"] = "node";
-  ItemPopoverType["Edge"] = "edge";
-})(ItemPopoverType || (ItemPopoverType = {}));
-
-var ItemPopover = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(ItemPopover, _React$Component);
-
-  function ItemPopover() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.state = {
-      visible: false,
-      content: null
-    };
-    _this.mouseEnterTimeoutID = 0;
-    _this.mouseLeaveTimeoutID = 0;
-
-    _this.showItemPopover = function (item) {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          renderContent = _this$props.renderContent;
-      global.plugin.itemPopover.state = 'show';
-
-      var _item$getBBox = item.getBBox(),
-          minX = _item$getBBox.minX,
-          minY = _item$getBBox.minY,
-          maxX = _item$getBBox.maxX,
-          maxY = _item$getBBox.maxY,
-          centerX = _item$getBBox.centerX,
-          centerY = _item$getBBox.centerY;
-
-      var _graph$getCanvasByPoi = graph.getCanvasByPoint(minX, minY),
-          itemMinX = _graph$getCanvasByPoi.x,
-          itemMinY = _graph$getCanvasByPoi.y;
-
-      var _graph$getCanvasByPoi2 = graph.getCanvasByPoint(maxX, maxY),
-          itemMaxX = _graph$getCanvasByPoi2.x,
-          itemMaxY = _graph$getCanvasByPoi2.y;
-
-      var _graph$getCanvasByPoi3 = graph.getCanvasByPoint(centerX, centerY),
-          itemCenterX = _graph$getCanvasByPoi3.x,
-          itemCenterY = _graph$getCanvasByPoi3.y;
-
-      var position = {
-        minX: itemMinX,
-        minY: itemMinY,
-        maxX: itemMaxX,
-        maxY: itemMaxY,
-        centerX: itemCenterX,
-        centerY: itemCenterY
-      };
-
-      _this.setState({
-        visible: true,
-        content: renderContent(item, position)
-      });
-    };
-
-    _this.hideItemPopover = function () {
-      global.plugin.itemPopover.state = 'hide';
-
-      _this.setState({
-        visible: false,
-        content: null
-      });
-    };
-
-    return _this;
-  }
-
-  var _proto = ItemPopover.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        type = _this$props2.type;
-
-    if (type === ItemPopoverType.Node) {
-      graph.on(GraphNodeEvent.onNodeMouseEnter, function (_ref) {
-        var item = _ref.item;
-        clearTimeout(_this2.mouseLeaveTimeoutID);
-        _this2.mouseEnterTimeoutID = delay(_this2.showItemPopover, 250, item);
-      });
-      graph.on(GraphNodeEvent.onNodeMouseLeave, function () {
-        clearTimeout(_this2.mouseEnterTimeoutID);
-        _this2.mouseLeaveTimeoutID = delay(_this2.hideItemPopover, 250);
-      });
-    }
-  };
-
-  _proto.render = function render() {
-    var graph = this.props.graph;
-    var _this$state = this.state,
-        visible = _this$state.visible,
-        content = _this$state.content;
-
-    if (!visible) {
-      return null;
-    }
-
-    return ReactDOM.createPortal(content, graph.get('container'));
-  };
-
-  return ItemPopover;
-}(React.Component);
-
-ItemPopover.defaultProps = {
-  type: ItemPopoverType.Node
-};
-var index$4 = withEditorContext(ItemPopover);
-
-var ContextMenuType;
-
-(function (ContextMenuType) {
-  ContextMenuType["Canvas"] = "canvas";
-  ContextMenuType["Node"] = "node";
-  ContextMenuType["Edge"] = "edge";
-})(ContextMenuType || (ContextMenuType = {}));
-
-var ContextMenu = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(ContextMenu, _React$Component);
-
-  function ContextMenu() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.state = {
-      visible: false,
-      content: null
-    };
-
-    _this.showContextMenu = function (x, y, item) {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          renderContent = _this$props.renderContent;
-      clearSelectedState(graph);
-
-      if (item) {
-        graph.setItemState(item, ItemState.Selected, true);
-      }
-
-      global.plugin.contextMenu.state = 'show';
-      global.clipboard.point = {
-        x: x,
-        y: y
-      };
-      var position = graph.getCanvasByPoint(x, y);
-
-      _this.setState({
-        visible: true,
-        content: renderContent(item, position, _this.hideContextMenu)
-      });
-    };
-
-    _this.hideContextMenu = function () {
-      global.plugin.contextMenu.state = 'hide';
-
-      _this.setState({
-        visible: false,
-        content: null
-      });
-    };
-
-    return _this;
-  }
-
-  var _proto = ContextMenu.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        type = _this$props2.type;
-
-    switch (type) {
-      case ContextMenuType.Canvas:
-        graph.on(GraphCanvasEvent.onCanvasContextMenu, function (e) {
-          e.preventDefault();
-          var x = e.x,
-              y = e.y;
-
-          _this2.showContextMenu(x, y);
-        });
-        break;
-
-      case ContextMenuType.Node:
-        graph.on(GraphNodeEvent.onNodeContextMenu, function (e) {
-          e.preventDefault();
-          var x = e.x,
-              y = e.y,
-              item = e.item;
-
-          _this2.showContextMenu(x, y, item);
-        });
-        break;
-
-      case ContextMenuType.Edge:
-        graph.on(GraphEdgeEvent.onEdgeContextMenu, function (e) {
-          e.preventDefault();
-          var x = e.x,
-              y = e.y,
-              item = e.item;
-
-          _this2.showContextMenu(x, y, item);
-        });
-        break;
-    }
-
-    graph.on(GraphCommonEvent.onClick, function () {
-      _this2.hideContextMenu();
-    });
-  };
-
-  _proto.render = function render() {
-    var graph = this.props.graph;
-    var _this$state = this.state,
-        visible = _this$state.visible,
-        content = _this$state.content;
-
-    if (!visible) {
-      return null;
-    }
-
-    return ReactDOM.createPortal(content, graph.get('container'));
-  };
-
-  return ContextMenu;
-}(React.Component);
-
-ContextMenu.defaultProps = {
-  type: ContextMenuType.Canvas
-};
-var index$5 = withEditorContext(ContextMenu);
-
-var EditableLabel = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(EditableLabel, _React$Component);
-
-  function EditableLabel() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.el = null;
-    _this.state = {
-      visible: false
-    };
-
-    _this.update = function () {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          executeCommand = _this$props.executeCommand;
-      var node = getSelectedNodes(graph)[0];
-      var model = node.getModel();
-      var label = _this.el.textContent;
-
-      if (label === model.label) {
-        return;
-      }
-
-      executeCommand('update', {
-        id: model.id,
-        updateModel: {
-          label: label
-        },
-        forceRefreshLayout: isMind(graph)
-      });
-    };
-
-    _this.showEditableLabel = function () {
-      global.plugin.editableLabel.state = 'show';
-
-      _this.setState({
-        visible: true
-      }, function () {
-        var _assertThisInitialize = _assertThisInitialized(_this),
-            el = _assertThisInitialize.el;
-
-        if (el) {
-          el.focus();
-          document.execCommand('selectAll', false, null);
-        }
-      });
-    };
-
-    _this.hideEditableLabel = function () {
-      global.plugin.editableLabel.state = 'hide';
-
-      _this.setState({
-        visible: false
-      });
-    };
-
-    _this.handleBlur = function () {
-      _this.update();
-
-      _this.hideEditableLabel();
-    };
-
-    _this.handleKeyDown = function (e) {
-      e.stopPropagation();
-      var key = e.key;
-
-      if (['Tab'].includes(key)) {
-        e.preventDefault();
-      }
-
-      if (['Enter', 'Escape', 'Tab'].includes(key)) {
-        _this.update();
-
-        _this.hideEditableLabel();
-      }
-    };
-
-    return _this;
-  }
-
-  var _proto = EditableLabel.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var graph = this.props.graph;
-    graph.on(EditorEvent.onLabelStateChange, function (_ref) {
-      var labelState = _ref.labelState;
-
-      if (labelState === LabelState.Show) {
-        _this2.showEditableLabel();
-      } else {
-        _this2.hideEditableLabel();
-      }
-    });
-    graph.on(GraphNodeEvent.onNodeDoubleClick, function () {
-      _this2.showEditableLabel();
-    });
-  };
-
-  _proto.render = function render() {
-    var _this3 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        labelClassName = _this$props2.labelClassName,
-        labelMaxWidth = _this$props2.labelMaxWidth;
-    var mode = graph.getCurrentMode();
-    var zoom = graph.getZoom();
-
-    if (mode === GraphMode.Readonly) {
-      return null;
-    }
-
-    var node = getSelectedNodes(graph)[0];
-
-    if (!node) {
-      return null;
-    }
-
-    var model = node.getModel();
-    var group = node.getContainer();
-    var label = model.label;
-    var labelShape = group.findByClassName(labelClassName);
-
-    if (!labelShape) {
-      return null;
-    }
-
-    var visible = this.state.visible;
-
-    if (!visible) {
-      return null;
-    } // Get the label offset
-
-
-    var _labelShape$getBBox = labelShape.getBBox(),
-        relativeX = _labelShape$getBBox.x,
-        relativeY = _labelShape$getBBox.y;
-
-    var _G6$Util$applyMatrix = G6.Util.applyMatrix({
-      x: relativeX,
-      y: relativeY
-    }, node.getContainer().getMatrix()),
-        absoluteX = _G6$Util$applyMatrix.x,
-        absoluteY = _G6$Util$applyMatrix.y;
-
-    var _graph$getCanvasByPoi = graph.getCanvasByPoint(absoluteX, absoluteY),
-        left = _graph$getCanvasByPoi.x,
-        top = _graph$getCanvasByPoi.y; // Get the label size
-
-
-    var _labelShape$getBBox2 = labelShape.getBBox(),
-        width = _labelShape$getBBox2.width,
-        height = _labelShape$getBBox2.height; // Get the label font
-
-
-    var font = labelShape.attr('font');
-    var style = {
-      position: 'absolute',
-      top: top,
-      left: left,
-      width: 'auto',
-      height: 'auto',
-      minWidth: width,
-      minHeight: height,
-      maxWidth: labelMaxWidth,
-      font: font,
-      background: 'white',
-      border: '1px solid #1890ff',
-      outline: 'none',
-      transform: "scale(" + zoom + ")",
-      transformOrigin: 'left top'
-    };
-    return ReactDOM.createPortal(React.createElement("div", {
-      ref: function ref(el) {
-        _this3.el = el;
-      },
-      style: style,
-      contentEditable: true,
-      onBlur: this.handleBlur,
-      onKeyDown: this.handleKeyDown,
-      suppressContentEditableWarning: true
-    }, label), graph.get('container'));
-  };
-
-  return EditableLabel;
-}(React.Component);
-
-EditableLabel.defaultProps = {
-  labelClassName: 'node-label',
-  labelMaxWidth: 100
-};
-var index$6 = withEditorContext(EditableLabel);
-
+import '../es/shape';
+import * as Util from '../es/utils';
+import Editor from '../es/components/Editor';
+import Flow from '../es/components/Flow';
+import Mind from '../es/components/Mind';
+import Command from '../es/components/Command';
+import ItemPanel, { Item } from '../es/components/ItemPanel';
+import DetailPanel from '../es/components/DetailPanel';
+import { RegisterNode, RegisterEdge, RegisterCommand, RegisterBehavior } from '../es/components/Register';
+import { withEditorContext } from '../es/components/EditorContext';
+import { baseCommand } from '../es/components/Graph/command/base';
+import ItemPopover from '../es/plugins/ItemPopover';
+import ContextMenu from '../es/plugins/ContextMenu';
+import EditableLabel from '../es/plugins/EditableLabel';
+import global from '../es/common/global';
+import * as constants from '../es/common/constants';
+import CommandManager from '../es/common/CommandManager';
+import behaviorManager from '../es/common/behaviorManager';
+import { setAnchorPointsState } from '../es/shape/common/anchor';
+export { G6, Util, Flow, Mind, Command, Item, ItemPanel, DetailPanel, RegisterNode, RegisterEdge, RegisterCommand, RegisterBehavior, withEditorContext, baseCommand, ItemPopover, ContextMenu, EditableLabel, global, constants, CommandManager, behaviorManager, setAnchorPointsState };
 export default Editor;
\ No newline at end of file
-export { index$2 as Command, CommandManager, index$5 as ContextMenu, DetailPanel, index$6 as EditableLabel, Flow, Item$1 as Item, index$3 as ItemPanel, index$4 as ItemPopover, Mind, RegisterBehavior, RegisterCommand, RegisterEdge, RegisterNode, index$1 as Util, baseCommand, behaviorManager, index as constants, global, setAnchorPointsState, withEditorContext };
diff --git a/node_modules/gg-editor/es/plugins/ContextMenu/index.d.ts b/node_modules/gg-editor/es/plugins/ContextMenu/index.d.ts
new file mode 100644
index 0000000..401c777
--- /dev/null
+++ b/node_modules/gg-editor/es/plugins/ContextMenu/index.d.ts
@@ -0,0 +1,19 @@
+import React from 'react';
+import { Item } from '../../../es/common/interfaces';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+export declare enum ContextMenuType {
+    Canvas = "canvas",
+    Node = "node",
+    Edge = "edge"
+}
+interface ContextMenuProps extends EditorContextProps {
+    /** 菜单类型 */
+    type?: ContextMenuType;
+    /** 菜单内容 */
+    renderContent: (item: Item, position: {
+        x: number;
+        y: number;
+    }, hide: () => void) => React.ReactNode;
+}
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ContextMenuProps>, "type" | "children" | "renderContent"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/plugins/ContextMenu/index.js b/node_modules/gg-editor/es/plugins/ContextMenu/index.js
new file mode 100644
index 0000000..5fed07a
--- /dev/null
+++ b/node_modules/gg-editor/es/plugins/ContextMenu/index.js
@@ -0,0 +1,166 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import ReactDOM from 'react-dom';
+import { clearSelectedState } from '../../../es/utils';
+import global from '../../../es/common/global';
+import { ItemState, GraphCommonEvent, GraphNodeEvent, GraphEdgeEvent, GraphCanvasEvent } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+export var ContextMenuType;
+
+(function (ContextMenuType) {
+  ContextMenuType["Canvas"] = "canvas";
+  ContextMenuType["Node"] = "node";
+  ContextMenuType["Edge"] = "edge";
+})(ContextMenuType || (ContextMenuType = {}));
+
+var ContextMenu =
+/** @class */
+function () {
+  var ContextMenu = /*#__PURE__*/function (_React$Component) {
+    _inherits(ContextMenu, _React$Component);
+
+    var _super = _createSuper(ContextMenu);
+
+    function ContextMenu() {
+      var _this;
+
+      _classCallCheck(this, ContextMenu);
+
+      _this = _super.apply(this, arguments);
+      _this.state = {
+        visible: false,
+        content: null
+      };
+
+      _this.showContextMenu = function (x, y, item) {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            renderContent = _this$props.renderContent;
+        clearSelectedState(graph);
+
+        if (item) {
+          graph.setItemState(item, ItemState.Selected, true);
+        }
+
+        global.plugin.contextMenu.state = 'show';
+        global.clipboard.point = {
+          x: x,
+          y: y
+        };
+        var position = graph.getCanvasByPoint(x, y);
+
+        _this.setState({
+          visible: true,
+          content: renderContent(item, position, _this.hideContextMenu)
+        });
+      };
+
+      _this.hideContextMenu = function () {
+        global.plugin.contextMenu.state = 'hide';
+
+        _this.setState({
+          visible: false,
+          content: null
+        });
+      };
+
+      return _this;
+    }
+
+    _createClass(ContextMenu, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            type = _this$props2.type;
+
+        switch (type) {
+          case ContextMenuType.Canvas:
+            graph.on(GraphCanvasEvent.onCanvasContextMenu, function (e) {
+              e.preventDefault();
+              var x = e.x,
+                  y = e.y;
+
+              _this2.showContextMenu(x, y);
+            });
+            break;
+
+          case ContextMenuType.Node:
+            graph.on(GraphNodeEvent.onNodeContextMenu, function (e) {
+              e.preventDefault();
+              var x = e.x,
+                  y = e.y,
+                  item = e.item;
+
+              _this2.showContextMenu(x, y, item);
+            });
+            break;
+
+          case ContextMenuType.Edge:
+            graph.on(GraphEdgeEvent.onEdgeContextMenu, function (e) {
+              e.preventDefault();
+              var x = e.x,
+                  y = e.y,
+                  item = e.item;
+
+              _this2.showContextMenu(x, y, item);
+            });
+            break;
+
+          default:
+            break;
+        }
+
+        graph.on(GraphCommonEvent.onClick, function () {
+          _this2.hideContextMenu();
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var graph = this.props.graph;
+        var _this$state = this.state,
+            visible = _this$state.visible,
+            content = _this$state.content;
+
+        if (!visible) {
+          return null;
+        }
+
+        return /*#__PURE__*/ReactDOM.createPortal(content, graph.get('container'));
+      }
+    }]);
+
+    return ContextMenu;
+  }(React.Component);
+
+  ContextMenu.defaultProps = {
+    type: ContextMenuType.Canvas
+  };
+  return ContextMenu;
+}();
+
+export default withEditorContext(ContextMenu);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/plugins/EditableLabel/index.d.ts b/node_modules/gg-editor/es/plugins/EditableLabel/index.d.ts
new file mode 100644
index 0000000..673bcb0
--- /dev/null
+++ b/node_modules/gg-editor/es/plugins/EditableLabel/index.d.ts
@@ -0,0 +1,10 @@
+import React from 'react';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+interface EditableLabelProps extends EditorContextProps {
+    /** 标签图形类名 */
+    labelClassName?: string;
+    /** 标签最大宽度 */
+    labelMaxWidth?: number;
+}
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<EditableLabelProps>, "children" | "labelClassName" | "labelMaxWidth"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/plugins/EditableLabel/index.js b/node_modules/gg-editor/es/plugins/EditableLabel/index.js
new file mode 100644
index 0000000..817bb8b
--- /dev/null
+++ b/node_modules/gg-editor/es/plugins/EditableLabel/index.js
@@ -0,0 +1,237 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import ReactDOM from 'react-dom';
+import G6 from '@antv/g6';
+import { isMind, getSelectedNodes } from '../../../es/utils';
+import global from '../../../es/common/global';
+import { GraphMode, EditorEvent, GraphNodeEvent, LabelState } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+
+var EditableLabel =
+/** @class */
+function () {
+  var EditableLabel = /*#__PURE__*/function (_React$Component) {
+    _inherits(EditableLabel, _React$Component);
+
+    var _super = _createSuper(EditableLabel);
+
+    function EditableLabel() {
+      var _this;
+
+      _classCallCheck(this, EditableLabel);
+
+      _this = _super.apply(this, arguments);
+      _this.el = null;
+      _this.state = {
+        visible: false
+      };
+
+      _this.update = function () {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            executeCommand = _this$props.executeCommand;
+        var node = getSelectedNodes(graph)[0];
+        var model = node.getModel();
+        var label = _this.el.textContent;
+
+        if (label === model.label) {
+          return;
+        }
+
+        executeCommand('update', {
+          id: model.id,
+          updateModel: {
+            label: label
+          },
+          forceRefreshLayout: isMind(graph)
+        });
+      };
+
+      _this.showEditableLabel = function () {
+        global.plugin.editableLabel.state = 'show';
+
+        _this.setState({
+          visible: true
+        }, function () {
+          var _assertThisInitialize = _assertThisInitialized(_this),
+              el = _assertThisInitialize.el;
+
+          if (el) {
+            el.focus();
+            document.execCommand('selectAll', false, null);
+          }
+        });
+      };
+
+      _this.hideEditableLabel = function () {
+        global.plugin.editableLabel.state = 'hide';
+
+        _this.setState({
+          visible: false
+        });
+      };
+
+      _this.handleBlur = function () {
+        _this.update();
+
+        _this.hideEditableLabel();
+      };
+
+      _this.handleKeyDown = function (e) {
+        e.stopPropagation();
+        var key = e.key;
+
+        if (['Tab'].includes(key)) {
+          e.preventDefault();
+        }
+
+        if (['Enter', 'Escape', 'Tab'].includes(key)) {
+          _this.update();
+
+          _this.hideEditableLabel();
+        }
+      };
+
+      return _this;
+    }
+
+    _createClass(EditableLabel, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var graph = this.props.graph;
+        graph.on(EditorEvent.onLabelStateChange, function (_ref) {
+          var labelState = _ref.labelState;
+
+          if (labelState === LabelState.Show) {
+            _this2.showEditableLabel();
+          } else {
+            _this2.hideEditableLabel();
+          }
+        });
+        graph.on(GraphNodeEvent.onNodeDoubleClick, function () {
+          _this2.showEditableLabel();
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var _this3 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            labelClassName = _this$props2.labelClassName,
+            labelMaxWidth = _this$props2.labelMaxWidth;
+        var mode = graph.getCurrentMode();
+        var zoom = graph.getZoom();
+
+        if (mode === GraphMode.Readonly) {
+          return null;
+        }
+
+        var node = getSelectedNodes(graph)[0];
+
+        if (!node) {
+          return null;
+        }
+
+        var model = node.getModel();
+        var group = node.getContainer();
+        var label = model.label;
+        var labelShape = group.findByClassName(labelClassName);
+
+        if (!labelShape) {
+          return null;
+        }
+
+        var visible = this.state.visible;
+
+        if (!visible) {
+          return null;
+        } // Get the label offset
+
+
+        var _labelShape$getBBox = labelShape.getBBox(),
+            relativeX = _labelShape$getBBox.x,
+            relativeY = _labelShape$getBBox.y;
+
+        var _G6$Util$applyMatrix = G6.Util.applyMatrix({
+          x: relativeX,
+          y: relativeY
+        }, node.getContainer().getMatrix()),
+            absoluteX = _G6$Util$applyMatrix.x,
+            absoluteY = _G6$Util$applyMatrix.y;
+
+        var _graph$getCanvasByPoi = graph.getCanvasByPoint(absoluteX, absoluteY),
+            left = _graph$getCanvasByPoi.x,
+            top = _graph$getCanvasByPoi.y; // Get the label size
+
+
+        var _labelShape$getBBox2 = labelShape.getBBox(),
+            width = _labelShape$getBBox2.width,
+            height = _labelShape$getBBox2.height; // Get the label font
+
+
+        var font = labelShape.attr('font');
+        var style = {
+          position: 'absolute',
+          top: top,
+          left: left,
+          width: 'auto',
+          height: 'auto',
+          minWidth: width,
+          minHeight: height,
+          maxWidth: labelMaxWidth,
+          font: font,
+          background: 'white',
+          border: '1px solid #1890ff',
+          outline: 'none',
+          transform: "scale(".concat(zoom, ")"),
+          transformOrigin: 'left top'
+        };
+        return /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement("div", {
+          ref: function ref(el) {
+            _this3.el = el;
+          },
+          style: style,
+          contentEditable: true,
+          onBlur: this.handleBlur,
+          onKeyDown: this.handleKeyDown,
+          suppressContentEditableWarning: true
+        }, label), graph.get('container'));
+      }
+    }]);
+
+    return EditableLabel;
+  }(React.Component);
+
+  EditableLabel.defaultProps = {
+    labelClassName: 'node-label',
+    labelMaxWidth: 100
+  };
+  return EditableLabel;
+}();
+
+export default withEditorContext(EditableLabel);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/plugins/ItemPopover/index.d.ts b/node_modules/gg-editor/es/plugins/ItemPopover/index.d.ts
new file mode 100644
index 0000000..f360130
--- /dev/null
+++ b/node_modules/gg-editor/es/plugins/ItemPopover/index.d.ts
@@ -0,0 +1,22 @@
+import React from 'react';
+import { Item } from '../../../es/common/interfaces';
+import { EditorContextProps } from '../../../es/components/EditorContext';
+export declare enum ItemPopoverType {
+    Node = "node",
+    Edge = "edge"
+}
+interface ItemPopoverProps extends EditorContextProps {
+    /** 浮层类型 */
+    type?: ItemPopoverType;
+    /** 浮层内容 */
+    renderContent: (item: Item, position: {
+        minX: number;
+        minY: number;
+        maxX: number;
+        maxY: number;
+        centerX: number;
+        centerY: number;
+    }) => React.ReactNode;
+}
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemPopoverProps>, "type" | "children" | "renderContent"> & React.RefAttributes<unknown>>;
+export default _default;
diff --git a/node_modules/gg-editor/es/plugins/ItemPopover/index.js b/node_modules/gg-editor/es/plugins/ItemPopover/index.js
new file mode 100644
index 0000000..5fd056d
--- /dev/null
+++ b/node_modules/gg-editor/es/plugins/ItemPopover/index.js
@@ -0,0 +1,156 @@
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+import React from 'react';
+import ReactDOM from 'react-dom';
+import delay from 'lodash/delay';
+import global from '../../../es/common/global';
+import { GraphNodeEvent } from '../../../es/common/constants';
+import { withEditorContext } from '../../../es/components/EditorContext';
+export var ItemPopoverType;
+
+(function (ItemPopoverType) {
+  ItemPopoverType["Node"] = "node";
+  ItemPopoverType["Edge"] = "edge";
+})(ItemPopoverType || (ItemPopoverType = {}));
+
+var ItemPopover =
+/** @class */
+function () {
+  var ItemPopover = /*#__PURE__*/function (_React$Component) {
+    _inherits(ItemPopover, _React$Component);
+
+    var _super = _createSuper(ItemPopover);
+
+    function ItemPopover() {
+      var _this;
+
+      _classCallCheck(this, ItemPopover);
+
+      _this = _super.apply(this, arguments);
+      _this.state = {
+        visible: false,
+        content: null
+      };
+      _this.mouseEnterTimeoutID = 0;
+      _this.mouseLeaveTimeoutID = 0;
+
+      _this.showItemPopover = function (item) {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            renderContent = _this$props.renderContent;
+        global.plugin.itemPopover.state = 'show';
+
+        var _item$getBBox = item.getBBox(),
+            minX = _item$getBBox.minX,
+            minY = _item$getBBox.minY,
+            maxX = _item$getBBox.maxX,
+            maxY = _item$getBBox.maxY,
+            centerX = _item$getBBox.centerX,
+            centerY = _item$getBBox.centerY;
+
+        var _graph$getCanvasByPoi = graph.getCanvasByPoint(minX, minY),
+            itemMinX = _graph$getCanvasByPoi.x,
+            itemMinY = _graph$getCanvasByPoi.y;
+
+        var _graph$getCanvasByPoi2 = graph.getCanvasByPoint(maxX, maxY),
+            itemMaxX = _graph$getCanvasByPoi2.x,
+            itemMaxY = _graph$getCanvasByPoi2.y;
+
+        var _graph$getCanvasByPoi3 = graph.getCanvasByPoint(centerX, centerY),
+            itemCenterX = _graph$getCanvasByPoi3.x,
+            itemCenterY = _graph$getCanvasByPoi3.y;
+
+        var position = {
+          minX: itemMinX,
+          minY: itemMinY,
+          maxX: itemMaxX,
+          maxY: itemMaxY,
+          centerX: itemCenterX,
+          centerY: itemCenterY
+        };
+
+        _this.setState({
+          visible: true,
+          content: renderContent(item, position)
+        });
+      };
+
+      _this.hideItemPopover = function () {
+        global.plugin.itemPopover.state = 'hide';
+
+        _this.setState({
+          visible: false,
+          content: null
+        });
+      };
+
+      return _this;
+    }
+
+    _createClass(ItemPopover, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            type = _this$props2.type;
+
+        if (type === ItemPopoverType.Node) {
+          graph.on(GraphNodeEvent.onNodeMouseEnter, function (_ref) {
+            var item = _ref.item;
+            clearTimeout(_this2.mouseLeaveTimeoutID);
+            _this2.mouseEnterTimeoutID = delay(_this2.showItemPopover, 250, item);
+          });
+          graph.on(GraphNodeEvent.onNodeMouseLeave, function () {
+            clearTimeout(_this2.mouseEnterTimeoutID);
+            _this2.mouseLeaveTimeoutID = delay(_this2.hideItemPopover, 250);
+          });
+        }
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var graph = this.props.graph;
+        var _this$state = this.state,
+            visible = _this$state.visible,
+            content = _this$state.content;
+
+        if (!visible) {
+          return null;
+        }
+
+        return /*#__PURE__*/ReactDOM.createPortal(content, graph.get('container'));
+      }
+    }]);
+
+    return ItemPopover;
+  }(React.Component);
+
+  ItemPopover.defaultProps = {
+    type: ItemPopoverType.Node
+  };
+  return ItemPopover;
+}();
+
+export default withEditorContext(ItemPopover);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/common/anchor.d.ts b/node_modules/gg-editor/es/shape/common/anchor.d.ts
new file mode 100644
index 0000000..2f4ac5f
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/common/anchor.d.ts
@@ -0,0 +1,10 @@
+import { ShapeStyle, NodeModel, Item, Node } from '../../../es/common/interfaces';
+interface AnchorPointContextProps {
+    getAnchorPoints?(model: NodeModel): number[][];
+}
+declare type GetAnchorPointStyle = (item: Node, anchorPoint: number[]) => ShapeStyle;
+declare type GetAnchorPointDisabledStyle = (item: Node, anchorPoint: number[]) => ShapeStyle & {
+    img?: string;
+};
+declare function setAnchorPointsState(this: AnchorPointContextProps, name: string, value: string | boolean, item: Item, getAnchorPointStyle?: GetAnchorPointStyle, getAnchorPointDisabledStyle?: GetAnchorPointDisabledStyle): void;
+export { setAnchorPointsState };
diff --git a/node_modules/gg-editor/es/shape/common/anchor.js b/node_modules/gg-editor/es/shape/common/anchor.js
new file mode 100644
index 0000000..f44df2f
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/common/anchor.js
@@ -0,0 +1,112 @@
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+import { ItemState, AnchorPointState } from '../../../es/common/constants';
+var ANCHOR_POINT_NAME = 'anchorPoint';
+
+var getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {
+  var _item$getKeyShape$get = item.getKeyShape().getBBox(),
+      width = _item$getKeyShape$get.width,
+      height = _item$getKeyShape$get.height;
+
+  var _anchorPoint = _slicedToArray(anchorPoint, 2),
+      x = _anchorPoint[0],
+      y = _anchorPoint[1];
+
+  return {
+    x: width * x,
+    y: height * y - 3,
+    r: 3,
+    lineWidth: 2,
+    fill: '#FFFFFF',
+    stroke: '#5AAAFF'
+  };
+};
+
+var getAnchorPointDefaultDisabledStyle = function getAnchorPointDefaultDisabledStyle(item, anchorPoint) {
+  var _item$getKeyShape$get2 = item.getKeyShape().getBBox(),
+      width = _item$getKeyShape$get2.width,
+      height = _item$getKeyShape$get2.height;
+
+  var _anchorPoint2 = _slicedToArray(anchorPoint, 2),
+      x = _anchorPoint2[0],
+      y = _anchorPoint2[1];
+
+  return {
+    img: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0xLjUxNSAxLjE3Mmw1LjY1NyA1LjY1Nm0wLTUuNjU2TDEuNTE1IDYuODI4IiBzdHJva2U9IiNGRjYwNjAiIHN0cm9rZS13aWR0aD0iMS42IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIi8+PC9zdmc+',
+    x: width * x - 4,
+    y: height * y - 8,
+    width: 8,
+    height: 8
+  };
+};
+
+function drawAnchorPoints(item, getAnchorPointStyle, getAnchorPointDisabledStyle) {
+  var group = item.getContainer();
+  var model = item.getModel();
+  var anchorPoints = this.getAnchorPoints ? this.getAnchorPoints(model) : [];
+  var anchorPointsState = item.get('anchorPointsState') || [];
+  anchorPoints.forEach(function (anchorPoint, index) {
+    if (anchorPointsState[index] === AnchorPointState.Enabled) {
+      group.addShape('circle', {
+        name: ANCHOR_POINT_NAME,
+        attrs: _objectSpread(_objectSpread({}, getAnchorPointDefaultStyle(item, anchorPoint)), getAnchorPointStyle(item, anchorPoint)),
+        isAnchorPoint: true,
+        anchorPointIndex: index,
+        anchorPointState: AnchorPointState.Enabled
+      });
+    } else {
+      group.addShape('image', {
+        name: ANCHOR_POINT_NAME,
+        attrs: _objectSpread(_objectSpread({}, getAnchorPointDefaultDisabledStyle(item, anchorPoint)), getAnchorPointDisabledStyle(item, anchorPoint)),
+        isAnchorPoint: true,
+        anchorPointIndex: index,
+        anchorPointState: AnchorPointState.Disabled
+      });
+    }
+  });
+}
+
+function removeAnchorPoints(item) {
+  var group = item.getContainer();
+  var anchorPoints = group.findAllByName(ANCHOR_POINT_NAME);
+  anchorPoints.forEach(function (anchorPoint) {
+    group.removeChild(anchorPoint);
+  });
+}
+
+function setAnchorPointsState(name, value, item) {
+  var getAnchorPointStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {
+    return {};
+  };
+  var getAnchorPointDisabledStyle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
+    return {};
+  };
+
+  if (name !== ItemState.ActiveAnchorPoints) {
+    return;
+  }
+
+  if (value) {
+    drawAnchorPoints.call(this, item, getAnchorPointStyle, getAnchorPointDisabledStyle);
+  } else {
+    removeAnchorPoints.call(this, item);
+  }
+}
+
+export { setAnchorPointsState };
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/edges/bizFlowEdge.d.ts b/node_modules/gg-editor/es/shape/edges/bizFlowEdge.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/edges/bizFlowEdge.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/shape/edges/bizFlowEdge.js b/node_modules/gg-editor/es/shape/edges/bizFlowEdge.js
new file mode 100644
index 0000000..664ffa4
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/edges/bizFlowEdge.js
@@ -0,0 +1,132 @@
+var _stateStyles;
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import G6 from '@antv/g6';
+import { ItemState } from '../../../es/common/constants';
+var EDGE_LABEL_CLASS_NAME = 'edge-label';
+var EDGE_LABEL_WRAPPER_CLASS_NAME = 'edge-label-wrapper-label';
+var bizFlowEdge = {
+  options: {
+    style: {
+      stroke: '#ccc1d8',
+      lineWidth: 2,
+      shadowColor: null,
+      shadowBlur: 0,
+      radius: 8,
+      offset: 24,
+      // startArrow: {
+      //   path: 'M 3,0 A 3,3,0,1,1,-3,0 A 3,3,0,1,1,3,0 Z',
+      //   d: 7,
+      // },
+      // endArrow: {
+      //   path: 'M 3,0 L -3,-3 L -3,3 Z',
+      //   d: 5,
+      // },
+      endArrow: {
+        path: 'M 0,0 L 4,3 L 4,-3 Z'
+      }
+    },
+    labelCfg: {
+      style: {
+        fill: '#000000',
+        fontSize: 10
+      }
+    },
+    stateStyles: (_stateStyles = {}, _defineProperty(_stateStyles, ItemState.Selected, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _defineProperty(_stateStyles, ItemState.HighLight, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _stateStyles)
+  },
+  createLabelWrapper: function createLabelWrapper(group) {
+    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
+    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
+
+    if (!label) {
+      return;
+    }
+
+    if (labelWrapper) {
+      return;
+    }
+
+    group.addShape('rect', {
+      className: EDGE_LABEL_WRAPPER_CLASS_NAME,
+      attrs: {
+        fill: '#e1e5e8',
+        radius: 2
+      }
+    });
+    label.set('zIndex', 1);
+    group.sort();
+  },
+  updateLabelWrapper: function updateLabelWrapper(group) {
+    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
+    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
+
+    if (!label) {
+      labelWrapper && labelWrapper.hide();
+      return;
+    } else {
+      labelWrapper && labelWrapper.show();
+    }
+
+    if (!labelWrapper) {
+      return;
+    }
+
+    var _label$getBBox = label.getBBox(),
+        minX = _label$getBBox.minX,
+        minY = _label$getBBox.minY,
+        width = _label$getBBox.width,
+        height = _label$getBBox.height;
+
+    labelWrapper.attr({
+      x: minX - 5,
+      y: minY - 3,
+      width: width + 10,
+      height: height + 6
+    });
+  },
+  afterDraw: function afterDraw(model, group) {
+    this.createLabelWrapper(group);
+    this.updateLabelWrapper(group);
+  },
+  afterUpdate: function afterUpdate(model, item) {
+    var group = item.getContainer();
+    this.createLabelWrapper(group);
+    this.updateLabelWrapper(group);
+  },
+  setState: function setState(name, value, item) {
+    var shape = item.get('keyShape');
+
+    if (!shape) {
+      return;
+    }
+
+    var _this$options = this.options,
+        style = _this$options.style,
+        stateStyles = _this$options.stateStyles;
+    var stateStyle = stateStyles[name];
+
+    if (!stateStyle) {
+      return;
+    }
+
+    if (value) {
+      shape.attr(_objectSpread(_objectSpread({}, style), stateStyle));
+    } else {
+      shape.attr(style);
+    }
+  }
+};
+G6.registerEdge('bizFlowEdge', bizFlowEdge, 'polyline');
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/edges/bizMindEdge.d.ts b/node_modules/gg-editor/es/shape/edges/bizMindEdge.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/edges/bizMindEdge.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/shape/edges/bizMindEdge.js b/node_modules/gg-editor/es/shape/edges/bizMindEdge.js
new file mode 100644
index 0000000..e4d4475
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/edges/bizMindEdge.js
@@ -0,0 +1,26 @@
+var _stateStyles;
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import G6 from '@antv/g6';
+import { ItemState } from '../../../es/common/constants';
+var bizMindEdge = {
+  options: {
+    style: {
+      stroke: '#ccc1d8',
+      lineWidth: 2,
+      shadowColor: null,
+      shadowBlur: 0
+    },
+    stateStyles: (_stateStyles = {}, _defineProperty(_stateStyles, ItemState.Selected, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _defineProperty(_stateStyles, ItemState.HighLight, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _stateStyles)
+  }
+};
+G6.registerEdge('bizMindEdge', bizMindEdge, 'cubic-horizontal');
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/index.d.ts b/node_modules/gg-editor/es/shape/index.d.ts
new file mode 100644
index 0000000..cd908b3
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/index.d.ts
@@ -0,0 +1,5 @@
+import './nodes/bizNode';
+import './nodes/bizFlowNode';
+import './nodes/bizMindNode';
+import './edges/bizFlowEdge';
+import './edges/bizMindEdge';
diff --git a/node_modules/gg-editor/es/shape/index.js b/node_modules/gg-editor/es/shape/index.js
new file mode 100644
index 0000000..d02b0d1
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/index.js
@@ -0,0 +1,5 @@
+import './nodes/bizNode';
+import './nodes/bizFlowNode';
+import './nodes/bizMindNode';
+import './edges/bizFlowEdge';
+import './edges/bizMindEdge';
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/nodes/bizFlowNode.d.ts b/node_modules/gg-editor/es/shape/nodes/bizFlowNode.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/nodes/bizFlowNode.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/shape/nodes/bizFlowNode.js b/node_modules/gg-editor/es/shape/nodes/bizFlowNode.js
new file mode 100644
index 0000000..ac4ecd7
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/nodes/bizFlowNode.js
@@ -0,0 +1,11 @@
+import G6 from '@antv/g6';
+import { setAnchorPointsState } from '../common/anchor';
+var bizFlowNode = {
+  afterSetState: function afterSetState(name, value, item) {
+    setAnchorPointsState.call(this, name, value, item);
+  },
+  getAnchorPoints: function getAnchorPoints() {
+    return [[0.5, 0], [0.5, 1], [0, 0.5], [1, 0.5]];
+  }
+};
+G6.registerNode('bizFlowNode', bizFlowNode, 'bizNode');
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/nodes/bizMindNode.d.ts b/node_modules/gg-editor/es/shape/nodes/bizMindNode.d.ts
new file mode 100644
index 0000000..011f3de
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/nodes/bizMindNode.d.ts
@@ -0,0 +1,2 @@
+export declare const FOLD_BUTTON_CLASS_NAME = "node-fold-button";
+export declare const UNFOLD_BUTTON_CLASS_NAME = "node-unfold-button";
diff --git a/node_modules/gg-editor/es/shape/nodes/bizMindNode.js b/node_modules/gg-editor/es/shape/nodes/bizMindNode.js
new file mode 100644
index 0000000..06284c4
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/nodes/bizMindNode.js
@@ -0,0 +1,85 @@
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+import G6 from '@antv/g6';
+import { getNodeSide, getFoldButtonPath, getUnfoldButtonPath } from '../utils';
+export var FOLD_BUTTON_CLASS_NAME = 'node-fold-button';
+export var UNFOLD_BUTTON_CLASS_NAME = 'node-unfold-button';
+var bizMindNode = {
+  afterDraw: function afterDraw(model, group) {
+    this.drawButton(model, group);
+  },
+  afterUpdate: function afterUpdate(model, item) {
+    var group = item.getContainer();
+    this.drawButton(model, group);
+    this.adjustButton(model, item);
+  },
+  drawButton: function drawButton(model, group) {
+    var children = model.children,
+        collapsed = model.collapsed;
+    [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].forEach(function (className) {
+      var shape = group.findByClassName(className);
+
+      if (shape) {
+        shape.destroy();
+      }
+    });
+
+    if (!children || !children.length) {
+      return;
+    }
+
+    if (!collapsed) {
+      group.addShape('path', {
+        className: FOLD_BUTTON_CLASS_NAME,
+        attrs: {
+          path: getFoldButtonPath(),
+          fill: '#ffffff',
+          stroke: '#ccc1d8'
+        }
+      });
+    } else {
+      group.addShape('path', {
+        className: UNFOLD_BUTTON_CLASS_NAME,
+        attrs: {
+          path: getUnfoldButtonPath(),
+          fill: '#ffffff',
+          stroke: '#ccc1d8'
+        }
+      });
+    }
+  },
+  adjustButton: function adjustButton(model, item) {
+    var children = model.children,
+        collapsed = model.collapsed;
+
+    if (!children || !children.length) {
+      return;
+    }
+
+    var group = item.getContainer();
+    var shape = group.findByClassName(!collapsed ? FOLD_BUTTON_CLASS_NAME : UNFOLD_BUTTON_CLASS_NAME);
+
+    var _this$getSize = this.getSize(model),
+        _this$getSize2 = _slicedToArray(_this$getSize, 2),
+        width = _this$getSize2[0],
+        height = _this$getSize2[1];
+
+    var x = getNodeSide(item) === 'left' ? -24 : width + 10;
+    var y = height / 2 - 9;
+    shape.translate(x, y);
+  },
+  getAnchorPoints: function getAnchorPoints() {
+    return [[0, 0.5], [1, 0.5]];
+  }
+};
+G6.registerNode('bizMindNode', bizMindNode, 'bizNode');
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/nodes/bizNode.d.ts b/node_modules/gg-editor/es/shape/nodes/bizNode.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/nodes/bizNode.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/gg-editor/es/shape/nodes/bizNode.js b/node_modules/gg-editor/es/shape/nodes/bizNode.js
new file mode 100644
index 0000000..3c9df04
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/nodes/bizNode.js
@@ -0,0 +1,220 @@
+var _stateStyles;
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import G6 from '@antv/g6';
+import merge from 'lodash/merge';
+import isArray from 'lodash/isArray';
+import { ItemState } from '../../../es/common/constants';
+import { optimizeMultilineText } from '../utils';
+var WRAPPER_BORDER_WIDTH = 2;
+var WRAPPER_HORIZONTAL_PADDING = 10;
+var WRAPPER_CLASS_NAME = 'node-wrapper';
+var CONTENT_CLASS_NAME = 'node-content';
+var LABEL_CLASS_NAME = 'node-label';
+var bizNode = {
+  options: {
+    size: [120, 60],
+    wrapperStyle: {
+      fill: '#5487ea',
+      radius: 8
+    },
+    contentStyle: {
+      fill: '#ffffff',
+      radius: 6
+    },
+    labelStyle: {
+      fill: '#000000',
+      textAlign: 'center',
+      textBaseline: 'middle'
+    },
+    stateStyles: (_stateStyles = {}, _defineProperty(_stateStyles, ItemState.Active, {
+      wrapperStyle: {},
+      contentStyle: {},
+      labelStyle: {}
+    }), _defineProperty(_stateStyles, ItemState.Selected, {
+      wrapperStyle: {},
+      contentStyle: {},
+      labelStyle: {}
+    }), _stateStyles)
+  },
+  getOptions: function getOptions(model) {
+    return merge({}, this.options, this.getCustomConfig(model) || {}, model);
+  },
+  draw: function draw(model, group) {
+    var keyShape = this.drawWrapper(model, group);
+    this.drawContent(model, group);
+    this.drawLabel(model, group);
+    return keyShape;
+  },
+  drawWrapper: function drawWrapper(model, group) {
+    var _this$getSize = this.getSize(model),
+        _this$getSize2 = _slicedToArray(_this$getSize, 2),
+        width = _this$getSize2[0],
+        height = _this$getSize2[1];
+
+    var _this$getOptions = this.getOptions(model),
+        wrapperStyle = _this$getOptions.wrapperStyle;
+
+    var shape = group.addShape('rect', {
+      className: WRAPPER_CLASS_NAME,
+      draggable: true,
+      attrs: _objectSpread({
+        x: 0,
+        y: -WRAPPER_BORDER_WIDTH * 2,
+        width: width,
+        height: height + WRAPPER_BORDER_WIDTH * 2
+      }, wrapperStyle)
+    });
+    return shape;
+  },
+  drawContent: function drawContent(model, group) {
+    var _this$getSize3 = this.getSize(model),
+        _this$getSize4 = _slicedToArray(_this$getSize3, 2),
+        width = _this$getSize4[0],
+        height = _this$getSize4[1];
+
+    var _this$getOptions2 = this.getOptions(model),
+        contentStyle = _this$getOptions2.contentStyle;
+
+    var shape = group.addShape('rect', {
+      className: CONTENT_CLASS_NAME,
+      draggable: true,
+      attrs: _objectSpread({
+        x: 0,
+        y: 0,
+        width: width,
+        height: height
+      }, contentStyle)
+    });
+    return shape;
+  },
+  drawLabel: function drawLabel(model, group) {
+    var _this$getSize5 = this.getSize(model),
+        _this$getSize6 = _slicedToArray(_this$getSize5, 2),
+        width = _this$getSize6[0],
+        height = _this$getSize6[1];
+
+    var _this$getOptions3 = this.getOptions(model),
+        labelStyle = _this$getOptions3.labelStyle;
+
+    var shape = group.addShape('text', {
+      className: LABEL_CLASS_NAME,
+      draggable: true,
+      attrs: _objectSpread({
+        x: width / 2,
+        y: height / 2,
+        text: model.label
+      }, labelStyle)
+    });
+    return shape;
+  },
+  setLabelText: function setLabelText(model, group) {
+    var shape = group.findByClassName(LABEL_CLASS_NAME);
+
+    if (!shape) {
+      return;
+    }
+
+    var _this$getSize7 = this.getSize(model),
+        _this$getSize8 = _slicedToArray(_this$getSize7, 1),
+        width = _this$getSize8[0];
+
+    var _shape$attr = shape.attr(),
+        fontStyle = _shape$attr.fontStyle,
+        fontWeight = _shape$attr.fontWeight,
+        fontSize = _shape$attr.fontSize,
+        fontFamily = _shape$attr.fontFamily;
+
+    var text = model.label;
+    var font = "".concat(fontStyle, " ").concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily); //@ts-ignore
+
+    shape.attr(text, optimizeMultilineText(text, font, 2, width - WRAPPER_HORIZONTAL_PADDING * 2));
+  },
+  update: function update(model, item) {
+    var group = item.getContainer();
+    this.setLabelText(model, group);
+  },
+  setState: function setState(name, value, item) {
+    var _this = this;
+
+    var group = item.getContainer();
+    var model = item.getModel();
+    var states = item.getStates();
+    [WRAPPER_CLASS_NAME, CONTENT_CLASS_NAME, LABEL_CLASS_NAME].forEach(function (className) {
+      var shape = group.findByClassName(className);
+
+      var options = _this.getOptions(model);
+
+      var shapeName = className.split('-')[1];
+      shape.attr(_objectSpread({}, options["".concat(shapeName, "Style")]));
+      states.forEach(function (state) {
+        if (options.stateStyles[state] && options.stateStyles[state]["".concat(shapeName, "Style")]) {
+          shape.attr(_objectSpread({}, options.stateStyles[state]["".concat(shapeName, "Style")]));
+        }
+      });
+    });
+
+    if (name === ItemState.Selected) {
+      var wrapperShape = group.findByClassName(WRAPPER_CLASS_NAME);
+
+      var _this$getSize9 = this.getSize(model),
+          _this$getSize10 = _slicedToArray(_this$getSize9, 2),
+          width = _this$getSize10[0],
+          height = _this$getSize10[1];
+
+      if (value) {
+        wrapperShape.attr({
+          x: -WRAPPER_BORDER_WIDTH,
+          y: -WRAPPER_BORDER_WIDTH * 2,
+          width: width + WRAPPER_BORDER_WIDTH * 2,
+          height: height + WRAPPER_BORDER_WIDTH * 3
+        });
+      } else {
+        wrapperShape.attr({
+          x: 0,
+          y: -WRAPPER_BORDER_WIDTH * 2,
+          width: width,
+          height: height + WRAPPER_BORDER_WIDTH * 2
+        });
+      }
+    }
+
+    if (this.afterSetState) {
+      this.afterSetState(name, value, item);
+    }
+  },
+  getSize: function getSize(model) {
+    var _this$getOptions4 = this.getOptions(model),
+        size = _this$getOptions4.size;
+
+    if (!isArray(size)) {
+      return [size, size];
+    }
+
+    return size;
+  },
+  getCustomConfig: function getCustomConfig() {
+    return {};
+  },
+  getAnchorPoints: function getAnchorPoints() {
+    return [];
+  }
+};
+G6.registerNode('bizNode', bizNode);
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/shape/utils/index.d.ts b/node_modules/gg-editor/es/shape/utils/index.d.ts
new file mode 100644
index 0000000..66a52cb
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/utils/index.d.ts
@@ -0,0 +1,6 @@
+import { Node } from '../../../es/common/interfaces';
+export declare function getNodeSide(item: Node): 'left' | 'right';
+export declare function getRectPath(x: number, y: number, w: number, h: number, r: number): (string | number)[][];
+export declare function getFoldButtonPath(): string;
+export declare function getUnfoldButtonPath(): string;
+export declare function optimizeMultilineText(text: string, font: string, maxRows: number, maxWidth: number): string;
diff --git a/node_modules/gg-editor/es/shape/utils/index.js b/node_modules/gg-editor/es/shape/utils/index.js
new file mode 100644
index 0000000..82c5415
--- /dev/null
+++ b/node_modules/gg-editor/es/shape/utils/index.js
@@ -0,0 +1,122 @@
+function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+var canvas = document.createElement('canvas');
+var canvasContext = canvas.getContext('2d');
+export function getNodeSide(item) {
+  var model = item.getModel();
+
+  if (model.side) {
+    return model.side;
+  }
+
+  var parent = item.get('parent');
+
+  if (parent) {
+    return getNodeSide(parent);
+  }
+
+  return 'right';
+}
+export function getRectPath(x, y, w, h, r) {
+  if (r) {
+    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
+  }
+
+  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
+  res.toString = toString;
+  return res;
+}
+export function getFoldButtonPath() {
+  var w = 14;
+  var h = 14;
+  var rect = getRectPath(0, 0, w, h, 2);
+  var hp = "M".concat(w * 3 / 14, ",").concat(h / 2, "L").concat(w * 11 / 14, ",").concat(h / 2);
+  var vp = '';
+  return rect + hp + vp;
+}
+export function getUnfoldButtonPath() {
+  var w = 14;
+  var h = 14;
+  var rect = getRectPath(0, 0, w, h, 2);
+  var hp = "M".concat(w * 3 / 14, ",").concat(h / 2, "L").concat(w * 11 / 14, ",").concat(h / 2);
+  var vp = "M".concat(w / 2, ",").concat(h * 3 / 14, "L").concat(w / 2, ",").concat(h * 11 / 14);
+  return rect + hp + vp;
+}
+export function optimizeMultilineText(text, font, maxRows, maxWidth) {
+  canvasContext.font = font;
+
+  if (canvasContext.measureText(text).width <= maxWidth) {
+    return text;
+  }
+
+  var multilineText = [];
+  var tempText = '';
+  var tempTextWidth = 0;
+
+  var _iterator = _createForOfIteratorHelper(text),
+      _step;
+
+  try {
+    for (_iterator.s(); !(_step = _iterator.n()).done;) {
+      var _char2 = _step.value;
+
+      var _canvasContext$measur2 = canvasContext.measureText(_char2),
+          _width = _canvasContext$measur2.width;
+
+      if (tempTextWidth + _width >= maxWidth) {
+        multilineText.push(tempText);
+        tempText = '';
+        tempTextWidth = 0;
+      }
+
+      tempText += _char2;
+      tempTextWidth += _width;
+    }
+  } catch (err) {
+    _iterator.e(err);
+  } finally {
+    _iterator.f();
+  }
+
+  if (tempText) {
+    multilineText.push(tempText);
+  }
+
+  if (multilineText.length > maxRows) {
+    var ellipsis = '...';
+    var ellipsisWidth = canvasContext.measureText(ellipsis).width;
+    var _tempText = '';
+    var _tempTextWidth = 0;
+
+    var _iterator2 = _createForOfIteratorHelper(multilineText[maxRows - 1]),
+        _step2;
+
+    try {
+      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
+        var _char = _step2.value;
+
+        var _canvasContext$measur = canvasContext.measureText(_char),
+            width = _canvasContext$measur.width;
+
+        if (_tempTextWidth + width > maxWidth - ellipsisWidth) {
+          break;
+        }
+
+        _tempText += _char;
+        _tempTextWidth += width;
+      }
+    } catch (err) {
+      _iterator2.e(err);
+    } finally {
+      _iterator2.f();
+    }
+
+    multilineText = multilineText.slice(0, maxRows - 1).concat("".concat(_tempText).concat(ellipsis));
+  }
+
+  return multilineText.join('\n');
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/es/utils/index.d.ts b/node_modules/gg-editor/es/utils/index.d.ts
new file mode 100644
index 0000000..6096c56
--- /dev/null
+++ b/node_modules/gg-editor/es/utils/index.d.ts
@@ -0,0 +1,34 @@
+import { GraphState } from '../../es/common/constants';
+import { Graph, TreeGraph, Item, Node, Edge } from '../../es/common/interfaces';
+/** 生成唯一标识 */
+export declare function guid(): string;
+/** 拼接查询字符 */
+export declare const toQueryString: (obj: object) => string;
+/** 执行批量处理 */
+export declare function executeBatch(graph: Graph, execute: Function): void;
+/** 执行递归遍历 */
+export declare function recursiveTraversal(root: any, callback: any): void;
+/** 判断是否流程图 */
+export declare function isFlow(graph: Graph): boolean;
+/** 判断是否脑图 */
+export declare function isMind(graph: Graph): boolean;
+/** 判断是否节点 */
+export declare function isNode(item: Item): boolean;
+/** 判断是否边线 */
+export declare function isEdge(item: Item): boolean;
+/** 获取选中节点 */
+export declare function getSelectedNodes(graph: Graph): Node[];
+/** 获取选中边线 */
+export declare function getSelectedEdges(graph: Graph): Edge[];
+/** 获取高亮边线 */
+export declare function getHighlightEdges(graph: Graph): Edge[];
+/** 获取图表状态 */
+export declare function getGraphState(graph: Graph): GraphState;
+/** 设置选中元素 */
+export declare function setSelectedItems(graph: Graph, items: Item[] | string[]): void;
+/** 清除选中状态 */
+export declare function clearSelectedState(graph: Graph, shouldUpdate?: (item: Item) => boolean): void;
+/** 获取回溯路径 - Flow */
+export declare function getFlowRecallEdges(graph: Graph, node: Node, targetIds?: string[], edges?: Edge[]): Edge[];
+/** 获取回溯路径 - Mind */
+export declare function getMindRecallEdges(graph: TreeGraph, node: Node, edges?: Edge[]): any;
diff --git a/node_modules/gg-editor/es/utils/index.js b/node_modules/gg-editor/es/utils/index.js
new file mode 100644
index 0000000..fbb7e87
--- /dev/null
+++ b/node_modules/gg-editor/es/utils/index.js
@@ -0,0 +1,188 @@
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+import G6 from '@antv/g6';
+import { ItemType, ItemState, GraphState, EditorEvent } from '../../es/common/constants';
+/** 生成唯一标识 */
+
+export function guid() {
+  return 'xxxxxxxx'.replace(/[xy]/g, function (c) {
+    var r = Math.random() * 16 | 0;
+    var v = c === 'x' ? r : r & 0x3 | 0x8;
+    return v.toString(16);
+  });
+}
+/** 拼接查询字符 */
+
+export var toQueryString = function toQueryString(obj) {
+  return Object.keys(obj).map(function (key) {
+    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(obj[key]));
+  }).join('&');
+};
+/** 执行批量处理 */
+
+export function executeBatch(graph, execute) {
+  var autoPaint = graph.get('autoPaint');
+  graph.setAutoPaint(false);
+  execute();
+  graph.paint();
+  graph.setAutoPaint(autoPaint);
+}
+/** 执行递归遍历 */
+
+export function recursiveTraversal(root, callback) {
+  if (!root) {
+    return;
+  }
+
+  callback(root);
+
+  if (!root.children) {
+    return;
+  }
+
+  root.children.forEach(function (item) {
+    return recursiveTraversal(item, callback);
+  });
+}
+/** 判断是否流程图 */
+
+export function isFlow(graph) {
+  return graph.constructor === G6.Graph;
+}
+/** 判断是否脑图 */
+
+export function isMind(graph) {
+  return graph.constructor === G6.TreeGraph;
+}
+/** 判断是否节点 */
+
+export function isNode(item) {
+  return item.getType() === ItemType.Node;
+}
+/** 判断是否边线 */
+
+export function isEdge(item) {
+  return item.getType() === ItemType.Edge;
+}
+/** 获取选中节点 */
+
+export function getSelectedNodes(graph) {
+  return graph.findAllByState(ItemType.Node, ItemState.Selected);
+}
+/** 获取选中边线 */
+
+export function getSelectedEdges(graph) {
+  return graph.findAllByState(ItemType.Edge, ItemState.Selected);
+}
+/** 获取高亮边线 */
+
+export function getHighlightEdges(graph) {
+  return graph.findAllByState(ItemType.Edge, ItemState.HighLight);
+}
+/** 获取图表状态 */
+
+export function getGraphState(graph) {
+  var graphState = GraphState.MultiSelected;
+  var selectedNodes = getSelectedNodes(graph);
+  var selectedEdges = getSelectedEdges(graph);
+
+  if (selectedNodes.length === 1 && !selectedEdges.length) {
+    graphState = GraphState.NodeSelected;
+  }
+
+  if (selectedEdges.length === 1 && !selectedNodes.length) {
+    graphState = GraphState.EdgeSelected;
+  }
+
+  if (!selectedNodes.length && !selectedEdges.length) {
+    graphState = GraphState.CanvasSelected;
+  }
+
+  return graphState;
+}
+/** 设置选中元素 */
+
+export function setSelectedItems(graph, items) {
+  executeBatch(graph, function () {
+    var selectedNodes = getSelectedNodes(graph);
+    var selectedEdges = getSelectedEdges(graph);
+    [].concat(_toConsumableArray(selectedNodes), _toConsumableArray(selectedEdges)).forEach(function (node) {
+      graph.setItemState(node, ItemState.Selected, false);
+    });
+    items.forEach(function (item) {
+      graph.setItemState(item, ItemState.Selected, true);
+    });
+  });
+  graph.emit(EditorEvent.onGraphStateChange, {
+    graphState: getGraphState(graph)
+  });
+}
+/** 清除选中状态 */
+
+export function clearSelectedState(graph) {
+  var shouldUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
+    return true;
+  };
+  var selectedNodes = getSelectedNodes(graph);
+  var selectedEdges = getSelectedEdges(graph);
+  executeBatch(graph, function () {
+    [].concat(_toConsumableArray(selectedNodes), _toConsumableArray(selectedEdges)).forEach(function (item) {
+      if (shouldUpdate(item)) {
+        graph.setItemState(item, ItemState.Selected, false);
+      }
+    });
+  });
+}
+/** 获取回溯路径 - Flow */
+
+export function getFlowRecallEdges(graph, node) {
+  var targetIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  var edges = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
+  var inEdges = node.getInEdges();
+
+  if (!inEdges.length) {
+    return [];
+  }
+
+  inEdges.map(function (edge) {
+    var sourceId = edge.getModel().source;
+    var sourceNode = graph.findById(sourceId);
+    edges.push(edge);
+    var targetId = node.get('id');
+    targetIds.push(targetId);
+
+    if (!targetIds.includes(sourceId)) {
+      getFlowRecallEdges(graph, sourceNode, targetIds, edges);
+    }
+  });
+  return edges;
+}
+/** 获取回溯路径 - Mind */
+
+export function getMindRecallEdges(graph, node) {
+  var edges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  var parentNode = node.get('parent');
+
+  if (!parentNode) {
+    return edges;
+  }
+
+  node.getEdges().forEach(function (edge) {
+    var sourceId = edge.getModel().source;
+
+    if (sourceId === parentNode.get('id')) {
+      edges.push(edge);
+    }
+  });
+  return getMindRecallEdges(graph, parentNode, edges);
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/common/CommandManager/index.js b/node_modules/gg-editor/lib/common/CommandManager/index.js
new file mode 100644
index 0000000..d80d885
--- /dev/null
+++ b/node_modules/gg-editor/lib/common/CommandManager/index.js
@@ -0,0 +1,114 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));
+
+var _utils = require("../../utils");
+
+var _constants = require("../constants");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+var CommandManager = /*#__PURE__*/function () {
+  function CommandManager() {
+    _classCallCheck(this, CommandManager);
+
+    this.command = {};
+    this.commandQueue = [];
+    this.commandIndex = 0;
+  }
+  /** 注册命令 */
+
+
+  _createClass(CommandManager, [{
+    key: "register",
+    value: function register(name, command) {
+      this.command[name] = _objectSpread(_objectSpread({}, command), {}, {
+        name: name
+      });
+    }
+    /** 执行命令 */
+
+  }, {
+    key: "execute",
+    value: function execute(graph, name, params) {
+      var Command = this.command[name];
+
+      if (!Command) {
+        return;
+      }
+
+      var command = Object.create(Command);
+      command.params = (0, _cloneDeep["default"])(Command.params);
+
+      if (params) {
+        command.params = _objectSpread(_objectSpread({}, command.params), params);
+      }
+
+      if (!command.canExecute(graph)) {
+        return;
+      }
+
+      if (!command.shouldExecute(graph)) {
+        return;
+      }
+
+      command.init(graph);
+      graph.emit(_constants.EditorEvent.onBeforeExecuteCommand, {
+        name: command.name,
+        params: command.params
+      });
+      command.execute(graph);
+      graph.emit(_constants.EditorEvent.onAfterExecuteCommand, {
+        name: command.name,
+        params: command.params
+      });
+
+      if (command.canUndo(graph)) {
+        var commandQueue = this.commandQueue,
+            commandIndex = this.commandIndex;
+        commandQueue.splice(commandIndex, commandQueue.length - commandIndex, command);
+        this.commandIndex += 1;
+      }
+
+      graph.emit(_constants.EditorEvent.onGraphStateChange, {
+        graphState: (0, _utils.getGraphState)(graph)
+      });
+    }
+    /** 判断是否可以执行 */
+
+  }, {
+    key: "canExecute",
+    value: function canExecute(graph, name) {
+      return this.command[name].canExecute(graph);
+    }
+    /** 注入是否应该执行 */
+
+  }, {
+    key: "injectShouldExecute",
+    value: function injectShouldExecute(name, shouldExecute) {
+      this.command[name].shouldExecute = shouldExecute;
+    }
+  }]);
+
+  return CommandManager;
+}();
+
+var _default = CommandManager;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/common/behaviorManager/index.js b/node_modules/gg-editor/lib/common/behaviorManager/index.js
new file mode 100644
index 0000000..b818bc5
--- /dev/null
+++ b/node_modules/gg-editor/lib/common/behaviorManager/index.js
@@ -0,0 +1,106 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _utils = require("../../utils");
+
+var _constants = require("../constants");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+var BehaviorManager = /*#__PURE__*/function () {
+  function BehaviorManager() {
+    _classCallCheck(this, BehaviorManager);
+
+    this.behaviors = {};
+  }
+
+  _createClass(BehaviorManager, [{
+    key: "getRegisteredBehaviors",
+    value: function getRegisteredBehaviors(type) {
+      var _this = this;
+
+      var registeredBehaviors = {};
+      Object.keys(this.behaviors).forEach(function (name) {
+        var behavior = _this.behaviors[name];
+        var graphType = behavior.graphType;
+
+        if (graphType && graphType !== type) {
+          return;
+        }
+
+        var _behavior$graphMode = behavior.graphMode,
+            graphMode = _behavior$graphMode === void 0 ? 'default' : _behavior$graphMode;
+
+        if (!registeredBehaviors[graphMode]) {
+          registeredBehaviors[graphMode] = {};
+        }
+
+        registeredBehaviors[graphMode][name] = name;
+      });
+      return registeredBehaviors;
+    }
+  }, {
+    key: "wrapEventHandler",
+    value: function wrapEventHandler(type, behavior) {
+      var events = behavior.getEvents();
+      Object.keys(events).forEach(function (event) {
+        var handlerName = events[event];
+        var handler = behavior[handlerName];
+
+        behavior[handlerName] = function () {
+          var graph = this.graph;
+
+          if (type === _constants.GraphType.Flow && (0, _utils.isMind)(graph) === false || type === _constants.GraphType.Mind && (0, _utils.isMind)(graph)) {
+            for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
+              params[_key] = arguments[_key];
+            }
+
+            handler.apply(this, params);
+          }
+        };
+      });
+      return behavior;
+    }
+  }, {
+    key: "register",
+    value: function register(name, behavior) {
+      var graphType = behavior.graphType;
+      this.behaviors[name] = behavior;
+
+      switch (graphType) {
+        case _constants.GraphType.Flow:
+          _g["default"].registerBehavior(name, this.wrapEventHandler(_constants.GraphType.Flow, behavior));
+
+          break;
+
+        case _constants.GraphType.Mind:
+          _g["default"].registerBehavior(name, this.wrapEventHandler(_constants.GraphType.Mind, behavior));
+
+          break;
+
+        default:
+          _g["default"].registerBehavior(name, behavior);
+
+          break;
+      }
+    }
+  }]);
+
+  return BehaviorManager;
+}();
+
+var _default = new BehaviorManager();
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/common/constants/index.js b/node_modules/gg-editor/lib/common/constants/index.js
new file mode 100644
index 0000000..89e3c64
--- /dev/null
+++ b/node_modules/gg-editor/lib/common/constants/index.js
@@ -0,0 +1,410 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.GraphCustomEvent = exports.GraphCanvasEvent = exports.GraphEdgeEvent = exports.GraphNodeEvent = exports.GraphCommonEvent = exports.EditorCommand = exports.EditorEvent = exports.AnchorPointState = exports.LabelState = exports.GraphState = exports.GraphMode = exports.GraphType = exports.ItemState = exports.ItemType = exports.RendererType = exports.LABEL_DEFAULT_TEXT = exports.MIND_CONTAINER_ID = exports.FLOW_CONTAINER_ID = void 0;
+var FLOW_CONTAINER_ID = 'J_FlowContainer';
+exports.FLOW_CONTAINER_ID = FLOW_CONTAINER_ID;
+var MIND_CONTAINER_ID = 'J_MindContainer';
+exports.MIND_CONTAINER_ID = MIND_CONTAINER_ID;
+var LABEL_DEFAULT_TEXT = '新建节点';
+exports.LABEL_DEFAULT_TEXT = LABEL_DEFAULT_TEXT;
+var RendererType;
+exports.RendererType = RendererType;
+
+(function (RendererType) {
+  RendererType["Canvas"] = "canvas";
+  RendererType["Svg"] = "svg";
+})(RendererType || (exports.RendererType = RendererType = {}));
+
+var ItemType;
+exports.ItemType = ItemType;
+
+(function (ItemType) {
+  ItemType["Node"] = "node";
+  ItemType["Edge"] = "edge";
+})(ItemType || (exports.ItemType = ItemType = {}));
+
+var ItemState;
+exports.ItemState = ItemState;
+
+(function (ItemState) {
+  ItemState["Active"] = "active";
+  ItemState["ActiveAnchorPoints"] = "activeAnchorPoints";
+  ItemState["Selected"] = "selected";
+  ItemState["HighLight"] = "highLight";
+  ItemState["Error"] = "error";
+})(ItemState || (exports.ItemState = ItemState = {}));
+
+var GraphType;
+exports.GraphType = GraphType;
+
+(function (GraphType) {
+  GraphType["Flow"] = "flow";
+  GraphType["Mind"] = "mind";
+})(GraphType || (exports.GraphType = GraphType = {}));
+
+var GraphMode;
+exports.GraphMode = GraphMode;
+
+(function (GraphMode) {
+  GraphMode["Default"] = "default";
+  GraphMode["AddNode"] = "addNode";
+  GraphMode["Readonly"] = "readonly";
+})(GraphMode || (exports.GraphMode = GraphMode = {}));
+
+var GraphState;
+exports.GraphState = GraphState;
+
+(function (GraphState) {
+  GraphState["NodeSelected"] = "nodeSelected";
+  GraphState["EdgeSelected"] = "edgeSelected";
+  GraphState["MultiSelected"] = "multiSelected";
+  GraphState["CanvasSelected"] = "canvasSelected";
+})(GraphState || (exports.GraphState = GraphState = {}));
+
+var LabelState;
+exports.LabelState = LabelState;
+
+(function (LabelState) {
+  LabelState["Hide"] = "hide";
+  LabelState["Show"] = "show";
+})(LabelState || (exports.LabelState = LabelState = {}));
+
+var AnchorPointState;
+exports.AnchorPointState = AnchorPointState;
+
+(function (AnchorPointState) {
+  AnchorPointState["Enabled"] = "enabled";
+  AnchorPointState["Disabled"] = "disabled";
+})(AnchorPointState || (exports.AnchorPointState = AnchorPointState = {}));
+
+var EditorEvent;
+exports.EditorEvent = EditorEvent;
+
+(function (EditorEvent) {
+  /** 调用命令之前触发 */
+  EditorEvent["onBeforeExecuteCommand"] = "onBeforeExecuteCommand";
+  /** 调用命令之后触发 */
+
+  EditorEvent["onAfterExecuteCommand"] = "onAfterExecuteCommand";
+  /** 改变画面状态触发 */
+
+  EditorEvent["onGraphStateChange"] = "onGraphStateChange";
+  /** 改变标签状态触发 */
+
+  EditorEvent["onLabelStateChange"] = "onLabelStateChange";
+})(EditorEvent || (exports.EditorEvent = EditorEvent = {}));
+
+var EditorCommand;
+exports.EditorCommand = EditorCommand;
+
+(function (EditorCommand) {
+  /** 撤销 */
+  EditorCommand["Undo"] = "undo";
+  /** 重做 */
+
+  EditorCommand["Redo"] = "redo";
+  /** 添加 */
+
+  EditorCommand["Add"] = "add";
+  /** 更新 */
+
+  EditorCommand["Update"] = "update";
+  /** 删除 */
+
+  EditorCommand["Remove"] = "remove";
+  /** 复制 */
+
+  EditorCommand["Copy"] = "copy";
+  /** 粘贴 */
+
+  EditorCommand["Paste"] = "paste";
+  /** 粘贴到这里 */
+
+  EditorCommand["PasteHere"] = "pasteHere";
+  /** 放大 */
+
+  EditorCommand["ZoomIn"] = "zoomIn";
+  /** 缩小 */
+
+  EditorCommand["ZoomOut"] = "zoomOut";
+  /** 插入主题 */
+
+  EditorCommand["Topic"] = "topic";
+  /** 插入子主题 */
+
+  EditorCommand["Subtopic"] = "subtopic";
+  /** 收起 */
+
+  EditorCommand["Fold"] = "fold";
+  /** 展开 */
+
+  EditorCommand["Unfold"] = "unfold";
+})(EditorCommand || (exports.EditorCommand = EditorCommand = {}));
+
+var GraphCommonEvent;
+exports.GraphCommonEvent = GraphCommonEvent;
+
+(function (GraphCommonEvent) {
+  /** 单击鼠标左键或者按下回车键时触发 */
+  GraphCommonEvent["onClick"] = "click";
+  /** 双击鼠标左键时触发 */
+
+  GraphCommonEvent["onDoubleClick"] = "dblclick";
+  /** 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 */
+
+  GraphCommonEvent["onMouseEnter"] = "mouseenter";
+  /** 鼠标在元素内部移到时不断触发，不能通过键盘触发 */
+
+  GraphCommonEvent["onMouseMove"] = "mousemove";
+  /** 鼠标移出目标元素后触发 */
+
+  GraphCommonEvent["onMouseOut"] = "mouseout";
+  /** 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 */
+
+  GraphCommonEvent["onMouseOver"] = "mouseover";
+  /** 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 */
+
+  GraphCommonEvent["onMouseLeave"] = "mouseleave";
+  /** 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphCommonEvent["onMouseDown"] = "mousedown";
+  /** 鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphCommonEvent["onMouseUp"] = "mouseup";
+  /** 用户右击鼠标时触发并打开上下文菜单 */
+
+  GraphCommonEvent["onContextMenu"] = "contextmenu";
+  /** 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 */
+
+  GraphCommonEvent["onDragStart"] = "dragstart";
+  /** 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 */
+
+  GraphCommonEvent["onDrag"] = "drag";
+  /** 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 */
+
+  GraphCommonEvent["onDragEnd"] = "dragend";
+  /** 当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCommonEvent["onDragEnter"] = "dragenter";
+  /** 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCommonEvent["onDragLeave"] = "dragleave";
+  /** 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
+
+  GraphCommonEvent["onDrop"] = "drop";
+  /** 按下键盘键触发该事件 */
+
+  GraphCommonEvent["onKeyDown"] = "keydown";
+  /** 释放键盘键触发该事件 */
+
+  GraphCommonEvent["onKeyUp"] = "keyup";
+  /** 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 */
+
+  GraphCommonEvent["onTouchStart"] = "touchstart";
+  /** 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault() 事件可以阻止滚动。 */
+
+  GraphCommonEvent["onTouchMove"] = "touchmove";
+  /** 当手指从屏幕上离开的时候触发 */
+
+  GraphCommonEvent["onTouchEnd"] = "touchend";
+})(GraphCommonEvent || (exports.GraphCommonEvent = GraphCommonEvent = {}));
+
+var GraphNodeEvent;
+exports.GraphNodeEvent = GraphNodeEvent;
+
+(function (GraphNodeEvent) {
+  /** 鼠标左键单击节点时触发 */
+  GraphNodeEvent["onNodeClick"] = "node:click";
+  /** 鼠标双击左键节点时触发 */
+
+  GraphNodeEvent["onNodeDoubleClick"] = "node:dblclick";
+  /** 鼠标移入节点时触发 */
+
+  GraphNodeEvent["onNodeMouseEnter"] = "node:mouseenter";
+  /** 鼠标在节点内部移到时不断触发，不能通过键盘触发 */
+
+  GraphNodeEvent["onNodeMouseMove"] = "node:mousemove";
+  /** 鼠标移出节点后触发 */
+
+  GraphNodeEvent["onNodeMouseOut"] = "node:mouseout";
+  /** 鼠标移入节点上方时触发 */
+
+  GraphNodeEvent["onNodeMouseOver"] = "node:mouseover";
+  /** 鼠标移出节点时触发 */
+
+  GraphNodeEvent["onNodeMouseLeave"] = "node:mouseleave";
+  /** 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphNodeEvent["onNodeMouseDown"] = "node:mousedown";
+  /** 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphNodeEvent["onNodeMouseUp"] = "node:mouseup";
+  /** 用户在节点上右击鼠标时触发并打开右键菜单 */
+
+  GraphNodeEvent["onNodeContextMenu"] = "node:contextmenu";
+  /** 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 */
+
+  GraphNodeEvent["onNodeDragStart"] = "node:dragstart";
+  /** 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 */
+
+  GraphNodeEvent["onNodeDrag"] = "node:drag";
+  /** 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 */
+
+  GraphNodeEvent["onNodeDragEnd"] = "node:dragend";
+  /** 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphNodeEvent["onNodeDragEnter"] = "node:dragenter";
+  /** 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphNodeEvent["onNodeDragLeave"] = "node:dragleave";
+  /** 被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
+
+  GraphNodeEvent["onNodeDrop"] = "node:drop";
+})(GraphNodeEvent || (exports.GraphNodeEvent = GraphNodeEvent = {}));
+
+var GraphEdgeEvent;
+exports.GraphEdgeEvent = GraphEdgeEvent;
+
+(function (GraphEdgeEvent) {
+  /** 鼠标左键单击边时触发 */
+  GraphEdgeEvent["onEdgeClick"] = "edge:click";
+  /** 鼠标双击左键边时触发 */
+
+  GraphEdgeEvent["onEdgeDoubleClick"] = "edge:dblclick";
+  /** 鼠标移入边时触发 */
+
+  GraphEdgeEvent["onEdgeMouseEnter"] = "edge:mouseenter";
+  /** 鼠标在边上移到时不断触发，不能通过键盘触发 */
+
+  GraphEdgeEvent["onEdgeMouseMove"] = "edge:mousemove";
+  /** 鼠标移出边后触发 */
+
+  GraphEdgeEvent["onEdgeMouseOut"] = "edge:mouseout";
+  /** 鼠标移入边上方时触发 */
+
+  GraphEdgeEvent["onEdgeMouseOver"] = "edge:mouseover";
+  /** 鼠标移出边时触发 */
+
+  GraphEdgeEvent["onEdgeMouseLeave"] = "edge:mouseleave";
+  /** 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphEdgeEvent["onEdgeMouseDown"] = "edge:mousedown";
+  /** 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphEdgeEvent["onEdgeMouseUp"] = "edge:mouseup";
+  /** 用户在边上右击鼠标时触发并打开右键菜单 */
+
+  GraphEdgeEvent["onEdgeContextMenu"] = "edge:contextmenu";
+})(GraphEdgeEvent || (exports.GraphEdgeEvent = GraphEdgeEvent = {}));
+
+var GraphCanvasEvent;
+exports.GraphCanvasEvent = GraphCanvasEvent;
+
+(function (GraphCanvasEvent) {
+  /** 鼠标左键单击画布时触发 */
+  GraphCanvasEvent["onCanvasClick"] = "canvas:click";
+  /** 鼠标双击左键画布时触发 */
+
+  GraphCanvasEvent["onCanvasDoubleClick"] = "canvas:dblclick";
+  /** 鼠标移入画布时触发 */
+
+  GraphCanvasEvent["onCanvasMouseEnter"] = "canvas:mouseenter";
+  /** 鼠标在画布内部移到时不断触发，不能通过键盘触发 */
+
+  GraphCanvasEvent["onCanvasMouseMove"] = "canvas:mousemove";
+  /** 鼠标移出画布后触发 */
+
+  GraphCanvasEvent["onCanvasMouseOut"] = "canvas:mouseout";
+  /** 鼠标移入画布上方时触发 */
+
+  GraphCanvasEvent["onCanvasMouseOver"] = "canvas:mouseover";
+  /** 鼠标移出画布时触发 */
+
+  GraphCanvasEvent["onCanvasMouseLeave"] = "canvas:mouseleave";
+  /** 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 */
+
+  GraphCanvasEvent["onCanvasMouseDown"] = "canvas:mousedown";
+  /** 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
+
+  GraphCanvasEvent["onCanvasMouseUp"] = "canvas:mouseup";
+  /** 用户在画布上右击鼠标时触发并打开右键菜单 */
+
+  GraphCanvasEvent["onCanvasContextMenu"] = "canvas:contextmenu";
+  /** 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 */
+
+  GraphCanvasEvent["onCanvasDragStart"] = "canvas:dragstart";
+  /** 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 */
+
+  GraphCanvasEvent["onCanvasDrag"] = "canvas:drag";
+  /** 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 */
+
+  GraphCanvasEvent["onCanvasDragEnd"] = "canvas:dragend";
+  /** 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCanvasEvent["onCanvasDragEnter"] = "canvas:dragenter";
+  /** 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标元素上 */
+
+  GraphCanvasEvent["onCanvasDragLeave"] = "canvas:dragleave";
+})(GraphCanvasEvent || (exports.GraphCanvasEvent = GraphCanvasEvent = {}));
+
+var GraphCustomEvent;
+exports.GraphCustomEvent = GraphCustomEvent;
+
+(function (GraphCustomEvent) {
+  /** 调用 add / addItem 方法之前触发 */
+  GraphCustomEvent["onBeforeAddItem"] = "beforeadditem";
+  /** 调用 add / addItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterAddItem"] = "afteradditem";
+  /** 调用 remove / removeItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeRemoveItem"] = "beforeremoveitem";
+  /** 调用 remove / removeItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterRemoveItem"] = "afterremoveitem";
+  /** 调用 update / updateItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeUpdateItem"] = "beforeupdateitem";
+  /** 调用 update / updateItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterUpdateItem"] = "afterupdateitem";
+  /** 调用 showItem / hideItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeItemVisibilityChange"] = "beforeitemvisibilitychange";
+  /** 调用 showItem / hideItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterItemVisibilityChange"] = "afteritemvisibilitychange";
+  /** 调用 setItemState 方法之前触发 */
+
+  GraphCustomEvent["onBeforeItemStateChange"] = "beforeitemstatechange";
+  /** 调用 setItemState 方法之后触发 */
+
+  GraphCustomEvent["onAfterItemStateChange"] = "afteritemstatechange";
+  /** 调用 refreshItem 方法之前触发 */
+
+  GraphCustomEvent["onBeforeRefreshItem"] = "beforerefreshitem";
+  /** 调用 refreshItem 方法之后触发 */
+
+  GraphCustomEvent["onAfterRefreshItem"] = "afterrefreshitem";
+  /** 调用 clearItemStates 方法之前触发 */
+
+  GraphCustomEvent["onBeforeItemStatesClear"] = "beforeitemstatesclear";
+  /** 调用 clearItemStates 方法之后触发 */
+
+  GraphCustomEvent["onAfterItemStatesClear"] = "afteritemstatesclear";
+  /** 布局前触发。调用 render 时会进行布局，因此 render 时会触发。或用户主动调用图的 layout 时触发 */
+
+  GraphCustomEvent["onBeforeLayout"] = "beforelayout";
+  /** 布局完成后触发。调用 render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 layout 时布局完成后触发 */
+
+  GraphCustomEvent["onAfterLayout"] = "afterlayout";
+  /** 连线完成之前触发 */
+
+  GraphCustomEvent["onBeforeConnect"] = "beforeconnect";
+  /** 连线完成之后触发 */
+
+  GraphCustomEvent["onAfterConnect"] = "afterconnect";
+})(GraphCustomEvent || (exports.GraphCustomEvent = GraphCustomEvent = {}));
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/common/global/index.js b/node_modules/gg-editor/lib/common/global/index.js
new file mode 100644
index 0000000..91ce4bb
--- /dev/null
+++ b/node_modules/gg-editor/lib/common/global/index.js
@@ -0,0 +1,54 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _utils = require("../../utils");
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+var Global = function Global() {
+  _classCallCheck(this, Global);
+
+  /** 当前版本 */
+  this.version = process.env.GG_EDITOR_VERSION;
+  /** 埋点开关 */
+
+  this.trackable = true;
+  /** 剪贴板 */
+
+  this.clipboard = {
+    point: {
+      x: 0,
+      y: 0
+    },
+    models: []
+  };
+  /** 组件数据 */
+
+  this.component = {
+    itemPanel: {
+      model: null,
+      delegateShapeClassName: "delegateShape_".concat((0, _utils.guid)())
+    }
+  };
+  /** 插件数据 */
+
+  this.plugin = {
+    itemPopover: {
+      state: 'hide'
+    },
+    contextMenu: {
+      state: 'hide'
+    },
+    editableLabel: {
+      state: 'hide'
+    }
+  };
+};
+
+var _default = new Global();
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/common/interfaces/index.d.ts b/node_modules/gg-editor/lib/common/interfaces/index.d.ts
index 82e2a06..b545ecc 100644
--- a/node_modules/gg-editor/lib/common/interfaces/index.d.ts
+++ b/node_modules/gg-editor/lib/common/interfaces/index.d.ts
@@ -3,7 +3,7 @@ import IGGroup from '@antv/g-canvas/lib/group';
 import { IShape as IGShape } from '@antv/g-canvas/lib/interfaces';
 import { Graph as IGraph, TreeGraph as ITreeGraph } from '@antv/g6';
 import { IPoint, ShapeStyle as IShapeStyle, GraphData as IGraphData, TreeGraphData as ITreeGraphData, NodeConfig as INodeConfig, EdgeConfig as IEdgeConfig, BehaviorOption as IBehaviorOption, IG6GraphEvent as IGraphEvent } from '@antv/g6/lib/types';
-import { GraphOptions as IGraphOptions } from '@antv/g6/lib/interface/graph';
+import { GraphOptions as IGraphOptions } from '@antv/g6/lib/types';
 import { ShapeOptions as IShapeOptions } from '@antv/g6/lib/interface/shape';
 import { INode, IEdge } from '@antv/g6/lib/interface/item';
 export interface GShape extends IGShape {
diff --git a/node_modules/gg-editor/lib/common/interfaces/index.js b/node_modules/gg-editor/lib/common/interfaces/index.js
new file mode 100644
index 0000000..9a390c3
--- /dev/null
+++ b/node_modules/gg-editor/lib/common/interfaces/index.js
@@ -0,0 +1 @@
+"use strict";
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/common/withContext/index.d.ts b/node_modules/gg-editor/lib/common/withContext/index.d.ts
index c15c4b2..d882cd8 100644
--- a/node_modules/gg-editor/lib/common/withContext/index.d.ts
+++ b/node_modules/gg-editor/lib/common/withContext/index.d.ts
@@ -1,2 +1,2 @@
 import React from 'react';
-export default function <CP>(Context: React.Context<CP>, shouldRender?: (context: CP) => boolean): <P extends CP, T = unknown>(WrappedComponent: React.ComponentType<P>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<Pick<React.PropsWithChildren<P>, Exclude<keyof P, keyof CP> | Exclude<"children", keyof CP>>> & React.RefAttributes<T>>;
+export default function <CP>(Context: React.Context<CP>, shouldRender?: (context: CP) => boolean): <P extends CP, T = unknown>(WrappedComponent: React.ComponentType<P>) => React.ForwardRefExoticComponent<React.PropsWithoutRef<Pick<React.PropsWithChildren<P>, Exclude<"children", keyof CP> | Exclude<keyof P, keyof CP>>> & React.RefAttributes<T>>;
diff --git a/node_modules/gg-editor/lib/common/withContext/index.js b/node_modules/gg-editor/lib/common/withContext/index.js
new file mode 100644
index 0000000..f745bf6
--- /dev/null
+++ b/node_modules/gg-editor/lib/common/withContext/index.js
@@ -0,0 +1,48 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = _default;
+
+var _react = _interopRequireDefault(require("react"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
+
+function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
+
+function _default(Context) {
+  var shouldRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
+    return true;
+  };
+  return function (WrappedComponent) {
+    var InjectContext = function InjectContext(props) {
+      var forwardRef = props.forwardRef,
+          rest = _objectWithoutProperties(props, ["forwardRef"]);
+
+      var refProp = {};
+
+      if (WrappedComponent.prototype.isReactComponent) {
+        refProp = {
+          ref: forwardRef
+        };
+      } else {
+        refProp = {
+          forwardRef: forwardRef
+        };
+      }
+
+      return /*#__PURE__*/_react["default"].createElement(Context.Consumer, null, function (context) {
+        return shouldRender(context) ? /*#__PURE__*/_react["default"].createElement(WrappedComponent, Object.assign({}, refProp, rest, context)) : null;
+      });
+    };
+
+    return /*#__PURE__*/_react["default"].forwardRef(function (props, ref) {
+      return /*#__PURE__*/_react["default"].createElement(InjectContext, Object.assign({
+        forwardRef: ref
+      }, props));
+    });
+  };
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Command/index.d.ts b/node_modules/gg-editor/lib/components/Command/index.d.ts
index beacb9c..81f827d 100644
--- a/node_modules/gg-editor/lib/components/Command/index.d.ts
+++ b/node_modules/gg-editor/lib/components/Command/index.d.ts
@@ -5,5 +5,5 @@ interface CommandProps extends EditorContextProps {
     className?: string;
     disabledClassName?: string;
 }
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<CommandProps>, "name" | "className" | "disabledClassName" | "children"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<CommandProps>, "children" | "className" | "name" | "disabledClassName"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/components/Command/index.js b/node_modules/gg-editor/lib/components/Command/index.js
new file mode 100644
index 0000000..67a1ea3
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Command/index.js
@@ -0,0 +1,117 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var Command =
+/** @class */
+function () {
+  var Command = /*#__PURE__*/function (_React$Component) {
+    _inherits(Command, _React$Component);
+
+    var _super = _createSuper(Command);
+
+    function Command() {
+      var _this;
+
+      _classCallCheck(this, Command);
+
+      _this = _super.apply(this, arguments);
+      _this.state = {
+        disabled: false
+      };
+
+      _this.handleClick = function () {
+        var _this$props = _this.props,
+            name = _this$props.name,
+            executeCommand = _this$props.executeCommand;
+        executeCommand(name);
+      };
+
+      return _this;
+    }
+
+    _createClass(Command, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            name = _this$props2.name;
+        var commandManager = graph.get('commandManager');
+        this.setState({
+          disabled: !commandManager.canExecute(graph, name)
+        });
+        graph.on(_constants.EditorEvent.onGraphStateChange, function () {
+          _this2.setState({
+            disabled: !commandManager.canExecute(graph, name)
+          });
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var graph = this.props.graph;
+
+        if (!graph) {
+          return null;
+        }
+
+        var _this$props3 = this.props,
+            className = _this$props3.className,
+            disabledClassName = _this$props3.disabledClassName,
+            children = _this$props3.children;
+        var disabled = this.state.disabled;
+        return /*#__PURE__*/_react["default"].createElement("div", {
+          className: "".concat(className).concat(disabled ? " ".concat(disabledClassName) : ''),
+          onClick: this.handleClick
+        }, children);
+      }
+    }]);
+
+    return Command;
+  }(_react["default"].Component);
+
+  Command.defaultProps = {
+    className: 'command',
+    disabledClassName: 'command-disabled'
+  };
+  return Command;
+}();
+
+var _default = (0, _EditorContext.withEditorContext)(Command);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/DetailPanel/index.js b/node_modules/gg-editor/lib/components/DetailPanel/index.js
new file mode 100644
index 0000000..9b7a243
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/DetailPanel/index.js
@@ -0,0 +1,111 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _utils = require("../../utils");
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+var DetailPanel =
+/** @class */
+function () {
+  var DetailPanel = function DetailPanel() {
+    _classCallCheck(this, DetailPanel);
+  };
+
+  DetailPanel.create = function (type) {
+    return function (WrappedComponent) {
+      var TypedPanel = /*#__PURE__*/function (_React$Component) {
+        _inherits(TypedPanel, _React$Component);
+
+        var _super = _createSuper(TypedPanel);
+
+        function TypedPanel() {
+          var _this;
+
+          _classCallCheck(this, TypedPanel);
+
+          _this = _super.apply(this, arguments);
+          _this.state = {
+            graphState: _constants.GraphState.CanvasSelected
+          };
+          return _this;
+        }
+
+        _createClass(TypedPanel, [{
+          key: "componentDidMount",
+          value: function componentDidMount() {
+            var _this2 = this;
+
+            var graph = this.props.graph;
+            graph.on(_constants.EditorEvent.onGraphStateChange, function (_ref) {
+              var graphState = _ref.graphState;
+
+              _this2.setState({
+                graphState: graphState
+              });
+            });
+          }
+        }, {
+          key: "render",
+          value: function render() {
+            var graph = this.props.graph;
+            var graphState = this.state.graphState;
+
+            if (graphState !== "".concat(type, "Selected")) {
+              return null;
+            }
+
+            var nodes = (0, _utils.getSelectedNodes)(graph);
+            var edges = (0, _utils.getSelectedEdges)(graph);
+            return /*#__PURE__*/_react["default"].createElement(WrappedComponent, Object.assign({
+              type: type,
+              nodes: nodes,
+              edges: edges
+            }, this.props));
+          }
+        }]);
+
+        return TypedPanel;
+      }(_react["default"].Component);
+
+      return (0, _EditorContext.withEditorContext)(TypedPanel);
+    };
+  };
+
+  return DetailPanel;
+}();
+
+var _default = DetailPanel;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Editor/index.js b/node_modules/gg-editor/lib/components/Editor/index.js
new file mode 100644
index 0000000..f6f1b19
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Editor/index.js
@@ -0,0 +1,220 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _isArray = _interopRequireDefault(require("lodash/isArray"));
+
+var _pick = _interopRequireDefault(require("lodash/pick"));
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _CommandManager = _interopRequireDefault(require("../../common/CommandManager"));
+
+var _EditorContext = require("../EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var Editor =
+/** @class */
+function () {
+  var _Editor$defaultProps;
+
+  var Editor = /*#__PURE__*/function (_React$Component) {
+    _inherits(Editor, _React$Component);
+
+    var _super = _createSuper(Editor);
+
+    function Editor(props) {
+      var _this;
+
+      _classCallCheck(this, Editor);
+
+      _this = _super.call(this, props);
+      _this.lastMousedownTarget = null;
+
+      _this.setGraph = function (graph) {
+        _this.setState({
+          graph: graph
+        });
+
+        _this.bindEvent(graph);
+
+        _this.bindShortcut(graph);
+      };
+
+      _this.executeCommand = function (name, params) {
+        var _this$state = _this.state,
+            graph = _this$state.graph,
+            commandManager = _this$state.commandManager;
+
+        if (graph) {
+          commandManager.execute(graph, name, params);
+        }
+      };
+
+      _this.state = {
+        graph: null,
+        setGraph: _this.setGraph,
+        executeCommand: _this.executeCommand,
+        commandManager: new _CommandManager["default"]()
+      };
+      _this.lastMousedownTarget = null;
+      return _this;
+    }
+
+    _createClass(Editor, [{
+      key: "shouldTriggerShortcut",
+      value: function shouldTriggerShortcut(graph, target) {
+        var renderer = graph.get('renderer');
+        var canvasElement = graph.get('canvas').get('el');
+
+        if (!target) {
+          return false;
+        }
+
+        if (target === canvasElement) {
+          return true;
+        }
+
+        if (renderer === _constants.RendererType.Svg) {
+          if (target.nodeName === 'svg') {
+            return true;
+          }
+
+          var parentNode = target.parentNode;
+
+          while (parentNode && parentNode.nodeName !== 'BODY') {
+            if (parentNode.nodeName === 'svg') {
+              return true;
+            } else {
+              parentNode = parentNode.parentNode;
+            }
+          }
+
+          return false;
+        }
+      }
+    }, {
+      key: "bindEvent",
+      value: function bindEvent(graph) {
+        var props = this.props;
+        graph.on(_constants.EditorEvent.onBeforeExecuteCommand, props[_constants.EditorEvent.onBeforeExecuteCommand]);
+        graph.on(_constants.EditorEvent.onAfterExecuteCommand, props[_constants.EditorEvent.onAfterExecuteCommand]);
+      }
+    }, {
+      key: "bindShortcut",
+      value: function bindShortcut(graph) {
+        var _this2 = this;
+
+        var commandManager = this.state.commandManager;
+        window.addEventListener(_constants.GraphCommonEvent.onMouseDown, function (e) {
+          _this2.lastMousedownTarget = e.target;
+        });
+        graph.on(_constants.GraphCommonEvent.onKeyDown, function (e) {
+          if (!_this2.shouldTriggerShortcut(graph, _this2.lastMousedownTarget)) {
+            return;
+          }
+
+          Object.values(commandManager.command).some(function (command) {
+            var name = command.name,
+                shortcuts = command.shortcuts;
+            var flag = shortcuts.some(function (shortcut) {
+              var key = e.key;
+
+              if (!(0, _isArray["default"])(shortcut)) {
+                return shortcut === key;
+              }
+
+              return shortcut.every(function (item, index) {
+                if (index === shortcut.length - 1) {
+                  return item === key;
+                }
+
+                return e[item];
+              });
+            });
+
+            if (flag) {
+              if (commandManager.canExecute(graph, name)) {
+                // Prevent default
+                e.preventDefault(); // Execute command
+
+                _this2.executeCommand(name);
+
+                return true;
+              }
+            }
+
+            return false;
+          });
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var children = this.props.children;
+        var _this$state2 = this.state,
+            graph = _this$state2.graph,
+            setGraph = _this$state2.setGraph,
+            executeCommand = _this$state2.executeCommand,
+            commandManager = _this$state2.commandManager;
+        return /*#__PURE__*/_react["default"].createElement(_EditorContext.EditorContext.Provider, {
+          value: {
+            graph: graph,
+            executeCommand: executeCommand,
+            commandManager: commandManager
+          }
+        }, /*#__PURE__*/_react["default"].createElement(_EditorContext.EditorPrivateContext.Provider, {
+          value: {
+            setGraph: setGraph,
+            commandManager: commandManager
+          }
+        }, /*#__PURE__*/_react["default"].createElement("div", Object.assign({}, (0, _pick["default"])(this.props, ['className', 'style'])), children)));
+      }
+    }], [{
+      key: "setTrackable",
+      value: function setTrackable(trackable) {
+        _global["default"].trackable = trackable;
+      }
+    }]);
+
+    return Editor;
+  }(_react["default"].Component);
+
+  Editor.defaultProps = (_Editor$defaultProps = {}, _defineProperty(_Editor$defaultProps, _constants.EditorEvent.onBeforeExecuteCommand, function () {}), _defineProperty(_Editor$defaultProps, _constants.EditorEvent.onAfterExecuteCommand, function () {}), _Editor$defaultProps);
+  return Editor;
+}();
+
+var _default = Editor;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/EditorContext/index.js b/node_modules/gg-editor/lib/components/EditorContext/index.js
new file mode 100644
index 0000000..8fbfc47
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/EditorContext/index.js
@@ -0,0 +1,26 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.withEditorPrivateContext = exports.withEditorContext = exports.EditorPrivateContext = exports.EditorContext = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _withContext = _interopRequireDefault(require("../../common/withContext"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var EditorContext = _react["default"].createContext({});
+
+exports.EditorContext = EditorContext;
+
+var EditorPrivateContext = _react["default"].createContext({});
+
+exports.EditorPrivateContext = EditorPrivateContext;
+var withEditorContext = (0, _withContext["default"])(EditorContext, function (context) {
+  return !!context.graph;
+});
+exports.withEditorContext = withEditorContext;
+var withEditorPrivateContext = (0, _withContext["default"])(EditorPrivateContext);
+exports.withEditorPrivateContext = withEditorPrivateContext;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Flow/behavior/dragAddEdge.js b/node_modules/gg-editor/lib/components/Flow/behavior/dragAddEdge.js
new file mode 100644
index 0000000..d0fc9d6
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Flow/behavior/dragAddEdge.js
@@ -0,0 +1,254 @@
+"use strict";
+
+var _merge2 = _interopRequireDefault(require("lodash/merge"));
+
+var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var _behaviorManager = _interopRequireDefault(require("../../../common/behaviorManager"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+var getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {
+  var _item$getKeyShape$get = item.getKeyShape().getBBox(),
+      width = _item$getKeyShape$get.width,
+      height = _item$getKeyShape$get.height;
+
+  var _anchorPoint = _slicedToArray(anchorPoint, 2),
+      x = _anchorPoint[0],
+      y = _anchorPoint[1];
+
+  return {
+    x: width * x,
+    y: height * y - 3,
+    r: 3,
+    lineWidth: 2,
+    fill: '#FFFFFF',
+    stroke: '#5AAAFF'
+  };
+};
+
+var dragAddEdgeBehavior = {
+  edge: null,
+  animateAnchor: null,
+  targetId: null,
+  targetAnchorIndex: null,
+  graphType: _constants.GraphType.Flow,
+  getDefaultCfg: function getDefaultCfg() {
+    return {
+      edgeType: 'bizFlowEdge',
+      getAnchorPointStateOfSourceNode: function getAnchorPointStateOfSourceNode() {
+        return _constants.AnchorPointState.Enabled;
+      },
+      getAnchorPointStateOfTargetNode: function getAnchorPointStateOfTargetNode() {
+        return _constants.AnchorPointState.Enabled;
+      }
+    };
+  },
+  getEvents: function getEvents() {
+    return {
+      'node:mouseenter': 'handleNodeMouseEnter',
+      'node:mouseleave': 'handleNodeMouseLeave',
+      'node:mousedown': 'handleNodeMouseDown',
+      mousemove: 'handleMouseMove',
+      mouseup: 'handleMouseUp'
+    };
+  },
+  isEnabledAnchorPoint: function isEnabledAnchorPoint(e) {
+    var target = e.target;
+    return !!target.get('isAnchorPoint') && target.get('anchorPointState') === _constants.AnchorPointState.Enabled;
+  },
+  isNotSelf: function isNotSelf(e) {
+    var edge = this.edge;
+    var item = e.item;
+    return item.getModel().id !== edge.getSource().getModel().id;
+  },
+  getTargetNodes: function getTargetNodes(sourceId) {
+    var graph = this.graph;
+    var nodes = graph.getNodes();
+    return nodes.filter(function (node) {
+      return node.getModel().id !== sourceId;
+    });
+  },
+  canFindTargetAnchorPoint: function canFindTargetAnchorPoint(e) {
+    return this.isEnabledAnchorPoint(e) && this.isNotSelf(e);
+  },
+  shouldAddDelegateEdge: function shouldAddDelegateEdge(e) {
+    return this.isEnabledAnchorPoint(e);
+  },
+  shouldAddRealEdge: function shouldAddRealEdge() {
+    var edge = this.edge;
+    var target = edge.getTarget();
+    return !(0, _isPlainObject2["default"])(target);
+  },
+  handleNodeMouseEnter: function handleNodeMouseEnter(e) {
+    var graph = this.graph,
+        getAnchorPointStateOfSourceNode = this.getAnchorPointStateOfSourceNode;
+    var sourceNode = e.item;
+    var sourceAnchorPoints = sourceNode.getAnchorPoints();
+    var sourceAnchorPointsState = [];
+    sourceAnchorPoints.forEach(function (sourceAnchorPoint) {
+      sourceAnchorPointsState.push(getAnchorPointStateOfSourceNode(sourceNode, sourceAnchorPoint));
+    });
+    sourceNode.set('anchorPointsState', sourceAnchorPointsState);
+    graph.setItemState(sourceNode, _constants.ItemState.ActiveAnchorPoints, true);
+  },
+  handleNodeMouseLeave: function handleNodeMouseLeave(e) {
+    var graph = this.graph,
+        edge = this.edge;
+    var item = e.item;
+
+    if (!edge) {
+      item.set('anchorPointsState', []);
+      graph.setItemState(item, _constants.ItemState.ActiveAnchorPoints, false);
+    }
+  },
+  handleNodeMouseDown: function handleNodeMouseDown(e) {
+    if (!this.shouldBegin(e) || !this.shouldAddDelegateEdge(e)) {
+      return;
+    }
+
+    var graph = this.graph,
+        edgeType = this.edgeType,
+        getAnchorPointStateOfTargetNode = this.getAnchorPointStateOfTargetNode;
+    var target = e.target;
+    var sourceNode = e.item;
+    var sourceNodeId = sourceNode.getModel().id;
+    var sourceAnchorPointIndex = target.get('anchorPointIndex');
+    var sourceAnchorPoint = sourceNode.getAnchorPoints()[sourceAnchorPointIndex];
+    var model = {
+      id: (0, _utils.guid)(),
+      type: edgeType,
+      source: sourceNodeId,
+      sourceAnchor: sourceAnchorPointIndex,
+      target: sourceNodeId
+    };
+    this.edge = graph.addItem(_constants.ItemType.Edge, model);
+    graph.getNodes().forEach(function (targetNode) {
+      if (targetNode.getModel().id === sourceNodeId) {
+        return;
+      }
+
+      var targetAnchorPoints = targetNode.getAnchorPoints();
+      var targetAnchorPointsState = [];
+      targetAnchorPoints.forEach(function (targetAnchorPoint) {
+        targetAnchorPointsState.push(getAnchorPointStateOfTargetNode(sourceNode, sourceAnchorPoint, targetNode, targetAnchorPoint));
+      });
+      targetNode.set('anchorPointsState', targetAnchorPointsState);
+      graph.setItemState(targetNode, _constants.ItemState.ActiveAnchorPoints, true);
+    });
+  },
+  handleMouseMove: function handleMouseMove(e) {
+    var _this = this;
+
+    var graph = this.graph,
+        edge = this.edge;
+
+    if (edge === null) {
+      return;
+    }
+
+    if (this.targetId && this.targetAnchorIndex !== null) {
+      var item = graph.findById(this.targetId);
+
+      if (item) {
+        var targetAnchor = item.getLinkPointByAnchor(this.targetAnchorIndex);
+        if (targetAnchor && Math.abs(targetAnchor.x - e.x) < 5 && Math.abs(targetAnchor.y - e.y) < 5) return;
+      }
+    }
+
+    if (this.canFindTargetAnchorPoint(e)) {
+      var _item = e.item,
+          target = e.target;
+      this.targetId = _item.getModel().id;
+      this.targetAnchorIndex = target.get('anchorPointIndex');
+
+      var _targetAnchor = _item.getLinkPointByAnchor(this.targetAnchorIndex);
+
+      if (!!this.animateAnchorCfg && !this.animateAnchor) {
+        this.animateAnchor = graph.addItem('node', (0, _merge2["default"])(this.animateAnchorCfg, {
+          id: (0, _utils.guid)(),
+          x: _targetAnchor.x,
+          y: _targetAnchor.y
+        }));
+      }
+      /*
+      graph.updateItem(edge, {
+        target: targetId,
+        targetAnchor,
+      });
+      */
+
+    } else {
+      if (this.animateAnchor !== null) {
+        setTimeout(function () {
+          if (_this.animateAnchor !== null) graph.removeItem(_this.animateAnchor);
+          _this.animateAnchor = null;
+        }, 1000);
+      }
+
+      this.targetId = null;
+      this.targetAnchorIndex = null;
+
+      try {
+        graph.updateItem(edge, {
+          target: {
+            x: e.x,
+            y: e.y
+          },
+          targetAnchor: undefined
+        });
+      } catch (err) {//ignore
+      }
+    }
+  },
+  handleMouseUp: function handleMouseUp() {
+    var graph = this.graph,
+        edge = this.edge;
+
+    if (edge === null) {
+      return;
+    }
+
+    if (this.animateAnchor !== null) {
+      graph.removeItem(this.animateAnchor);
+      this.animateAnchor = null;
+    }
+
+    if (this.targetId !== null && this.targetAnchorIndex !== null) {
+      graph.updateItem(edge, {
+        target: this.targetId,
+        targetAnchor: this.targetAnchorIndex
+      });
+      this.targetId = null;
+      this.targetAnchorIndex = null;
+    }
+
+    if (!this.shouldAddRealEdge()) {
+      graph.removeItem(this.edge);
+    }
+
+    this.edge = null;
+    graph.getNodes().forEach(function (node) {
+      node.set('anchorPointsState', []);
+      graph.setItemState(node, _constants.ItemState.ActiveAnchorPoints, false);
+    });
+  }
+};
+
+_behaviorManager["default"].register('drag-add-edge', dragAddEdgeBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Flow/behavior/dragAddNode.js b/node_modules/gg-editor/lib/components/Flow/behavior/dragAddNode.js
new file mode 100644
index 0000000..fd07fbc
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Flow/behavior/dragAddNode.js
@@ -0,0 +1,117 @@
+"use strict";
+
+var _isArray = _interopRequireDefault(require("lodash/isArray"));
+
+var _utils = require("../../../utils");
+
+var _global = _interopRequireDefault(require("../../../common/global"));
+
+var _constants = require("../../../common/constants");
+
+var _behaviorManager = _interopRequireDefault(require("../../../common/behaviorManager"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var dragAddNodeBehavior = {
+  shape: null,
+  graphType: _constants.GraphType.Flow,
+  graphMode: _constants.GraphMode.AddNode,
+  getEvents: function getEvents() {
+    return {
+      'canvas:mouseenter': 'handleCanvasMouseEnter',
+      mousemove: 'handleMouseMove',
+      mouseup: 'handleMouseUp'
+    };
+  },
+  handleCanvasMouseEnter: function handleCanvasMouseEnter(e) {
+    var graph = this.graph,
+        shape = this.shape;
+
+    if (shape) {
+      return;
+    }
+
+    var group = graph.get('group');
+    var model = _global["default"].component.itemPanel.model;
+    var _model$size = model.size,
+        size = _model$size === void 0 ? 100 : _model$size;
+    var width = 0;
+    var height = 0;
+
+    if ((0, _isArray["default"])(size)) {
+      width = size[0];
+      height = size[1];
+    } else {
+      width = size;
+      height = size;
+    }
+
+    var x = e.x - width / 2;
+    var y = e.y - height / 2;
+    this.shape = group.addShape('rect', {
+      className: _global["default"].component.itemPanel.delegateShapeClassName,
+      attrs: {
+        x: x,
+        y: y,
+        width: width,
+        height: height,
+        fill: '#f3f9ff',
+        fillOpacity: 0.5,
+        stroke: '#1890ff',
+        strokeOpacity: 0.9,
+        lineDash: [5, 5]
+      }
+    });
+    graph.paint();
+  },
+  handleMouseMove: function handleMouseMove(e) {
+    var graph = this.graph;
+
+    var _this$shape$getBBox = this.shape.getBBox(),
+        width = _this$shape$getBBox.width,
+        height = _this$shape$getBBox.height;
+
+    var x = e.x - width / 2;
+    var y = e.y - height / 2;
+    this.shape.attr({
+      x: x,
+      y: y
+    });
+    graph.paint();
+  },
+  handleMouseUp: function handleMouseUp(e) {
+    var graph = this.graph;
+
+    var _this$shape$getBBox2 = this.shape.getBBox(),
+        width = _this$shape$getBBox2.width,
+        height = _this$shape$getBBox2.height;
+
+    var x = e.x;
+    var y = e.y;
+    var model = _global["default"].component.itemPanel.model;
+
+    if (model.center === 'topLeft') {
+      x -= width / 2;
+      y -= height / 2;
+    }
+
+    this.shape.remove(true);
+    var commandManager = graph.get('commandManager');
+    commandManager.execute(graph, _constants.EditorCommand.Add, {
+      type: _constants.ItemType.Node,
+      model: _objectSpread({
+        id: (0, _utils.guid)(),
+        x: x,
+        y: y
+      }, model)
+    });
+  }
+};
+
+_behaviorManager["default"].register('drag-add-node', dragAddNodeBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Flow/behavior/index.js b/node_modules/gg-editor/lib/components/Flow/behavior/index.js
new file mode 100644
index 0000000..a361c38
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Flow/behavior/index.js
@@ -0,0 +1,5 @@
+"use strict";
+
+require("./dragAddNode");
+
+require("./dragAddEdge");
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Flow/index.js b/node_modules/gg-editor/lib/components/Flow/index.js
new file mode 100644
index 0000000..da99285
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Flow/index.js
@@ -0,0 +1,191 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _omit = _interopRequireDefault(require("lodash/omit"));
+
+var _merge = _interopRequireDefault(require("lodash/merge"));
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _utils = require("../../utils");
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _behaviorManager = _interopRequireDefault(require("../../common/behaviorManager"));
+
+var _Graph = _interopRequireDefault(require("../Graph"));
+
+require("./behavior");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var Flow =
+/** @class */
+function () {
+  var Flow = /*#__PURE__*/function (_React$Component) {
+    _inherits(Flow, _React$Component);
+
+    var _super = _createSuper(Flow);
+
+    function Flow() {
+      var _this;
+
+      _classCallCheck(this, Flow);
+
+      _this = _super.apply(this, arguments);
+      _this.graph = null;
+      _this.containerId = "".concat(_constants.FLOW_CONTAINER_ID, "_").concat((0, _utils.guid)());
+
+      _this.canDragNode = function (e) {
+        return !['anchor', 'banAnchor'].some(function (item) {
+          return item === e.target.get('className');
+        });
+      };
+
+      _this.canDragOrZoomCanvas = function () {
+        var _assertThisInitialize = _assertThisInitialized(_this),
+            graph = _assertThisInitialize.graph;
+
+        if (!graph) {
+          return false;
+        }
+
+        return _global["default"].plugin.itemPopover.state === 'hide' && _global["default"].plugin.contextMenu.state === 'hide' && _global["default"].plugin.editableLabel.state === 'hide';
+      };
+
+      _this.parseData = function (data) {
+        var nodes = data.nodes,
+            edges = data.edges;
+        [].concat(_toConsumableArray(nodes), _toConsumableArray(edges)).forEach(function (item) {
+          var id = item.id;
+
+          if (id) {
+            return;
+          }
+
+          item.id = (0, _utils.guid)();
+        });
+      };
+
+      _this.initGraph = function (width, height) {
+        var _assertThisInitialize2 = _assertThisInitialized(_this),
+            containerId = _assertThisInitialize2.containerId;
+
+        var _this$props = _this.props,
+            graphConfig = _this$props.graphConfig,
+            customModes = _this$props.customModes;
+        var modes = (0, _merge["default"])(_behaviorManager["default"].getRegisteredBehaviors(_constants.GraphType.Flow), {
+          "default": {
+            'drag-node': {
+              type: 'drag-node',
+              enableDelegate: true,
+              shouldBegin: _this.canDragNode
+            },
+            'drag-canvas': {
+              type: 'drag-canvas',
+              shouldBegin: _this.canDragOrZoomCanvas,
+              shouldUpdate: _this.canDragOrZoomCanvas
+            },
+            'zoom-canvas': {
+              type: 'zoom-canvas',
+              shouldUpdate: _this.canDragOrZoomCanvas
+            },
+            'recall-edge': 'recall-edge',
+            'brush-select': 'brush-select'
+          }
+        });
+        Object.keys(modes).forEach(function (mode) {
+          var behaviors = modes[mode];
+          modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
+        });
+        _this.graph = new _g["default"].Graph(_objectSpread({
+          container: containerId,
+          width: width,
+          height: height,
+          modes: modes,
+          defaultNode: {
+            type: 'bizFlowNode'
+          },
+          defaultEdge: {
+            type: 'bizFlowEdge'
+          }
+        }, graphConfig));
+        return _this.graph;
+      };
+
+      return _this;
+    }
+
+    _createClass(Flow, [{
+      key: "render",
+      value: function render() {
+        var containerId = this.containerId,
+            parseData = this.parseData,
+            initGraph = this.initGraph;
+        return /*#__PURE__*/_react["default"].createElement(_Graph["default"], Object.assign({
+          containerId: containerId,
+          parseData: parseData,
+          initGraph: initGraph
+        }, (0, _omit["default"])(this.props, ['graphConfig', 'customModes'])));
+      }
+    }]);
+
+    return Flow;
+  }(_react["default"].Component);
+
+  Flow.defaultProps = {
+    graphConfig: {}
+  };
+  return Flow;
+}();
+
+var _default = Flow;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/behavior/clickItem.js b/node_modules/gg-editor/lib/components/Graph/behavior/clickItem.js
new file mode 100644
index 0000000..b37e9c1
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/behavior/clickItem.js
@@ -0,0 +1,69 @@
+"use strict";
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var _behaviorManager = _interopRequireDefault(require("../../../common/behaviorManager"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var clickItemBehavior = {
+  getDefaultCfg: function getDefaultCfg() {
+    return {
+      multiple: true,
+      keydown: false,
+      keyCode: 17
+    };
+  },
+  getEvents: function getEvents() {
+    return {
+      'node:click': 'handleItemClick',
+      'edge:click': 'handleItemClick',
+      'canvas:click': 'handleCanvasClick',
+      keydown: 'handleKeyDown',
+      keyup: 'handleKeyUp'
+    };
+  },
+  handleItemClick: function handleItemClick(_ref) {
+    var item = _ref.item;
+    var graph = this.graph;
+
+    if ((0, _utils.isMind)(graph) && (0, _utils.isEdge)(item)) {
+      return;
+    }
+
+    var isSelected = item.hasState(_constants.ItemState.Selected);
+
+    if (this.multiple && this.keydown) {
+      graph.setItemState(item, _constants.ItemState.Selected, !isSelected);
+    } else {
+      (0, _utils.clearSelectedState)(graph, function (selectedItem) {
+        return selectedItem !== item;
+      });
+
+      if (!isSelected) {
+        graph.setItemState(item, _constants.ItemState.Selected, true);
+      }
+    }
+
+    graph.emit(_constants.EditorEvent.onGraphStateChange, {
+      graphState: (0, _utils.getGraphState)(graph)
+    });
+  },
+  handleCanvasClick: function handleCanvasClick() {
+    var graph = this.graph;
+    (0, _utils.clearSelectedState)(graph);
+    graph.emit(_constants.EditorEvent.onGraphStateChange, {
+      graphState: _constants.GraphState.CanvasSelected
+    });
+  },
+  handleKeyDown: function handleKeyDown(e) {
+    this.keydown = (e.keyCode || e.which) === this.keyCode;
+  },
+  handleKeyUp: function handleKeyUp() {
+    this.keydown = false;
+  }
+};
+
+_behaviorManager["default"].register('click-item', clickItemBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/behavior/dragCanvas.js b/node_modules/gg-editor/lib/components/Graph/behavior/dragCanvas.js
new file mode 100644
index 0000000..8784b9b
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/behavior/dragCanvas.js
@@ -0,0 +1,141 @@
+"use strict";
+
+var _behaviorManager = _interopRequireDefault(require("../../../common/behaviorManager"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var dragCanvasBehavior = {
+  origin: null,
+  keyCode: null,
+  dragging: false,
+  handleWindowMouseUp: null,
+  getDefaultCfg: function getDefaultCfg() {
+    return {
+      allowKeyCode: [],
+      notAllowKeyCode: [16]
+    };
+  },
+  getEvents: function getEvents() {
+    return {
+      'canvas:dragstart': 'handleCanvasDragStart',
+      'canvas:drag': 'handleCanvasDrag',
+      'canvas:dragend': 'handleCanvasDragEnd',
+      'canvas:mouseleave': 'handleCanvasMouseLeave',
+      'canvas:contextmenu': 'handleCanvasContextMenu',
+      keydown: 'handleKeyDown',
+      keyup: 'handleKeyUp'
+    };
+  },
+  canDrag: function canDrag() {
+    var keyCode = this.keyCode,
+        allowKeyCode = this.allowKeyCode,
+        notAllowKeyCode = this.notAllowKeyCode;
+    var isAllow = !!!allowKeyCode.length;
+
+    if (!keyCode) {
+      return isAllow;
+    }
+
+    if (allowKeyCode.length && allowKeyCode.includes(keyCode)) {
+      isAllow = true;
+    }
+
+    if (notAllowKeyCode.includes(keyCode)) {
+      isAllow = false;
+    }
+
+    return isAllow;
+  },
+  updateViewport: function updateViewport(e) {
+    var clientX = e.clientX,
+        clientY = e.clientY;
+    var dx = clientX - this.origin.x;
+    var dy = clientY - this.origin.y;
+    this.origin = {
+      x: clientX,
+      y: clientY
+    };
+    this.graph.translate(dx, dy);
+    this.graph.paint();
+  },
+  handleCanvasDragStart: function handleCanvasDragStart(e) {
+    if (!this.shouldBegin.call(this, e)) {
+      return;
+    }
+
+    if (!this.canDrag()) {
+      return;
+    }
+
+    this.origin = {
+      x: e.clientX,
+      y: e.clientY
+    };
+    this.dragging = false;
+  },
+  handleCanvasDrag: function handleCanvasDrag(e) {
+    if (!this.shouldUpdate.call(this, e)) {
+      return;
+    }
+
+    if (!this.canDrag()) {
+      return;
+    }
+
+    if (!this.origin) {
+      return;
+    }
+
+    if (!this.dragging) {
+      this.dragging = true;
+    } else {
+      this.updateViewport(e);
+    }
+  },
+  handleCanvasDragEnd: function handleCanvasDragEnd(e) {
+    if (!this.shouldEnd.call(this, e)) {
+      return;
+    }
+
+    if (!this.canDrag()) {
+      return;
+    }
+
+    this.origin = null;
+    this.dragging = false;
+
+    if (this.handleWindowMouseUp) {
+      document.body.removeEventListener('mouseup', this.handleWindowMouseUp, false);
+      this.handleWindowMouseUp = null;
+    }
+  },
+  handleCanvasMouseLeave: function handleCanvasMouseLeave() {
+    var _this = this;
+
+    var canvasElement = this.graph.get('canvas').get('el');
+
+    if (this.handleWindowMouseUp) {
+      return;
+    }
+
+    this.handleWindowMouseUp = function (e) {
+      if (e.target !== canvasElement) {
+        _this.handleCanvasDragEnd();
+      }
+    };
+
+    document.body.addEventListener('mouseup', this.handleWindowMouseUp, false);
+  },
+  handleCanvasContextMenu: function handleCanvasContextMenu() {
+    this.origin = null;
+    this.dragging = false;
+  },
+  handleKeyDown: function handleKeyDown(e) {
+    this.keyCode = e.keyCode || e.which;
+  },
+  handleKeyUp: function handleKeyUp() {
+    this.keyCode = null;
+  }
+};
+
+_behaviorManager["default"].register('drag-canvas', dragCanvasBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/behavior/hoverItem.js b/node_modules/gg-editor/lib/components/Graph/behavior/hoverItem.js
new file mode 100644
index 0000000..4307bec
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/behavior/hoverItem.js
@@ -0,0 +1,30 @@
+"use strict";
+
+var _constants = require("../../../common/constants");
+
+var _behaviorManager = _interopRequireDefault(require("../../../common/behaviorManager"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var hoverItemBehavior = {
+  getEvents: function getEvents() {
+    return {
+      'node:mouseenter': 'handleItemMouseenter',
+      'edge:mouseenter': 'handleItemMouseenter',
+      'node:mouseleave': 'handleItemMouseleave',
+      'edge:mouseleave': 'handleItemMouseleave'
+    };
+  },
+  handleItemMouseenter: function handleItemMouseenter(_ref) {
+    var item = _ref.item;
+    var graph = this.graph;
+    graph.setItemState(item, _constants.ItemState.Active, true);
+  },
+  handleItemMouseleave: function handleItemMouseleave(_ref2) {
+    var item = _ref2.item;
+    var graph = this.graph;
+    graph.setItemState(item, _constants.ItemState.Active, false);
+  }
+};
+
+_behaviorManager["default"].register('hover-item', hoverItemBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/behavior/index.js b/node_modules/gg-editor/lib/components/Graph/behavior/index.js
new file mode 100644
index 0000000..b8990ba
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/behavior/index.js
@@ -0,0 +1,9 @@
+"use strict";
+
+require("./clickItem");
+
+require("./hoverItem");
+
+require("./dragCanvas");
+
+require("./recallEdge");
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/behavior/recallEdge.js b/node_modules/gg-editor/lib/components/Graph/behavior/recallEdge.js
new file mode 100644
index 0000000..6990fdc
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/behavior/recallEdge.js
@@ -0,0 +1,70 @@
+"use strict";
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var _behaviorManager = _interopRequireDefault(require("../../../common/behaviorManager"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var recallEdgeBehavior = {
+  edgeIds: [],
+  getEvents: function getEvents() {
+    return {
+      'node:click': 'handleNodeClick',
+      'edge:click': 'handleEdgeClick',
+      'canvas:click': 'handleCanvasClick'
+    };
+  },
+  setHighLightState: function setHighLightState(edges) {
+    var graph = this.graph;
+    this.clearHighLightState();
+    (0, _utils.executeBatch)(graph, function () {
+      edges.forEach(function (item) {
+        graph.setItemState(item, _constants.ItemState.HighLight, true);
+      });
+    });
+    this.edgeIds = edges.map(function (edge) {
+      return edge.get('id');
+    });
+  },
+  clearHighLightState: function clearHighLightState() {
+    var _this = this;
+
+    var graph = this.graph;
+    (0, _utils.executeBatch)(graph, function () {
+      _this.edgeIds.forEach(function (id) {
+        var item = graph.findById(id);
+
+        if (item && !item.destroyed) {
+          graph.setItemState(item, _constants.ItemState.HighLight, false);
+        }
+      });
+    });
+    this.edgeIds = [];
+  },
+  handleNodeClick: function handleNodeClick(_ref) {
+    var item = _ref.item;
+    var graph = this.graph;
+    var edges = [];
+
+    if ((0, _utils.isFlow)(graph)) {
+      edges = (0, _utils.getFlowRecallEdges)(graph, item);
+    }
+
+    if ((0, _utils.isMind)(graph)) {
+      edges = (0, _utils.getMindRecallEdges)(graph, item);
+    }
+
+    this.setHighLightState(edges);
+  },
+  handleEdgeClick: function handleEdgeClick() {
+    this.clearHighLightState();
+  },
+  handleCanvasClick: function handleCanvasClick() {
+    this.clearHighLightState();
+  }
+};
+
+_behaviorManager["default"].register('recall-edge', recallEdgeBehavior);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/add.js b/node_modules/gg-editor/lib/components/Graph/command/add.js
new file mode 100644
index 0000000..654b623
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/add.js
@@ -0,0 +1,50 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var _base = require("./base");
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var addCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  params: {
+    type: _constants.ItemType.Node,
+    model: {
+      id: ''
+    }
+  },
+  init: function init() {
+    var model = this.params.model;
+
+    if (model.id) {
+      return;
+    }
+
+    model.id = (0, _utils.guid)();
+  },
+  execute: function execute(graph) {
+    var _this$params = this.params,
+        type = _this$params.type,
+        model = _this$params.model;
+    graph.add(type, model);
+    this.setSelectedItems(graph, [model.id]);
+  },
+  undo: function undo(graph) {
+    var model = this.params.model;
+    graph.remove(model.id);
+  }
+});
+
+var _default = addCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/base.js b/node_modules/gg-editor/lib/components/Graph/command/base.js
new file mode 100644
index 0000000..3cbe5ac
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/base.js
@@ -0,0 +1,38 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.baseCommand = void 0;
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var baseCommand = {
+  name: '',
+  params: {},
+  canExecute: function canExecute() {
+    return true;
+  },
+  shouldExecute: function shouldExecute() {
+    return true;
+  },
+  canUndo: function canUndo() {
+    return true;
+  },
+  init: function init() {},
+  execute: function execute() {},
+  undo: function undo() {},
+  shortcuts: [],
+  isMind: _utils.isMind,
+  getSelectedNodes: _utils.getSelectedNodes,
+  getSelectedEdges: _utils.getSelectedEdges,
+  setSelectedItems: _utils.setSelectedItems,
+  editSelectedNode: function editSelectedNode(graph) {
+    graph.emit(_constants.EditorEvent.onLabelStateChange, {
+      labelState: _constants.LabelState.Show
+    });
+  }
+};
+exports.baseCommand = baseCommand;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/copy.js b/node_modules/gg-editor/lib/components/Graph/command/copy.js
new file mode 100644
index 0000000..0d3f707
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/copy.js
@@ -0,0 +1,39 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));
+
+var _global = _interopRequireDefault(require("../../../common/global"));
+
+var _base = require("./base");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var copyCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  canExecute: function canExecute(graph) {
+    return !!this.getSelectedNodes(graph).length;
+  },
+  canUndo: function canUndo() {
+    return false;
+  },
+  execute: function execute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    _global["default"].clipboard.models = (0, _cloneDeep["default"])(selectedNodes.map(function (node) {
+      return node.getModel();
+    }));
+  },
+  shortcuts: [['metaKey', 'c'], ['ctrlKey', 'c']]
+});
+
+var _default = copyCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/index.js b/node_modules/gg-editor/lib/components/Graph/command/index.js
new file mode 100644
index 0000000..508e0a4
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/index.js
@@ -0,0 +1,42 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _redo = _interopRequireDefault(require("./redo"));
+
+var _undo = _interopRequireDefault(require("./undo"));
+
+var _add = _interopRequireDefault(require("./add"));
+
+var _remove = _interopRequireDefault(require("./remove"));
+
+var _update = _interopRequireDefault(require("./update"));
+
+var _copy = _interopRequireDefault(require("./copy"));
+
+var _paste = _interopRequireDefault(require("./paste"));
+
+var _pasteHere = _interopRequireDefault(require("./pasteHere"));
+
+var _zoomIn = _interopRequireDefault(require("./zoomIn"));
+
+var _zoomOut = _interopRequireDefault(require("./zoomOut"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var _default = {
+  redo: _redo["default"],
+  undo: _undo["default"],
+  add: _add["default"],
+  remove: _remove["default"],
+  update: _update["default"],
+  copy: _copy["default"],
+  paste: _paste["default"],
+  pasteHere: _pasteHere["default"],
+  zoomIn: _zoomIn["default"],
+  zoomOut: _zoomOut["default"]
+};
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/paste.js b/node_modules/gg-editor/lib/components/Graph/command/paste.js
new file mode 100644
index 0000000..c4d90b6
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/paste.js
@@ -0,0 +1,70 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _utils = require("../../../utils");
+
+var _global = _interopRequireDefault(require("../../../common/global"));
+
+var _constants = require("../../../common/constants");
+
+var _base = require("./base");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var pasteCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  params: {
+    models: []
+  },
+  canExecute: function canExecute() {
+    return !!_global["default"].clipboard.models.length;
+  },
+  init: function init() {
+    var models = _global["default"].clipboard.models;
+    var offsetX = 10;
+    var offsetY = 10;
+    this.params = {
+      models: models.map(function (model) {
+        var x = model.x,
+            y = model.y;
+        return _objectSpread(_objectSpread({}, model), {}, {
+          id: (0, _utils.guid)(),
+          x: x + offsetX,
+          y: y + offsetY
+        });
+      })
+    };
+  },
+  execute: function execute(graph) {
+    var models = this.params.models;
+    (0, _utils.executeBatch)(graph, function () {
+      models.forEach(function (model) {
+        graph.addItem(_constants.ItemType.Node, model);
+      });
+    });
+    this.setSelectedItems(graph, models.map(function (model) {
+      return model.id;
+    }));
+  },
+  undo: function undo(graph) {
+    var models = this.params.models;
+    (0, _utils.executeBatch)(graph, function () {
+      models.forEach(function (model) {
+        graph.removeItem(model.id);
+      });
+    });
+  },
+  shortcuts: [['metaKey', 'v'], ['ctrlKey', 'v']]
+});
+
+var _default = pasteCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/pasteHere.js b/node_modules/gg-editor/lib/components/Graph/command/pasteHere.js
new file mode 100644
index 0000000..ff5f8a3
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/pasteHere.js
@@ -0,0 +1,48 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _utils = require("../../../utils");
+
+var _global = _interopRequireDefault(require("../../../common/global"));
+
+var _paste = _interopRequireDefault(require("./paste"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var pasteHereCommand = _objectSpread(_objectSpread({}, _paste["default"]), {}, {
+  params: {
+    models: []
+  },
+  init: function init() {
+    var _global$clipboard = _global["default"].clipboard,
+        point = _global$clipboard.point,
+        models = _global$clipboard.models;
+    this.params = {
+      models: models.map(function (model) {
+        var x = model.x,
+            y = model.y;
+        var offsetX = point.x - x;
+        var offsetY = point.y - y;
+        return _objectSpread(_objectSpread({}, model), {}, {
+          id: (0, _utils.guid)(),
+          x: x + offsetX,
+          y: y + offsetY
+        });
+      })
+    };
+  },
+  shortcuts: []
+});
+
+var _default = pasteHereCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/redo.js b/node_modules/gg-editor/lib/components/Graph/command/redo.js
new file mode 100644
index 0000000..2cd841e
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/redo.js
@@ -0,0 +1,34 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+var redoCommand = {
+  name: 'redo',
+  params: {},
+  canExecute: function canExecute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandQueue = commandManager.commandQueue,
+        commandIndex = commandManager.commandIndex;
+    return commandIndex < commandQueue.length;
+  },
+  shouldExecute: function shouldExecute() {
+    return true;
+  },
+  canUndo: function canUndo() {
+    return false;
+  },
+  init: function init() {},
+  execute: function execute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandQueue = commandManager.commandQueue,
+        commandIndex = commandManager.commandIndex;
+    commandQueue[commandIndex].execute(graph);
+    commandManager.commandIndex += 1;
+  },
+  undo: function undo() {},
+  shortcuts: [['metaKey', 'shiftKey', 'z'], ['ctrlKey', 'shiftKey', 'z']]
+};
+var _default = redoCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/remove.js b/node_modules/gg-editor/lib/components/Graph/command/remove.js
new file mode 100644
index 0000000..68ccaa5
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/remove.js
@@ -0,0 +1,132 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var _base = require("./base");
+
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var removeCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  params: {
+    flow: {
+      nodes: {},
+      edges: {}
+    },
+    mind: {
+      model: null,
+      parent: ''
+    }
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    var selectedEdges = this.getSelectedEdges(graph);
+    return !!(selectedNodes.length || selectedEdges.length);
+  },
+  init: function init(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    var selectedEdges = this.getSelectedEdges(graph);
+
+    if ((0, _utils.isMind)(graph)) {
+      var selectedNode = selectedNodes[0];
+      var selectedNodeModel = selectedNode.getModel();
+      var selectedNodeParent = selectedNode.get('parent');
+      var selectedNodeParentModel = selectedNodeParent ? selectedNodeParent.getModel() : {};
+      this.params.mind = {
+        model: selectedNodeModel,
+        parent: selectedNodeParentModel.id
+      };
+    } else {
+      var _this$params$flow = this.params.flow,
+          nodes = _this$params$flow.nodes,
+          edges = _this$params$flow.edges;
+      selectedNodes.forEach(function (node) {
+        var nodeModel = node.getModel();
+        var nodeEdges = node.getEdges();
+        nodes[nodeModel.id] = nodeModel;
+        nodeEdges.forEach(function (edge) {
+          var edgeModel = edge.getModel();
+          edges[edgeModel.id] = edgeModel;
+        });
+      });
+      selectedEdges.forEach(function (edge) {
+        var edgeModel = edge.getModel();
+        edges[edgeModel.id] = edgeModel;
+      });
+    }
+  },
+  execute: function execute(graph) {
+    if ((0, _utils.isMind)(graph)) {
+      var model = this.params.mind.model;
+
+      if (!model) {
+        return;
+      }
+
+      graph.removeChild(model.id);
+    } else {
+      var _this$params$flow2 = this.params.flow,
+          nodes = _this$params$flow2.nodes,
+          edges = _this$params$flow2.edges;
+      (0, _utils.executeBatch)(graph, function () {
+        [].concat(_toConsumableArray(Object.keys(nodes)), _toConsumableArray(Object.keys(edges))).forEach(function (id) {
+          graph.removeItem(id);
+        });
+      });
+    }
+  },
+  undo: function undo(graph) {
+    if ((0, _utils.isMind)(graph)) {
+      var _this$params$mind = this.params.mind,
+          model = _this$params$mind.model,
+          parent = _this$params$mind.parent;
+
+      if (!model) {
+        return;
+      } //@ts-ignore
+
+
+      graph.addChild(model, parent);
+    } else {
+      var _this$params$flow3 = this.params.flow,
+          nodes = _this$params$flow3.nodes,
+          edges = _this$params$flow3.edges;
+      (0, _utils.executeBatch)(graph, function () {
+        Object.keys(nodes).forEach(function (id) {
+          var model = nodes[id];
+          graph.addItem(_constants.ItemType.Node, model);
+        });
+        Object.keys(edges).forEach(function (id) {
+          var model = edges[id];
+          graph.addItem(_constants.ItemType.Edge, model);
+        });
+      });
+    }
+  },
+  shortcuts: ['Delete', 'Backspace']
+});
+
+var _default = removeCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/undo.js b/node_modules/gg-editor/lib/components/Graph/command/undo.js
new file mode 100644
index 0000000..616c71b
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/undo.js
@@ -0,0 +1,33 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+var undoCommand = {
+  name: 'undo',
+  params: {},
+  canExecute: function canExecute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandIndex = commandManager.commandIndex;
+    return commandIndex > 0;
+  },
+  shouldExecute: function shouldExecute() {
+    return true;
+  },
+  canUndo: function canUndo() {
+    return false;
+  },
+  init: function init() {},
+  execute: function execute(graph) {
+    var commandManager = graph.get('commandManager');
+    var commandQueue = commandManager.commandQueue,
+        commandIndex = commandManager.commandIndex;
+    commandQueue[commandIndex - 1].undo(graph);
+    commandManager.commandIndex -= 1;
+  },
+  undo: function undo() {},
+  shortcuts: [['metaKey', 'z'], ['ctrlKey', 'z']]
+};
+var _default = undoCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/update.js b/node_modules/gg-editor/lib/components/Graph/command/update.js
new file mode 100644
index 0000000..5e81ed2
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/update.js
@@ -0,0 +1,60 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _pick = _interopRequireDefault(require("lodash/pick"));
+
+var _base = require("./base");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var updateCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  params: {
+    id: '',
+    originModel: {},
+    updateModel: {},
+    forceRefreshLayout: false
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    var selectedEdges = this.getSelectedEdges(graph);
+    return (selectedNodes.length || selectedEdges.length) && (selectedNodes.length === 1 || selectedEdges.length === 1) ? true : false;
+  },
+  init: function init(graph) {
+    var _this$params = this.params,
+        id = _this$params.id,
+        updateModel = _this$params.updateModel;
+    var updatePaths = Object.keys(updateModel);
+    var originModel = (0, _pick["default"])(graph.findById(id).getModel(), updatePaths);
+    this.params.originModel = originModel;
+  },
+  execute: function execute(graph) {
+    var _this$params2 = this.params,
+        id = _this$params2.id,
+        updateModel = _this$params2.updateModel,
+        forceRefreshLayout = _this$params2.forceRefreshLayout;
+    graph.updateItem(id, updateModel);
+
+    if (forceRefreshLayout) {
+      graph.refreshLayout && graph.refreshLayout(false);
+    }
+  },
+  undo: function undo(graph) {
+    var _this$params3 = this.params,
+        id = _this$params3.id,
+        originModel = _this$params3.originModel;
+    graph.updateItem(id, originModel);
+  }
+});
+
+var _default = updateCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/zoomIn.js b/node_modules/gg-editor/lib/components/Graph/command/zoomIn.js
new file mode 100644
index 0000000..353727c
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/zoomIn.js
@@ -0,0 +1,37 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _base = require("./base");
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var DELTA = 0.05;
+
+var zoomInCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  canUndo: function canUndo() {
+    return false;
+  },
+  execute: function execute(graph) {
+    var ratio = 1 + DELTA;
+    var zoom = graph.getZoom() * ratio;
+    var maxZoom = graph.get('maxZoom');
+
+    if (zoom > maxZoom) {
+      return;
+    }
+
+    graph.zoom(ratio);
+  },
+  shortcuts: [['metaKey', '='], ['ctrlKey', '=']]
+});
+
+var _default = zoomInCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/command/zoomOut.js b/node_modules/gg-editor/lib/components/Graph/command/zoomOut.js
new file mode 100644
index 0000000..79c7504
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/command/zoomOut.js
@@ -0,0 +1,37 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _base = require("./base");
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var DELTA = 0.05;
+
+var zoomOutCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  canUndo: function canUndo() {
+    return false;
+  },
+  execute: function execute(graph) {
+    var ratio = 1 - DELTA;
+    var zoom = graph.getZoom() * ratio;
+    var minZoom = graph.get('minZoom');
+
+    if (zoom < minZoom) {
+      return;
+    }
+
+    graph.zoom(ratio);
+  },
+  shortcuts: [['metaKey', '-'], ['ctrlKey', '-']]
+});
+
+var _default = zoomOutCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Graph/index.d.ts b/node_modules/gg-editor/lib/components/Graph/index.d.ts
index 629bd61..22802f6 100644
--- a/node_modules/gg-editor/lib/components/Graph/index.d.ts
+++ b/node_modules/gg-editor/lib/components/Graph/index.d.ts
@@ -10,5 +10,5 @@ interface GraphProps extends Partial<GraphReactEventProps>, EditorPrivateContext
     parseData(data: object): void;
     initGraph(width: number, height: number): Graph;
 }
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<GraphProps>, "onClick" | "onDoubleClick" | "onMouseEnter" | "onMouseMove" | "onMouseOut" | "onMouseOver" | "onMouseLeave" | "onMouseDown" | "onMouseUp" | "onContextMenu" | "onDragStart" | "onDrag" | "onDragEnd" | "onDragEnter" | "onDragLeave" | "onDrop" | "onKeyDown" | "onKeyUp" | "onTouchStart" | "onTouchMove" | "onTouchEnd" | "onNodeClick" | "onNodeDoubleClick" | "onNodeMouseEnter" | "onNodeMouseMove" | "onNodeMouseOut" | "onNodeMouseOver" | "onNodeMouseLeave" | "onNodeMouseDown" | "onNodeMouseUp" | "onNodeContextMenu" | "onNodeDragStart" | "onNodeDrag" | "onNodeDragEnd" | "onNodeDragEnter" | "onNodeDragLeave" | "onNodeDrop" | "onEdgeClick" | "onEdgeDoubleClick" | "onEdgeMouseEnter" | "onEdgeMouseMove" | "onEdgeMouseOut" | "onEdgeMouseOver" | "onEdgeMouseLeave" | "onEdgeMouseDown" | "onEdgeMouseUp" | "onEdgeContextMenu" | "onCanvasClick" | "onCanvasDoubleClick" | "onCanvasMouseEnter" | "onCanvasMouseMove" | "onCanvasMouseOut" | "onCanvasMouseOver" | "onCanvasMouseLeave" | "onCanvasMouseDown" | "onCanvasMouseUp" | "onCanvasContextMenu" | "onCanvasDragStart" | "onCanvasDrag" | "onCanvasDragEnd" | "onCanvasDragEnter" | "onCanvasDragLeave" | "onBeforeAddItem" | "onAfterAddItem" | "onBeforeRemoveItem" | "onAfterRemoveItem" | "onBeforeUpdateItem" | "onAfterUpdateItem" | "onBeforeItemVisibilityChange" | "onAfterItemVisibilityChange" | "onBeforeItemStateChange" | "onAfterItemStateChange" | "onBeforeRefreshItem" | "onAfterRefreshItem" | "onBeforeItemStatesClear" | "onAfterItemStatesClear" | "onBeforeLayout" | "onAfterLayout" | "onBeforeConnect" | "onAfterConnect" | "style" | "className" | "containerId" | "data" | "parseData" | "initGraph" | "children"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<GraphProps>, "data" | "style" | "onClick" | "onDoubleClick" | "onMouseEnter" | "onMouseMove" | "onMouseOut" | "onMouseOver" | "onMouseLeave" | "onMouseDown" | "onMouseUp" | "onContextMenu" | "onDragStart" | "onDrag" | "onDragEnd" | "onDragEnter" | "onDragLeave" | "onDrop" | "onKeyDown" | "onKeyUp" | "onTouchStart" | "onTouchMove" | "onTouchEnd" | "onNodeClick" | "onNodeDoubleClick" | "onNodeMouseEnter" | "onNodeMouseMove" | "onNodeMouseOut" | "onNodeMouseOver" | "onNodeMouseLeave" | "onNodeMouseDown" | "onNodeMouseUp" | "onNodeContextMenu" | "onNodeDragStart" | "onNodeDrag" | "onNodeDragEnd" | "onNodeDragEnter" | "onNodeDragLeave" | "onNodeDrop" | "onEdgeClick" | "onEdgeDoubleClick" | "onEdgeMouseEnter" | "onEdgeMouseMove" | "onEdgeMouseOut" | "onEdgeMouseOver" | "onEdgeMouseLeave" | "onEdgeMouseDown" | "onEdgeMouseUp" | "onEdgeContextMenu" | "onCanvasClick" | "onCanvasDoubleClick" | "onCanvasMouseEnter" | "onCanvasMouseMove" | "onCanvasMouseOut" | "onCanvasMouseOver" | "onCanvasMouseLeave" | "onCanvasMouseDown" | "onCanvasMouseUp" | "onCanvasContextMenu" | "onCanvasDragStart" | "onCanvasDrag" | "onCanvasDragEnd" | "onCanvasDragEnter" | "onCanvasDragLeave" | "onBeforeAddItem" | "onAfterAddItem" | "onBeforeRemoveItem" | "onAfterRemoveItem" | "onBeforeUpdateItem" | "onAfterUpdateItem" | "onBeforeItemVisibilityChange" | "onAfterItemVisibilityChange" | "onBeforeItemStateChange" | "onAfterItemStateChange" | "onBeforeRefreshItem" | "onAfterRefreshItem" | "onBeforeItemStatesClear" | "onAfterItemStatesClear" | "onBeforeLayout" | "onAfterLayout" | "onBeforeConnect" | "onAfterConnect" | "children" | "className" | "containerId" | "parseData" | "initGraph"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/components/Graph/index.js b/node_modules/gg-editor/lib/components/Graph/index.js
new file mode 100644
index 0000000..df6cd25
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Graph/index.js
@@ -0,0 +1,214 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _pick = _interopRequireDefault(require("lodash/pick"));
+
+var _utils = require("../../utils");
+
+var _helpers = require("../../helpers");
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../EditorContext");
+
+var _command = _interopRequireDefault(require("./command"));
+
+var _command2 = _interopRequireDefault(require("../Mind/command"));
+
+require("./behavior");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var GraphComponent = /*#__PURE__*/function (_React$Component) {
+  _inherits(GraphComponent, _React$Component);
+
+  var _super = _createSuper(GraphComponent);
+
+  function GraphComponent() {
+    var _this;
+
+    _classCallCheck(this, GraphComponent);
+
+    _this = _super.apply(this, arguments);
+    _this.graph = null;
+
+    _this.changeWidth = function () {
+      setTimeout(function () {
+        var containerId = _this.props.containerId;
+
+        var _ref = document.getElementById(containerId) || {},
+            _ref$clientWidth = _ref.clientWidth,
+            clientWidth = _ref$clientWidth === void 0 ? 0 : _ref$clientWidth,
+            _ref$clientHeight = _ref.clientHeight,
+            clientHeight = _ref$clientHeight === void 0 ? 0 : _ref$clientHeight;
+
+        _this.graph.changeSize(clientWidth, clientHeight);
+      }, 200);
+    };
+
+    return _this;
+  }
+
+  _createClass(GraphComponent, [{
+    key: "componentDidMount",
+    value: function componentDidMount() {
+      this.initGraph();
+      this.bindEvent();
+    }
+  }, {
+    key: "componentWillUnmount",
+    value: function componentWillUnmount() {
+      window.removeEventListener('resize', this.changeWidth);
+    }
+  }, {
+    key: "componentDidUpdate",
+    value: function componentDidUpdate(prevProps) {
+      var data = this.props.data;
+
+      if (data !== prevProps.data) {
+        this.changeData(data);
+      }
+    }
+  }, {
+    key: "focusRootNode",
+    value: function focusRootNode(graph, data) {
+      if (!(0, _utils.isMind)(graph)) {
+        return;
+      }
+
+      var id = data.id;
+      graph.focusItem(id);
+    }
+  }, {
+    key: "initGraph",
+    value: function initGraph() {
+      var _this$props = this.props,
+          containerId = _this$props.containerId,
+          parseData = _this$props.parseData,
+          initGraph = _this$props.initGraph,
+          setGraph = _this$props.setGraph,
+          commandManager = _this$props.commandManager;
+
+      var _ref2 = document.getElementById(containerId) || {},
+          _ref2$clientWidth = _ref2.clientWidth,
+          clientWidth = _ref2$clientWidth === void 0 ? 0 : _ref2$clientWidth,
+          _ref2$clientHeight = _ref2.clientHeight,
+          clientHeight = _ref2$clientHeight === void 0 ? 0 : _ref2$clientHeight; // 解析数据
+
+
+      var data = _objectSpread({}, this.props.data);
+
+      parseData(data); // 初始画布
+
+      this.graph = initGraph(clientWidth, clientHeight);
+      this.graph.data(data);
+      this.graph.render();
+      this.focusRootNode(this.graph, data);
+      this.graph.setMode('default');
+      setGraph(this.graph); // 设置命令管理器
+
+      this.graph.set('commandManager', commandManager); // 注册命令
+
+      var commands = _command["default"];
+
+      if ((0, _utils.isMind)(this.graph)) {
+        commands = _objectSpread(_objectSpread({}, commands), _command2["default"]);
+      }
+
+      Object.keys(commands).forEach(function (name) {
+        commandManager.register(name, commands[name]);
+      });
+      window.addEventListener('resize', this.changeWidth);
+      this.changeWidth(); // 发送埋点
+
+      if (_global["default"].trackable) {
+        var graphType = (0, _utils.isMind)(this.graph) ? _constants.GraphType.Mind : _constants.GraphType.Flow;
+        (0, _helpers.track)(graphType);
+      }
+    }
+  }, {
+    key: "bindEvent",
+    value: function bindEvent() {
+      var graph = this.graph,
+          props = this.props;
+
+      if (!graph) {
+        return;
+      }
+
+      var events = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _constants.GraphCommonEvent), _constants.GraphNodeEvent), _constants.GraphEdgeEvent), _constants.GraphCanvasEvent), _constants.GraphCustomEvent);
+
+      Object.keys(events).forEach(function (event) {
+        if (typeof props[event] === 'function') {
+          graph.on(events[event], props[event]);
+        }
+      });
+    }
+  }, {
+    key: "changeData",
+    value: function changeData(data) {
+      var graph = this.graph;
+      var parseData = this.props.parseData;
+
+      if (!graph) {
+        return;
+      }
+
+      parseData(data);
+      graph.changeData(data);
+      this.focusRootNode(graph, data);
+    }
+  }, {
+    key: "render",
+    value: function render() {
+      var _this$props2 = this.props,
+          containerId = _this$props2.containerId,
+          children = _this$props2.children;
+      return /*#__PURE__*/_react["default"].createElement("div", Object.assign({
+        id: containerId
+      }, (0, _pick["default"])(this.props, ['className', 'style'])), children);
+    }
+  }]);
+
+  return GraphComponent;
+}(_react["default"].Component);
+
+var _default = (0, _EditorContext.withEditorPrivateContext)(GraphComponent);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/ItemPanel/Item.d.ts b/node_modules/gg-editor/lib/components/ItemPanel/Item.d.ts
index 22a7f7e..8faca40 100644
--- a/node_modules/gg-editor/lib/components/ItemPanel/Item.d.ts
+++ b/node_modules/gg-editor/lib/components/ItemPanel/Item.d.ts
@@ -10,5 +10,5 @@ export interface ItemProps extends EditorContextProps {
 }
 export interface ItemState {
 }
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemProps>, "children" | "style" | "className" | "type" | "model"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemProps>, "style" | "type" | "model" | "children" | "className"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/components/ItemPanel/Item.js b/node_modules/gg-editor/lib/components/ItemPanel/Item.js
new file mode 100644
index 0000000..672ec29
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/ItemPanel/Item.js
@@ -0,0 +1,93 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _pick = _interopRequireDefault(require("lodash/pick"));
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var Item =
+/** @class */
+function () {
+  var Item = /*#__PURE__*/function (_React$Component) {
+    _inherits(Item, _React$Component);
+
+    var _super = _createSuper(Item);
+
+    function Item() {
+      var _this;
+
+      _classCallCheck(this, Item);
+
+      _this = _super.apply(this, arguments);
+
+      _this.handleMouseDown = function () {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            type = _this$props.type,
+            model = _this$props.model;
+
+        if (type === _constants.ItemType.Node) {
+          _global["default"].component.itemPanel.model = model;
+          graph.setMode(_constants.GraphMode.AddNode);
+        }
+      };
+
+      return _this;
+    }
+
+    _createClass(Item, [{
+      key: "render",
+      value: function render() {
+        var children = this.props.children;
+        return /*#__PURE__*/_react["default"].createElement("div", Object.assign({}, (0, _pick["default"])(this.props, ['style', 'className']), {
+          onMouseDown: this.handleMouseDown
+        }), children);
+      }
+    }]);
+
+    return Item;
+  }(_react["default"].Component);
+
+  Item.defaultProps = {
+    type: _constants.ItemType.Node
+  };
+  return Item;
+}();
+
+var _default = (0, _EditorContext.withEditorContext)(Item);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/ItemPanel/index.d.ts b/node_modules/gg-editor/lib/components/ItemPanel/index.d.ts
index ba19ecd..ec9ea70 100644
--- a/node_modules/gg-editor/lib/components/ItemPanel/index.d.ts
+++ b/node_modules/gg-editor/lib/components/ItemPanel/index.d.ts
@@ -6,5 +6,5 @@ interface ItemPanelProps extends EditorContextProps {
     className?: string;
 }
 export { Item };
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemPanelProps>, "style" | "className" | "children"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemPanelProps>, "style" | "children" | "className"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/components/ItemPanel/index.js b/node_modules/gg-editor/lib/components/ItemPanel/index.js
new file mode 100644
index 0000000..e2df3f6
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/ItemPanel/index.js
@@ -0,0 +1,114 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+Object.defineProperty(exports, "Item", {
+  enumerable: true,
+  get: function get() {
+    return _Item["default"];
+  }
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _pick = _interopRequireDefault(require("lodash/pick"));
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../EditorContext");
+
+var _Item = _interopRequireDefault(require("./Item"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var ItemPanel =
+/** @class */
+function () {
+  var ItemPanel = /*#__PURE__*/function (_React$Component) {
+    _inherits(ItemPanel, _React$Component);
+
+    var _super = _createSuper(ItemPanel);
+
+    function ItemPanel() {
+      var _this;
+
+      _classCallCheck(this, ItemPanel);
+
+      _this = _super.apply(this, arguments);
+
+      _this.handleMouseUp = function () {
+        var graph = _this.props.graph;
+
+        if (graph.getCurrentMode() === _constants.GraphMode.Default) {
+          return;
+        }
+
+        var group = graph.get('group');
+        var shape = group.findByClassName(_global["default"].component.itemPanel.delegateShapeClassName);
+
+        if (shape) {
+          shape.remove(true);
+          graph.paint();
+        }
+
+        _global["default"].component.itemPanel.model = null;
+        graph.setMode(_constants.GraphMode.Default);
+      };
+
+      return _this;
+    }
+
+    _createClass(ItemPanel, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        document.addEventListener('mouseup', this.handleMouseUp, false);
+      }
+    }, {
+      key: "componentWillUnmount",
+      value: function componentWillUnmount() {
+        document.removeEventListener('mouseup', this.handleMouseUp, false);
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var children = this.props.children;
+        return /*#__PURE__*/_react["default"].createElement("div", Object.assign({}, (0, _pick["default"])(this.props, ['style', 'className'])), children);
+      }
+    }]);
+
+    return ItemPanel;
+  }(_react["default"].Component);
+
+  ItemPanel.Item = _Item["default"];
+  return ItemPanel;
+}();
+
+var _default = (0, _EditorContext.withEditorContext)(ItemPanel);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Mind/command/fold.js b/node_modules/gg-editor/lib/components/Mind/command/fold.js
new file mode 100644
index 0000000..c7350af
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Mind/command/fold.js
@@ -0,0 +1,60 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _base = require("../../Graph/command/base");
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var foldCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  params: {
+    id: ''
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+
+    if (!selectedNodes.length) {
+      return false;
+    }
+
+    var selectedNode = selectedNodes[0];
+    var selectedNodeModel = selectedNode.getModel(); //@ts-ignore
+
+    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
+      return false;
+    }
+
+    if (selectedNodeModel.collapsed) {
+      return false;
+    }
+
+    return true;
+  },
+  init: function init(graph) {
+    var selectedNode = this.getSelectedNodes(graph)[0];
+    var selectedNodeModel = selectedNode.getModel();
+    this.params = {
+      id: selectedNodeModel.id
+    };
+  },
+  execute: function execute(graph) {
+    var id = this.params.id;
+    var sourceData = graph.findDataById(id);
+    sourceData.collapsed = !sourceData.collapsed;
+    graph.refreshLayout(false);
+  },
+  undo: function undo(graph) {
+    this.execute(graph);
+  },
+  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
+});
+
+var _default = foldCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Mind/command/index.js b/node_modules/gg-editor/lib/components/Mind/command/index.js
new file mode 100644
index 0000000..dff2ea6
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Mind/command/index.js
@@ -0,0 +1,24 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _topic = _interopRequireDefault(require("./topic"));
+
+var _subtopic = _interopRequireDefault(require("./subtopic"));
+
+var _fold = _interopRequireDefault(require("./fold"));
+
+var _unfold = _interopRequireDefault(require("./unfold"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var _default = {
+  topic: _topic["default"],
+  subtopic: _subtopic["default"],
+  fold: _fold["default"],
+  unfold: _unfold["default"]
+};
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Mind/command/subtopic.js b/node_modules/gg-editor/lib/components/Mind/command/subtopic.js
new file mode 100644
index 0000000..d36606e
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Mind/command/subtopic.js
@@ -0,0 +1,37 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _topic = _interopRequireDefault(require("./topic"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var subtopicCommand = _objectSpread(_objectSpread({}, _topic["default"]), {}, {
+  canExecute: function canExecute(graph) {
+    return this.getSelectedNodes(graph)[0] ? true : false;
+  },
+  execute: function execute(graph) {
+    var _this$params = this.params,
+        id = _this$params.id,
+        model = _this$params.model; // 添加节点
+
+    graph.addChild(model, id); // 选中节点
+
+    this.setSelectedItems(graph, [model.id]); // 编辑节点
+
+    this.editSelectedNode(graph);
+  },
+  shortcuts: ['Tab']
+});
+
+var _default = subtopicCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Mind/command/topic.js b/node_modules/gg-editor/lib/components/Mind/command/topic.js
new file mode 100644
index 0000000..5adf85e
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Mind/command/topic.js
@@ -0,0 +1,69 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = exports.topicCommand = void 0;
+
+var _utils = require("../../../utils");
+
+var _constants = require("../../../common/constants");
+
+var _base = require("../../Graph/command/base");
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var topicCommand = _objectSpread(_objectSpread({}, _base.baseCommand), {}, {
+  params: {
+    id: '',
+    model: {
+      id: ''
+    }
+  },
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+    return selectedNodes.length && selectedNodes.length === 1 && selectedNodes[0].get('parent');
+  },
+  init: function init(graph) {
+    if (this.params.id) {
+      return;
+    }
+
+    var selectedNode = this.getSelectedNodes(graph)[0];
+    this.params = {
+      id: selectedNode.get('id'),
+      model: {
+        id: (0, _utils.guid)(),
+        label: _constants.LABEL_DEFAULT_TEXT
+      }
+    };
+  },
+  execute: function execute(graph) {
+    var _this$params = this.params,
+        id = _this$params.id,
+        model = _this$params.model;
+    var parent = graph.findById(id).get('parent'); // 添加节点
+
+    graph.addChild(model, parent); // 选中节点
+
+    this.setSelectedItems(graph, [model.id]); // 编辑节点
+
+    this.editSelectedNode(graph);
+  },
+  undo: function undo(graph) {
+    var _this$params2 = this.params,
+        id = _this$params2.id,
+        model = _this$params2.model;
+    this.setSelectedItems(graph, [id]);
+    graph.removeChild(model.id);
+  },
+  shortcuts: ['Enter']
+});
+
+exports.topicCommand = topicCommand;
+var _default = topicCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Mind/command/unfold.js b/node_modules/gg-editor/lib/components/Mind/command/unfold.js
new file mode 100644
index 0000000..3eae0ec
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Mind/command/unfold.js
@@ -0,0 +1,43 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _fold = _interopRequireDefault(require("./fold"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var unfoldCommand = _objectSpread(_objectSpread({}, _fold["default"]), {}, {
+  canExecute: function canExecute(graph) {
+    var selectedNodes = this.getSelectedNodes(graph);
+
+    if (!selectedNodes.length) {
+      return false;
+    }
+
+    var selectedNode = selectedNodes[0];
+    var selectedNodeModel = selectedNode.getModel(); //@ts-ignore
+
+    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
+      return false;
+    }
+
+    if (!selectedNodeModel.collapsed) {
+      return false;
+    }
+
+    return true;
+  },
+  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
+});
+
+var _default = unfoldCommand;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Mind/index.js b/node_modules/gg-editor/lib/components/Mind/index.js
new file mode 100644
index 0000000..60818db
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Mind/index.js
@@ -0,0 +1,207 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _omit = _interopRequireDefault(require("lodash/omit"));
+
+var _merge = _interopRequireDefault(require("lodash/merge"));
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _utils = require("../../utils");
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _bizMindNode = require("../../shape/nodes/bizMindNode");
+
+var _behaviorManager = _interopRequireDefault(require("../../common/behaviorManager"));
+
+var _Graph = _interopRequireDefault(require("../Graph"));
+
+require("./command");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var Mind =
+/** @class */
+function () {
+  var Mind = /*#__PURE__*/function (_React$Component) {
+    _inherits(Mind, _React$Component);
+
+    var _super = _createSuper(Mind);
+
+    function Mind() {
+      var _this;
+
+      _classCallCheck(this, Mind);
+
+      _this = _super.apply(this, arguments);
+      _this.graph = null;
+      _this.containerId = "".concat(_constants.MIND_CONTAINER_ID, "_").concat((0, _utils.guid)());
+
+      _this.canDragOrZoomCanvas = function () {
+        var _assertThisInitialize = _assertThisInitialized(_this),
+            graph = _assertThisInitialize.graph;
+
+        if (!graph) {
+          return false;
+        }
+
+        return _global["default"].plugin.itemPopover.state === 'hide' && _global["default"].plugin.contextMenu.state === 'hide' && _global["default"].plugin.editableLabel.state === 'hide';
+      };
+
+      _this.canCollapseExpand = function (_ref) {
+        var target = _ref.target;
+        return target && [_bizMindNode.FOLD_BUTTON_CLASS_NAME, _bizMindNode.UNFOLD_BUTTON_CLASS_NAME].includes(target.get('className'));
+      };
+
+      _this.parseData = function (data) {
+        (0, _utils.recursiveTraversal)(data, function (item) {
+          var id = item.id;
+
+          if (id) {
+            return;
+          }
+
+          item.id = (0, _utils.guid)();
+        });
+      };
+
+      _this.initGraph = function (width, height) {
+        var _assertThisInitialize2 = _assertThisInitialized(_this),
+            containerId = _assertThisInitialize2.containerId;
+
+        var _this$props = _this.props,
+            graphConfig = _this$props.graphConfig,
+            customModes = _this$props.customModes;
+        var modes = (0, _merge["default"])(_behaviorManager["default"].getRegisteredBehaviors(_constants.GraphType.Mind), {
+          "default": {
+            'click-item': {
+              type: 'click-item',
+              multiple: false
+            },
+            'collapse-expand': {
+              type: 'collapse-expand',
+              shouldBegin: _this.canCollapseExpand
+            },
+            'drag-canvas': {
+              type: 'drag-canvas',
+              shouldBegin: _this.canDragOrZoomCanvas,
+              shouldUpdate: _this.canDragOrZoomCanvas
+            },
+            'zoom-canvas': {
+              type: 'zoom-canvas',
+              shouldUpdate: _this.canDragOrZoomCanvas
+            }
+          }
+        });
+        Object.keys(modes).forEach(function (mode) {
+          var behaviors = modes[mode];
+          modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
+        });
+        _this.graph = new _g["default"].TreeGraph(_objectSpread({
+          container: containerId,
+          width: width,
+          height: height,
+          modes: modes,
+          layout: {
+            type: 'mindmap',
+            direction: 'H',
+            getWidth: function getWidth() {
+              return 120;
+            },
+            getHeight: function getHeight() {
+              return 60;
+            },
+            getHGap: function getHGap() {
+              return 100;
+            },
+            getVGap: function getVGap() {
+              return 50;
+            },
+            getSide: function getSide(_ref2) {
+              var data = _ref2.data;
+
+              if (data.side) {
+                return data.side;
+              }
+
+              return 'right';
+            }
+          },
+          animate: false,
+          defaultNode: {
+            type: 'bizMindNode'
+          },
+          defaultEdge: {
+            type: 'bizMindEdge'
+          }
+        }, graphConfig));
+        return _this.graph;
+      };
+
+      return _this;
+    }
+
+    _createClass(Mind, [{
+      key: "render",
+      value: function render() {
+        var containerId = this.containerId,
+            parseData = this.parseData,
+            initGraph = this.initGraph;
+        var data = this.props.data;
+        return /*#__PURE__*/_react["default"].createElement(_Graph["default"], Object.assign({
+          containerId: containerId,
+          data: data,
+          parseData: parseData,
+          initGraph: initGraph
+        }, (0, _omit["default"])(this.props, ['graphConfig', 'customModes'])));
+      }
+    }]);
+
+    return Mind;
+  }(_react["default"].Component);
+
+  Mind.defaultProps = {
+    graphConfig: {}
+  };
+  return Mind;
+}();
+
+var _default = Mind;
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/components/Register/index.d.ts b/node_modules/gg-editor/lib/components/Register/index.d.ts
index fa34f14..ee6560f 100644
--- a/node_modules/gg-editor/lib/components/Register/index.d.ts
+++ b/node_modules/gg-editor/lib/components/Register/index.d.ts
@@ -5,8 +5,8 @@ interface RegisterProps extends EditorPrivateContextProps {
     config: object;
     extend?: string;
 }
-export declare const RegisterNode: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "name" | "config" | "extend" | "children"> & React.RefAttributes<unknown>>;
-export declare const RegisterEdge: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "name" | "config" | "extend" | "children"> & React.RefAttributes<unknown>>;
-export declare const RegisterCommand: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "name" | "config" | "extend" | "children"> & React.RefAttributes<unknown>>;
-export declare const RegisterBehavior: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "name" | "config" | "extend" | "children"> & React.RefAttributes<unknown>>;
+export declare const RegisterNode: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export declare const RegisterEdge: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export declare const RegisterCommand: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
+export declare const RegisterBehavior: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<RegisterProps>, "children" | "name" | "config" | "extend"> & React.RefAttributes<unknown>>;
 export {};
diff --git a/node_modules/gg-editor/lib/components/Register/index.js b/node_modules/gg-editor/lib/components/Register/index.js
new file mode 100644
index 0000000..a849b2d
--- /dev/null
+++ b/node_modules/gg-editor/lib/components/Register/index.js
@@ -0,0 +1,124 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.RegisterBehavior = exports.RegisterCommand = exports.RegisterEdge = exports.RegisterNode = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _behaviorManager = _interopRequireDefault(require("../../common/behaviorManager"));
+
+var _EditorContext = require("../EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var Register =
+/** @class */
+function () {
+  var Register = /*#__PURE__*/function (_React$Component) {
+    _inherits(Register, _React$Component);
+
+    var _super = _createSuper(Register);
+
+    function Register(props, type) {
+      var _this;
+
+      _classCallCheck(this, Register);
+
+      _this = _super.call(this, props);
+      var name = props.name,
+          config = props.config,
+          extend = props.extend,
+          commandManager = props.commandManager;
+
+      switch (type) {
+        case 'node':
+          _g["default"].registerNode(name, config, extend);
+
+          break;
+
+        case 'edge':
+          _g["default"].registerEdge(name, config, extend);
+
+          break;
+
+        case 'command':
+          commandManager.register(name, config);
+          break;
+
+        case 'behavior':
+          _behaviorManager["default"].register(name, config);
+
+          break;
+
+        default:
+          break;
+      }
+
+      return _this;
+    }
+
+    _createClass(Register, [{
+      key: "render",
+      value: function render() {
+        return null;
+      }
+    }]);
+
+    return Register;
+  }(_react["default"].Component);
+
+  Register.create = function (type) {
+    var TypedRegister = /*#__PURE__*/function (_Register) {
+      _inherits(TypedRegister, _Register);
+
+      var _super2 = _createSuper(TypedRegister);
+
+      function TypedRegister(props) {
+        _classCallCheck(this, TypedRegister);
+
+        return _super2.call(this, props, type);
+      }
+
+      return TypedRegister;
+    }(Register);
+
+    return (0, _EditorContext.withEditorPrivateContext)(TypedRegister);
+  };
+
+  return Register;
+}();
+
+var RegisterNode = Register.create('node');
+exports.RegisterNode = RegisterNode;
+var RegisterEdge = Register.create('edge');
+exports.RegisterEdge = RegisterEdge;
+var RegisterCommand = Register.create('command');
+exports.RegisterCommand = RegisterCommand;
+var RegisterBehavior = Register.create('behavior');
+exports.RegisterBehavior = RegisterBehavior;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/helpers/index.js b/node_modules/gg-editor/lib/helpers/index.js
new file mode 100644
index 0000000..59e9e81
--- /dev/null
+++ b/node_modules/gg-editor/lib/helpers/index.js
@@ -0,0 +1,39 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.track = track;
+
+var _global = _interopRequireDefault(require("../common/global"));
+
+var _utils = require("../utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var BASE_URL = 'http://gm.mmstat.com/fsp.1.1';
+
+function track(graphType) {
+  var version = _global["default"].version;
+  var trackable = _global["default"].trackable;
+
+  if (!trackable) {
+    return;
+  }
+
+  var _window = window,
+      location = _window.location,
+      navigator = _window.navigator;
+  var image = new Image();
+  var params = (0, _utils.toQueryString)({
+    pid: 'ggeditor',
+    code: '11',
+    msg: 'syslog',
+    page: "".concat(location.protocol, "//").concat(location.host).concat(location.pathname),
+    hash: location.hash,
+    ua: navigator.userAgent,
+    rel: version,
+    c1: graphType
+  });
+  image.src = "".concat(BASE_URL, "?").concat(params);
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/index.js b/node_modules/gg-editor/lib/index.js
index a9d5ecf..7bc0ba9 100644
--- a/node_modules/gg-editor/lib/index.js
+++ b/node_modules/gg-editor/lib/index.js
@@ -1,3834 +1,181 @@
-'use strict';
+"use strict";
 
-Object.defineProperty(exports, '__esModule', { value: true });
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
 
-function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
-
-var G6 = _interopDefault(require('@antv/g6'));
-var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
-var merge = _interopDefault(require('lodash/merge'));
-var isArray = _interopDefault(require('lodash/isArray'));
-var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
-var React = _interopDefault(require('react'));
-var pick = _interopDefault(require('lodash/pick'));
-var cloneDeep = _interopDefault(require('lodash/cloneDeep'));
-var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
-var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
-var omit = _interopDefault(require('lodash/omit'));
-var isPlainObject = _interopDefault(require('lodash/isPlainObject'));
-var ReactDOM = _interopDefault(require('react-dom'));
-var delay = _interopDefault(require('lodash/delay'));
-
-var FLOW_CONTAINER_ID = 'J_FlowContainer';
-var MIND_CONTAINER_ID = 'J_MindContainer';
-var LABEL_DEFAULT_TEXT = '新建节点';
-var RendererType;
-
-(function (RendererType) {
-  RendererType["Canvas"] = "canvas";
-  RendererType["Svg"] = "svg";
-})(RendererType || (RendererType = {}));
-
-var ItemType;
-
-(function (ItemType) {
-  ItemType["Node"] = "node";
-  ItemType["Edge"] = "edge";
-})(ItemType || (ItemType = {}));
-
-var ItemState;
-
-(function (ItemState) {
-  ItemState["Active"] = "active";
-  ItemState["ActiveAnchorPoints"] = "activeAnchorPoints";
-  ItemState["Selected"] = "selected";
-  ItemState["HighLight"] = "highLight";
-  ItemState["Error"] = "error";
-})(ItemState || (ItemState = {}));
-
-var GraphType;
-
-(function (GraphType) {
-  GraphType["Flow"] = "flow";
-  GraphType["Mind"] = "mind";
-})(GraphType || (GraphType = {}));
-
-var GraphMode;
-
-(function (GraphMode) {
-  GraphMode["Default"] = "default";
-  GraphMode["AddNode"] = "addNode";
-  GraphMode["Readonly"] = "readonly";
-})(GraphMode || (GraphMode = {}));
-
-var GraphState;
-
-(function (GraphState) {
-  GraphState["NodeSelected"] = "nodeSelected";
-  GraphState["EdgeSelected"] = "edgeSelected";
-  GraphState["MultiSelected"] = "multiSelected";
-  GraphState["CanvasSelected"] = "canvasSelected";
-})(GraphState || (GraphState = {}));
-
-var LabelState;
-
-(function (LabelState) {
-  LabelState["Hide"] = "hide";
-  LabelState["Show"] = "show";
-})(LabelState || (LabelState = {}));
-
-var AnchorPointState;
-
-(function (AnchorPointState) {
-  AnchorPointState["Enabled"] = "enabled";
-  AnchorPointState["Disabled"] = "disabled";
-})(AnchorPointState || (AnchorPointState = {}));
-
-var EditorEvent;
-
-(function (EditorEvent) {
-  /** 调用命令之前触发 */
-  EditorEvent["onBeforeExecuteCommand"] = "onBeforeExecuteCommand";
-  /** 调用命令之后触发 */
-
-  EditorEvent["onAfterExecuteCommand"] = "onAfterExecuteCommand";
-  /** 改变画面状态触发 */
-
-  EditorEvent["onGraphStateChange"] = "onGraphStateChange";
-  /** 改变标签状态触发 */
-
-  EditorEvent["onLabelStateChange"] = "onLabelStateChange";
-})(EditorEvent || (EditorEvent = {}));
-
-var EditorCommand;
-
-(function (EditorCommand) {
-  /** 撤销 */
-  EditorCommand["Undo"] = "undo";
-  /** 重做 */
-
-  EditorCommand["Redo"] = "redo";
-  /** 添加 */
-
-  EditorCommand["Add"] = "add";
-  /** 更新 */
-
-  EditorCommand["Update"] = "update";
-  /** 删除 */
-
-  EditorCommand["Remove"] = "remove";
-  /** 复制 */
-
-  EditorCommand["Copy"] = "copy";
-  /** 粘贴 */
-
-  EditorCommand["Paste"] = "paste";
-  /** 粘贴到这里 */
-
-  EditorCommand["PasteHere"] = "pasteHere";
-  /** 放大 */
-
-  EditorCommand["ZoomIn"] = "zoomIn";
-  /** 缩小 */
-
-  EditorCommand["ZoomOut"] = "zoomOut";
-  /** 插入主题 */
-
-  EditorCommand["Topic"] = "topic";
-  /** 插入子主题 */
-
-  EditorCommand["Subtopic"] = "subtopic";
-  /** 收起 */
-
-  EditorCommand["Fold"] = "fold";
-  /** 展开 */
-
-  EditorCommand["Unfold"] = "unfold";
-})(EditorCommand || (EditorCommand = {}));
-
-var GraphCommonEvent;
-
-(function (GraphCommonEvent) {
-  /** 单击鼠标左键或者按下回车键时触发 */
-  GraphCommonEvent["onClick"] = "click";
-  /** 双击鼠标左键时触发 */
-
-  GraphCommonEvent["onDoubleClick"] = "dblclick";
-  /** 鼠标移入元素范围内触发，该事件不冒泡，即鼠标移到其后代元素上时不会触发 */
-
-  GraphCommonEvent["onMouseEnter"] = "mouseenter";
-  /** 鼠标在元素内部移到时不断触发，不能通过键盘触发 */
-
-  GraphCommonEvent["onMouseMove"] = "mousemove";
-  /** 鼠标移出目标元素后触发 */
-
-  GraphCommonEvent["onMouseOut"] = "mouseout";
-  /** 鼠标移入目标元素上方，鼠标移到其后代元素上时会触发 */
-
-  GraphCommonEvent["onMouseOver"] = "mouseover";
-  /** 鼠标移出元素范围时触发，该事件不冒泡，即鼠标移到其后代元素时不会触发 */
-
-  GraphCommonEvent["onMouseLeave"] = "mouseleave";
-  /** 鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphCommonEvent["onMouseDown"] = "mousedown";
-  /** 鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphCommonEvent["onMouseUp"] = "mouseup";
-  /** 用户右击鼠标时触发并打开上下文菜单 */
-
-  GraphCommonEvent["onContextMenu"] = "contextmenu";
-  /** 当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上 */
-
-  GraphCommonEvent["onDragStart"] = "dragstart";
-  /** 当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上 */
-
-  GraphCommonEvent["onDrag"] = "drag";
-  /** 当拖拽完成后触发的事件，此事件作用在被拖曳元素上 */
-
-  GraphCommonEvent["onDragEnd"] = "dragend";
-  /** 当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCommonEvent["onDragEnter"] = "dragenter";
-  /** 当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCommonEvent["onDragLeave"] = "dragleave";
-  /** 被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
-
-  GraphCommonEvent["onDrop"] = "drop";
-  /** 按下键盘键触发该事件 */
-
-  GraphCommonEvent["onKeyDown"] = "keydown";
-  /** 释放键盘键触发该事件 */
-
-  GraphCommonEvent["onKeyUp"] = "keyup";
-  /** 当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发 */
-
-  GraphCommonEvent["onTouchStart"] = "touchstart";
-  /** 当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault() 事件可以阻止滚动。 */
-
-  GraphCommonEvent["onTouchMove"] = "touchmove";
-  /** 当手指从屏幕上离开的时候触发 */
-
-  GraphCommonEvent["onTouchEnd"] = "touchend";
-})(GraphCommonEvent || (GraphCommonEvent = {}));
-
-var GraphNodeEvent;
-
-(function (GraphNodeEvent) {
-  /** 鼠标左键单击节点时触发 */
-  GraphNodeEvent["onNodeClick"] = "node:click";
-  /** 鼠标双击左键节点时触发 */
-
-  GraphNodeEvent["onNodeDoubleClick"] = "node:dblclick";
-  /** 鼠标移入节点时触发 */
-
-  GraphNodeEvent["onNodeMouseEnter"] = "node:mouseenter";
-  /** 鼠标在节点内部移到时不断触发，不能通过键盘触发 */
-
-  GraphNodeEvent["onNodeMouseMove"] = "node:mousemove";
-  /** 鼠标移出节点后触发 */
-
-  GraphNodeEvent["onNodeMouseOut"] = "node:mouseout";
-  /** 鼠标移入节点上方时触发 */
-
-  GraphNodeEvent["onNodeMouseOver"] = "node:mouseover";
-  /** 鼠标移出节点时触发 */
-
-  GraphNodeEvent["onNodeMouseLeave"] = "node:mouseleave";
-  /** 鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphNodeEvent["onNodeMouseDown"] = "node:mousedown";
-  /** 节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphNodeEvent["onNodeMouseUp"] = "node:mouseup";
-  /** 用户在节点上右击鼠标时触发并打开右键菜单 */
-
-  GraphNodeEvent["onNodeContextMenu"] = "node:contextmenu";
-  /** 当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上 */
-
-  GraphNodeEvent["onNodeDragStart"] = "node:dragstart";
-  /** 当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上 */
-
-  GraphNodeEvent["onNodeDrag"] = "node:drag";
-  /** 当拖拽完成后触发的事件，此事件作用在被拖曳节点上 */
-
-  GraphNodeEvent["onNodeDragEnd"] = "node:dragend";
-  /** 当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphNodeEvent["onNodeDragEnter"] = "node:dragenter";
-  /** 当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphNodeEvent["onNodeDragLeave"] = "node:dragleave";
-  /** 被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上 */
-
-  GraphNodeEvent["onNodeDrop"] = "node:drop";
-})(GraphNodeEvent || (GraphNodeEvent = {}));
-
-var GraphEdgeEvent;
-
-(function (GraphEdgeEvent) {
-  /** 鼠标左键单击边时触发 */
-  GraphEdgeEvent["onEdgeClick"] = "edge:click";
-  /** 鼠标双击左键边时触发 */
-
-  GraphEdgeEvent["onEdgeDoubleClick"] = "edge:dblclick";
-  /** 鼠标移入边时触发 */
-
-  GraphEdgeEvent["onEdgeMouseEnter"] = "edge:mouseenter";
-  /** 鼠标在边上移到时不断触发，不能通过键盘触发 */
-
-  GraphEdgeEvent["onEdgeMouseMove"] = "edge:mousemove";
-  /** 鼠标移出边后触发 */
-
-  GraphEdgeEvent["onEdgeMouseOut"] = "edge:mouseout";
-  /** 鼠标移入边上方时触发 */
-
-  GraphEdgeEvent["onEdgeMouseOver"] = "edge:mouseover";
-  /** 鼠标移出边时触发 */
-
-  GraphEdgeEvent["onEdgeMouseLeave"] = "edge:mouseleave";
-  /** 鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphEdgeEvent["onEdgeMouseDown"] = "edge:mousedown";
-  /** 边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphEdgeEvent["onEdgeMouseUp"] = "edge:mouseup";
-  /** 用户在边上右击鼠标时触发并打开右键菜单 */
-
-  GraphEdgeEvent["onEdgeContextMenu"] = "edge:contextmenu";
-})(GraphEdgeEvent || (GraphEdgeEvent = {}));
-
-var GraphCanvasEvent;
-
-(function (GraphCanvasEvent) {
-  /** 鼠标左键单击画布时触发 */
-  GraphCanvasEvent["onCanvasClick"] = "canvas:click";
-  /** 鼠标双击左键画布时触发 */
-
-  GraphCanvasEvent["onCanvasDoubleClick"] = "canvas:dblclick";
-  /** 鼠标移入画布时触发 */
-
-  GraphCanvasEvent["onCanvasMouseEnter"] = "canvas:mouseenter";
-  /** 鼠标在画布内部移到时不断触发，不能通过键盘触发 */
-
-  GraphCanvasEvent["onCanvasMouseMove"] = "canvas:mousemove";
-  /** 鼠标移出画布后触发 */
-
-  GraphCanvasEvent["onCanvasMouseOut"] = "canvas:mouseout";
-  /** 鼠标移入画布上方时触发 */
-
-  GraphCanvasEvent["onCanvasMouseOver"] = "canvas:mouseover";
-  /** 鼠标移出画布时触发 */
-
-  GraphCanvasEvent["onCanvasMouseLeave"] = "canvas:mouseleave";
-  /** 鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发 */
-
-  GraphCanvasEvent["onCanvasMouseDown"] = "canvas:mousedown";
-  /** 画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发 */
-
-  GraphCanvasEvent["onCanvasMouseUp"] = "canvas:mouseup";
-  /** 用户在画布上右击鼠标时触发并打开右键菜单 */
-
-  GraphCanvasEvent["onCanvasContextMenu"] = "canvas:contextmenu";
-  /** 当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上 */
-
-  GraphCanvasEvent["onCanvasDragStart"] = "canvas:dragstart";
-  /** 当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上 */
-
-  GraphCanvasEvent["onCanvasDrag"] = "canvas:drag";
-  /** 当拖拽完成后触发的事件，此事件作用在被拖曳画布上 */
-
-  GraphCanvasEvent["onCanvasDragEnd"] = "canvas:dragend";
-  /** 当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCanvasEvent["onCanvasDragEnter"] = "canvas:dragenter";
-  /** 当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标元素上 */
-
-  GraphCanvasEvent["onCanvasDragLeave"] = "canvas:dragleave";
-})(GraphCanvasEvent || (GraphCanvasEvent = {}));
-
-var GraphCustomEvent;
-
-(function (GraphCustomEvent) {
-  /** 调用 add / addItem 方法之前触发 */
-  GraphCustomEvent["onBeforeAddItem"] = "beforeadditem";
-  /** 调用 add / addItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterAddItem"] = "afteradditem";
-  /** 调用 remove / removeItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeRemoveItem"] = "beforeremoveitem";
-  /** 调用 remove / removeItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterRemoveItem"] = "afterremoveitem";
-  /** 调用 update / updateItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeUpdateItem"] = "beforeupdateitem";
-  /** 调用 update / updateItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterUpdateItem"] = "afterupdateitem";
-  /** 调用 showItem / hideItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeItemVisibilityChange"] = "beforeitemvisibilitychange";
-  /** 调用 showItem / hideItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterItemVisibilityChange"] = "afteritemvisibilitychange";
-  /** 调用 setItemState 方法之前触发 */
-
-  GraphCustomEvent["onBeforeItemStateChange"] = "beforeitemstatechange";
-  /** 调用 setItemState 方法之后触发 */
-
-  GraphCustomEvent["onAfterItemStateChange"] = "afteritemstatechange";
-  /** 调用 refreshItem 方法之前触发 */
-
-  GraphCustomEvent["onBeforeRefreshItem"] = "beforerefreshitem";
-  /** 调用 refreshItem 方法之后触发 */
-
-  GraphCustomEvent["onAfterRefreshItem"] = "afterrefreshitem";
-  /** 调用 clearItemStates 方法之前触发 */
-
-  GraphCustomEvent["onBeforeItemStatesClear"] = "beforeitemstatesclear";
-  /** 调用 clearItemStates 方法之后触发 */
-
-  GraphCustomEvent["onAfterItemStatesClear"] = "afteritemstatesclear";
-  /** 布局前触发。调用 render 时会进行布局，因此 render 时会触发。或用户主动调用图的 layout 时触发 */
-
-  GraphCustomEvent["onBeforeLayout"] = "beforelayout";
-  /** 布局完成后触发。调用 render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 layout 时布局完成后触发 */
-
-  GraphCustomEvent["onAfterLayout"] = "afterlayout";
-  /** 连线完成之前触发 */
-
-  GraphCustomEvent["onBeforeConnect"] = "beforeconnect";
-  /** 连线完成之后触发 */
-
-  GraphCustomEvent["onAfterConnect"] = "afterconnect";
-})(GraphCustomEvent || (GraphCustomEvent = {}));
-
-var index = /*#__PURE__*/Object.freeze({
-  __proto__: null,
-  FLOW_CONTAINER_ID: FLOW_CONTAINER_ID,
-  MIND_CONTAINER_ID: MIND_CONTAINER_ID,
-  LABEL_DEFAULT_TEXT: LABEL_DEFAULT_TEXT,
-  get RendererType () { return RendererType; },
-  get ItemType () { return ItemType; },
-  get ItemState () { return ItemState; },
-  get GraphType () { return GraphType; },
-  get GraphMode () { return GraphMode; },
-  get GraphState () { return GraphState; },
-  get LabelState () { return LabelState; },
-  get AnchorPointState () { return AnchorPointState; },
-  get EditorEvent () { return EditorEvent; },
-  get EditorCommand () { return EditorCommand; },
-  get GraphCommonEvent () { return GraphCommonEvent; },
-  get GraphNodeEvent () { return GraphNodeEvent; },
-  get GraphEdgeEvent () { return GraphEdgeEvent; },
-  get GraphCanvasEvent () { return GraphCanvasEvent; },
-  get GraphCustomEvent () { return GraphCustomEvent; }
+Object.defineProperty(exports, "__esModule", {
+  value: true
 });
-
-function _createForOfIteratorHelperLoose(o) { var i = 0; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } i = o[Symbol.iterator](); return i.next.bind(i); }
-
-function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
-
-function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
-
-var canvas = document.createElement('canvas');
-var canvasContext = canvas.getContext('2d');
-function getNodeSide(item) {
-  var model = item.getModel();
-
-  if (model.side) {
-    return model.side;
+Object.defineProperty(exports, "G6", {
+  enumerable: true,
+  get: function get() {
+    return _g["default"];
   }
-
-  var parent = item.get('parent');
-
-  if (parent) {
-    return getNodeSide(parent);
-  }
-
-  return 'right';
-}
-function getRectPath(x, y, w, h, r) {
-  if (r) {
-    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
-  }
-
-  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
-  res.toString = toString;
-  return res;
-}
-function getFoldButtonPath() {
-  var w = 14;
-  var h = 14;
-  var rect = getRectPath(0, 0, w, h, 2);
-  var hp = "M" + w * 3 / 14 + "," + h / 2 + "L" + w * 11 / 14 + "," + h / 2;
-  var vp = '';
-  return rect + hp + vp;
-}
-function getUnfoldButtonPath() {
-  var w = 14;
-  var h = 14;
-  var rect = getRectPath(0, 0, w, h, 2);
-  var hp = "M" + w * 3 / 14 + "," + h / 2 + "L" + w * 11 / 14 + "," + h / 2;
-  var vp = "M" + w / 2 + "," + h * 3 / 14 + "L" + w / 2 + "," + h * 11 / 14;
-  return rect + hp + vp;
-}
-function optimizeMultilineText(text, font, maxRows, maxWidth) {
-  canvasContext.font = font;
-
-  if (canvasContext.measureText(text).width <= maxWidth) {
-    return text;
-  }
-
-  var multilineText = [];
-  var tempText = '';
-  var tempTextWidth = 0;
-
-  for (var _iterator = _createForOfIteratorHelperLoose(text), _step; !(_step = _iterator()).done;) {
-    var _char2 = _step.value;
-
-    var _canvasContext$measur2 = canvasContext.measureText(_char2),
-        _width = _canvasContext$measur2.width;
-
-    if (tempTextWidth + _width >= maxWidth) {
-      multilineText.push(tempText);
-      tempText = '';
-      tempTextWidth = 0;
-    }
-
-    tempText += _char2;
-    tempTextWidth += _width;
-  }
-
-  if (tempText) {
-    multilineText.push(tempText);
-  }
-
-  if (multilineText.length > maxRows) {
-    var ellipsis = '...';
-    var ellipsisWidth = canvasContext.measureText(ellipsis).width;
-    var _tempText = '';
-    var _tempTextWidth = 0;
-
-    for (var _iterator2 = _createForOfIteratorHelperLoose(multilineText[maxRows - 1]), _step2; !(_step2 = _iterator2()).done;) {
-      var _char = _step2.value;
-
-      var _canvasContext$measur = canvasContext.measureText(_char),
-          width = _canvasContext$measur.width;
-
-      if (_tempTextWidth + width > maxWidth - ellipsisWidth) {
-        break;
-      }
-
-      _tempText += _char;
-      _tempTextWidth += width;
-    }
-
-    multilineText = multilineText.slice(0, maxRows - 1).concat("" + _tempText + ellipsis);
-  }
-
-  return multilineText.join('\n');
-}
-
-var _stateStyles;
-var WRAPPER_BORDER_WIDTH = 2;
-var WRAPPER_HORIZONTAL_PADDING = 10;
-var WRAPPER_CLASS_NAME = 'node-wrapper';
-var CONTENT_CLASS_NAME = 'node-content';
-var LABEL_CLASS_NAME = 'node-label';
-var bizNode = {
-  options: {
-    size: [120, 60],
-    wrapperStyle: {
-      fill: '#5487ea',
-      radius: 8
-    },
-    contentStyle: {
-      fill: '#ffffff',
-      radius: 6
-    },
-    labelStyle: {
-      fill: '#000000',
-      textAlign: 'center',
-      textBaseline: 'middle'
-    },
-    stateStyles: (_stateStyles = {}, _stateStyles[ItemState.Active] = {
-      wrapperStyle: {},
-      contentStyle: {},
-      labelStyle: {}
-    }, _stateStyles[ItemState.Selected] = {
-      wrapperStyle: {},
-      contentStyle: {},
-      labelStyle: {}
-    }, _stateStyles)
-  },
-  getOptions: function getOptions(model) {
-    return merge({}, this.options, this.getCustomConfig(model) || {}, model);
-  },
-  draw: function draw(model, group) {
-    var keyShape = this.drawWrapper(model, group);
-    this.drawContent(model, group);
-    this.drawLabel(model, group);
-    return keyShape;
-  },
-  drawWrapper: function drawWrapper(model, group) {
-    var _this$getSize = this.getSize(model),
-        width = _this$getSize[0],
-        height = _this$getSize[1];
-
-    var _this$getOptions = this.getOptions(model),
-        wrapperStyle = _this$getOptions.wrapperStyle;
-
-    var shape = group.addShape('rect', {
-      className: WRAPPER_CLASS_NAME,
-      draggable: true,
-      attrs: _extends({
-        x: 0,
-        y: -WRAPPER_BORDER_WIDTH * 2,
-        width: width,
-        height: height + WRAPPER_BORDER_WIDTH * 2
-      }, wrapperStyle)
-    });
-    return shape;
-  },
-  drawContent: function drawContent(model, group) {
-    var _this$getSize2 = this.getSize(model),
-        width = _this$getSize2[0],
-        height = _this$getSize2[1];
-
-    var _this$getOptions2 = this.getOptions(model),
-        contentStyle = _this$getOptions2.contentStyle;
-
-    var shape = group.addShape('rect', {
-      className: CONTENT_CLASS_NAME,
-      draggable: true,
-      attrs: _extends({
-        x: 0,
-        y: 0,
-        width: width,
-        height: height
-      }, contentStyle)
-    });
-    return shape;
-  },
-  drawLabel: function drawLabel(model, group) {
-    var _this$getSize3 = this.getSize(model),
-        width = _this$getSize3[0],
-        height = _this$getSize3[1];
-
-    var _this$getOptions3 = this.getOptions(model),
-        labelStyle = _this$getOptions3.labelStyle;
-
-    var shape = group.addShape('text', {
-      className: LABEL_CLASS_NAME,
-      draggable: true,
-      attrs: _extends({
-        x: width / 2,
-        y: height / 2,
-        text: model.label
-      }, labelStyle)
-    });
-    return shape;
-  },
-  setLabelText: function setLabelText(model, group) {
-    var shape = group.findByClassName(LABEL_CLASS_NAME);
-
-    if (!shape) {
-      return;
-    }
-
-    var _this$getSize4 = this.getSize(model),
-        width = _this$getSize4[0];
-
-    var _shape$attr = shape.attr(),
-        fontStyle = _shape$attr.fontStyle,
-        fontWeight = _shape$attr.fontWeight,
-        fontSize = _shape$attr.fontSize,
-        fontFamily = _shape$attr.fontFamily;
-
-    var text = model.label;
-    var font = fontStyle + " " + fontWeight + " " + fontSize + "px " + fontFamily;
-    shape.attr('text', optimizeMultilineText(text, font, 2, width - WRAPPER_HORIZONTAL_PADDING * 2));
-  },
-  update: function update(model, item) {
-    var group = item.getContainer();
-    this.setLabelText(model, group);
-  },
-  setState: function setState(name, value, item) {
-    var _this = this;
-
-    var group = item.getContainer();
-    var model = item.getModel();
-    var states = item.getStates();
-    [WRAPPER_CLASS_NAME, CONTENT_CLASS_NAME, LABEL_CLASS_NAME].forEach(function (className) {
-      var shape = group.findByClassName(className);
-
-      var options = _this.getOptions(model);
-
-      var shapeName = className.split('-')[1];
-      shape.attr(_extends({}, options[shapeName + "Style"]));
-      states.forEach(function (state) {
-        if (options.stateStyles[state] && options.stateStyles[state][shapeName + "Style"]) {
-          shape.attr(_extends({}, options.stateStyles[state][shapeName + "Style"]));
-        }
-      });
-    });
-
-    if (name === ItemState.Selected) {
-      var wrapperShape = group.findByClassName(WRAPPER_CLASS_NAME);
-
-      var _this$getSize5 = this.getSize(model),
-          width = _this$getSize5[0],
-          height = _this$getSize5[1];
-
-      if (value) {
-        wrapperShape.attr({
-          x: -WRAPPER_BORDER_WIDTH,
-          y: -WRAPPER_BORDER_WIDTH * 2,
-          width: width + WRAPPER_BORDER_WIDTH * 2,
-          height: height + WRAPPER_BORDER_WIDTH * 3
-        });
-      } else {
-        wrapperShape.attr({
-          x: 0,
-          y: -WRAPPER_BORDER_WIDTH * 2,
-          width: width,
-          height: height + WRAPPER_BORDER_WIDTH * 2
-        });
-      }
-    }
-
-    if (this.afterSetState) {
-      this.afterSetState(name, value, item);
-    }
-  },
-  getSize: function getSize(model) {
-    var _this$getOptions4 = this.getOptions(model),
-        size = _this$getOptions4.size;
-
-    if (!isArray(size)) {
-      return [size, size];
-    }
-
-    return size;
-  },
-  getCustomConfig: function getCustomConfig() {
-    return {};
-  },
-  getAnchorPoints: function getAnchorPoints() {
-    return [];
+});
+Object.defineProperty(exports, "Flow", {
+  enumerable: true,
+  get: function get() {
+    return _Flow["default"];
   }
-};
-G6.registerNode('bizNode', bizNode);
-
-var ANCHOR_POINT_NAME = 'anchorPoint';
-
-var getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {
-  var _item$getKeyShape$get = item.getKeyShape().getBBox(),
-      width = _item$getKeyShape$get.width,
-      height = _item$getKeyShape$get.height;
-
-  var x = anchorPoint[0],
-      y = anchorPoint[1];
-  return {
-    x: width * x,
-    y: height * y - 3,
-    r: 3,
-    lineWidth: 2,
-    fill: '#FFFFFF',
-    stroke: '#5AAAFF'
-  };
-};
-
-var getAnchorPointDefaultDisabledStyle = function getAnchorPointDefaultDisabledStyle(item, anchorPoint) {
-  var _item$getKeyShape$get2 = item.getKeyShape().getBBox(),
-      width = _item$getKeyShape$get2.width,
-      height = _item$getKeyShape$get2.height;
-
-  var x = anchorPoint[0],
-      y = anchorPoint[1];
-  return {
-    img: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0xLjUxNSAxLjE3Mmw1LjY1NyA1LjY1Nm0wLTUuNjU2TDEuNTE1IDYuODI4IiBzdHJva2U9IiNGRjYwNjAiIHN0cm9rZS13aWR0aD0iMS42IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIi8+PC9zdmc+',
-    x: width * x - 4,
-    y: height * y - 8,
-    width: 8,
-    height: 8
-  };
-};
-
-function drawAnchorPoints(item, getAnchorPointStyle, getAnchorPointDisabledStyle) {
-  var group = item.getContainer();
-  var model = item.getModel();
-  var anchorPoints = this.getAnchorPoints ? this.getAnchorPoints(model) : [];
-  var anchorPointsState = item.get('anchorPointsState') || [];
-  anchorPoints.forEach(function (anchorPoint, index) {
-    if (anchorPointsState[index] === AnchorPointState.Enabled) {
-      group.addShape('circle', {
-        name: ANCHOR_POINT_NAME,
-        attrs: _extends({}, getAnchorPointDefaultStyle(item, anchorPoint), {}, getAnchorPointStyle(item, anchorPoint)),
-        isAnchorPoint: true,
-        anchorPointIndex: index,
-        anchorPointState: AnchorPointState.Enabled
-      });
-    } else {
-      group.addShape('image', {
-        name: ANCHOR_POINT_NAME,
-        attrs: _extends({}, getAnchorPointDefaultDisabledStyle(item, anchorPoint), {}, getAnchorPointDisabledStyle(item, anchorPoint)),
-        isAnchorPoint: true,
-        anchorPointIndex: index,
-        anchorPointState: AnchorPointState.Disabled
-      });
-    }
-  });
-}
-
-function removeAnchorPoints(item) {
-  var group = item.getContainer();
-  var anchorPoints = group.findAllByName(ANCHOR_POINT_NAME);
-  anchorPoints.forEach(function (anchorPoint) {
-    group.removeChild(anchorPoint);
-  });
-}
-
-function setAnchorPointsState(name, value, item, getAnchorPointStyle, getAnchorPointDisabledStyle) {
-  if (getAnchorPointStyle === void 0) {
-    getAnchorPointStyle = function getAnchorPointStyle() {
-      return {};
-    };
+});
+Object.defineProperty(exports, "Mind", {
+  enumerable: true,
+  get: function get() {
+    return _Mind["default"];
   }
-
-  if (getAnchorPointDisabledStyle === void 0) {
-    getAnchorPointDisabledStyle = function getAnchorPointDisabledStyle() {
-      return {};
-    };
+});
+Object.defineProperty(exports, "Command", {
+  enumerable: true,
+  get: function get() {
+    return _Command["default"];
   }
-
-  if (name !== ItemState.ActiveAnchorPoints) {
-    return;
+});
+Object.defineProperty(exports, "ItemPanel", {
+  enumerable: true,
+  get: function get() {
+    return _ItemPanel["default"];
   }
-
-  if (value) {
-    drawAnchorPoints.call(this, item, getAnchorPointStyle, getAnchorPointDisabledStyle);
-  } else {
-    removeAnchorPoints.call(this, item);
+});
+Object.defineProperty(exports, "Item", {
+  enumerable: true,
+  get: function get() {
+    return _ItemPanel.Item;
   }
-}
-
-var bizFlowNode = {
-  afterSetState: function afterSetState(name, value, item) {
-    setAnchorPointsState.call(this, name, value, item);
-  },
-  getAnchorPoints: function getAnchorPoints() {
-    return [[0.5, 0], [0.5, 1], [0, 0.5], [1, 0.5]];
+});
+Object.defineProperty(exports, "DetailPanel", {
+  enumerable: true,
+  get: function get() {
+    return _DetailPanel["default"];
   }
-};
-G6.registerNode('bizFlowNode', bizFlowNode, 'bizNode');
-
-var FOLD_BUTTON_CLASS_NAME = 'node-fold-button';
-var UNFOLD_BUTTON_CLASS_NAME = 'node-unfold-button';
-var bizMindNode = {
-  afterDraw: function afterDraw(model, group) {
-    this.drawButton(model, group);
-  },
-  afterUpdate: function afterUpdate(model, item) {
-    var group = item.getContainer();
-    this.drawButton(model, group);
-    this.adjustButton(model, item);
-  },
-  drawButton: function drawButton(model, group) {
-    var children = model.children,
-        collapsed = model.collapsed;
-    [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].forEach(function (className) {
-      var shape = group.findByClassName(className);
-
-      if (shape) {
-        shape.destroy();
-      }
-    });
-
-    if (!children || !children.length) {
-      return;
-    }
-
-    if (!collapsed) {
-      group.addShape('path', {
-        className: FOLD_BUTTON_CLASS_NAME,
-        attrs: {
-          path: getFoldButtonPath(),
-          fill: '#ffffff',
-          stroke: '#ccc1d8'
-        }
-      });
-    } else {
-      group.addShape('path', {
-        className: UNFOLD_BUTTON_CLASS_NAME,
-        attrs: {
-          path: getUnfoldButtonPath(),
-          fill: '#ffffff',
-          stroke: '#ccc1d8'
-        }
-      });
-    }
-  },
-  adjustButton: function adjustButton(model, item) {
-    var children = model.children,
-        collapsed = model.collapsed;
-
-    if (!children || !children.length) {
-      return;
-    }
-
-    var group = item.getContainer();
-    var shape = group.findByClassName(!collapsed ? FOLD_BUTTON_CLASS_NAME : UNFOLD_BUTTON_CLASS_NAME);
-
-    var _this$getSize = this.getSize(model),
-        width = _this$getSize[0],
-        height = _this$getSize[1];
-
-    var x = getNodeSide(item) === 'left' ? -24 : width + 10;
-    var y = height / 2 - 9;
-    shape.translate(x, y);
-  },
-  getAnchorPoints: function getAnchorPoints() {
-    return [[0, 0.5], [1, 0.5]];
+});
+Object.defineProperty(exports, "RegisterNode", {
+  enumerable: true,
+  get: function get() {
+    return _Register.RegisterNode;
   }
-};
-G6.registerNode('bizMindNode', bizMindNode, 'bizNode');
-
-var _stateStyles$1;
-var EDGE_LABEL_CLASS_NAME = 'edge-label';
-var EDGE_LABEL_WRAPPER_CLASS_NAME = 'edge-label-wrapper-label';
-var bizFlowEdge = {
-  options: {
-    style: {
-      stroke: '#ccc1d8',
-      lineWidth: 2,
-      shadowColor: null,
-      shadowBlur: 0,
-      radius: 8,
-      offset: 24,
-      // startArrow: {
-      //   path: 'M 3,0 A 3,3,0,1,1,-3,0 A 3,3,0,1,1,3,0 Z',
-      //   d: 7,
-      // },
-      // endArrow: {
-      //   path: 'M 3,0 L -3,-3 L -3,3 Z',
-      //   d: 5,
-      // },
-      endArrow: {
-        path: 'M 0,0 L 4,3 L 4,-3 Z'
-      }
-    },
-    labelCfg: {
-      style: {
-        fill: '#000000',
-        fontSize: 10
-      }
-    },
-    stateStyles: (_stateStyles$1 = {}, _stateStyles$1[ItemState.Selected] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$1[ItemState.HighLight] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$1)
-  },
-  createLabelWrapper: function createLabelWrapper(group) {
-    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
-    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
-
-    if (!label) {
-      return;
-    }
-
-    if (labelWrapper) {
-      return;
-    }
-
-    group.addShape('rect', {
-      className: EDGE_LABEL_WRAPPER_CLASS_NAME,
-      attrs: {
-        fill: '#e1e5e8',
-        radius: 2
-      }
-    });
-    label.set('zIndex', 1);
-    group.sort();
-  },
-  updateLabelWrapper: function updateLabelWrapper(group) {
-    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
-    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
-
-    if (!label) {
-      labelWrapper && labelWrapper.hide();
-      return;
-    } else {
-      labelWrapper && labelWrapper.show();
-    }
-
-    if (!labelWrapper) {
-      return;
-    }
-
-    var _label$getBBox = label.getBBox(),
-        minX = _label$getBBox.minX,
-        minY = _label$getBBox.minY,
-        width = _label$getBBox.width,
-        height = _label$getBBox.height;
-
-    labelWrapper.attr({
-      x: minX - 5,
-      y: minY - 3,
-      width: width + 10,
-      height: height + 6
-    });
-  },
-  afterDraw: function afterDraw(model, group) {
-    this.createLabelWrapper(group);
-    this.updateLabelWrapper(group);
-  },
-  afterUpdate: function afterUpdate(model, item) {
-    var group = item.getContainer();
-    this.createLabelWrapper(group);
-    this.updateLabelWrapper(group);
-  },
-  setState: function setState(name, value, item) {
-    var shape = item.get('keyShape');
-
-    if (!shape) {
-      return;
-    }
-
-    var _this$options = this.options,
-        style = _this$options.style,
-        stateStyles = _this$options.stateStyles;
-    var stateStyle = stateStyles[name];
-
-    if (!stateStyle) {
-      return;
-    }
-
-    if (value) {
-      shape.attr(_extends({}, style, {}, stateStyle));
-    } else {
-      shape.attr(style);
-    }
+});
+Object.defineProperty(exports, "RegisterEdge", {
+  enumerable: true,
+  get: function get() {
+    return _Register.RegisterEdge;
   }
-};
-G6.registerEdge('bizFlowEdge', bizFlowEdge, 'polyline');
-
-var _stateStyles$2;
-var bizMindEdge = {
-  options: {
-    style: {
-      stroke: '#ccc1d8',
-      lineWidth: 2,
-      shadowColor: null,
-      shadowBlur: 0
-    },
-    stateStyles: (_stateStyles$2 = {}, _stateStyles$2[ItemState.Selected] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$2[ItemState.HighLight] = {
-      stroke: '#5aaaff',
-      shadowColor: '#5aaaff',
-      shadowBlur: 24
-    }, _stateStyles$2)
+});
+Object.defineProperty(exports, "RegisterCommand", {
+  enumerable: true,
+  get: function get() {
+    return _Register.RegisterCommand;
   }
-};
-G6.registerEdge('bizMindEdge', bizMindEdge, 'cubic-horizontal');
-
-/** 生成唯一标识 */
-
-function guid() {
-  return 'xxxxxxxx'.replace(/[xy]/g, function (c) {
-    var r = Math.random() * 16 | 0;
-    var v = c === 'x' ? r : r & 0x3 | 0x8;
-    return v.toString(16);
-  });
-}
-/** 拼接查询字符 */
-
-var toQueryString = function toQueryString(obj) {
-  return Object.keys(obj).map(function (key) {
-    return encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]);
-  }).join('&');
-};
-/** 执行批量处理 */
-
-function executeBatch(graph, execute) {
-  var autoPaint = graph.get('autoPaint');
-  graph.setAutoPaint(false);
-  execute();
-  graph.paint();
-  graph.setAutoPaint(autoPaint);
-}
-/** 执行递归遍历 */
-
-function recursiveTraversal(root, callback) {
-  if (!root) {
-    return;
+});
+Object.defineProperty(exports, "RegisterBehavior", {
+  enumerable: true,
+  get: function get() {
+    return _Register.RegisterBehavior;
   }
-
-  callback(root);
-
-  if (!root.children) {
-    return;
+});
+Object.defineProperty(exports, "withEditorContext", {
+  enumerable: true,
+  get: function get() {
+    return _EditorContext.withEditorContext;
   }
-
-  root.children.forEach(function (item) {
-    return recursiveTraversal(item, callback);
-  });
-}
-/** 判断是否流程图 */
-
-function isFlow(graph) {
-  return graph.constructor === G6.Graph;
-}
-/** 判断是否脑图 */
-
-function isMind(graph) {
-  return graph.constructor === G6.TreeGraph;
-}
-/** 判断是否节点 */
-
-function isNode(item) {
-  return item.getType() === ItemType.Node;
-}
-/** 判断是否边线 */
-
-function isEdge(item) {
-  return item.getType() === ItemType.Edge;
-}
-/** 获取选中节点 */
-
-function getSelectedNodes(graph) {
-  return graph.findAllByState(ItemType.Node, ItemState.Selected);
-}
-/** 获取选中边线 */
-
-function getSelectedEdges(graph) {
-  return graph.findAllByState(ItemType.Edge, ItemState.Selected);
-}
-/** 获取高亮边线 */
-
-function getHighlightEdges(graph) {
-  return graph.findAllByState(ItemType.Edge, ItemState.HighLight);
-}
-/** 获取图表状态 */
-
-function getGraphState(graph) {
-  var graphState = GraphState.MultiSelected;
-  var selectedNodes = getSelectedNodes(graph);
-  var selectedEdges = getSelectedEdges(graph);
-
-  if (selectedNodes.length === 1 && !selectedEdges.length) {
-    graphState = GraphState.NodeSelected;
+});
+Object.defineProperty(exports, "baseCommand", {
+  enumerable: true,
+  get: function get() {
+    return _base.baseCommand;
   }
-
-  if (selectedEdges.length === 1 && !selectedNodes.length) {
-    graphState = GraphState.EdgeSelected;
+});
+Object.defineProperty(exports, "ItemPopover", {
+  enumerable: true,
+  get: function get() {
+    return _ItemPopover["default"];
   }
-
-  if (!selectedNodes.length && !selectedEdges.length) {
-    graphState = GraphState.CanvasSelected;
+});
+Object.defineProperty(exports, "ContextMenu", {
+  enumerable: true,
+  get: function get() {
+    return _ContextMenu["default"];
   }
-
-  return graphState;
-}
-/** 设置选中元素 */
-
-function setSelectedItems(graph, items) {
-  executeBatch(graph, function () {
-    var selectedNodes = getSelectedNodes(graph);
-    var selectedEdges = getSelectedEdges(graph);
-    [].concat(selectedNodes, selectedEdges).forEach(function (node) {
-      graph.setItemState(node, ItemState.Selected, false);
-    });
-    items.forEach(function (item) {
-      graph.setItemState(item, ItemState.Selected, true);
-    });
-  });
-  graph.emit(EditorEvent.onGraphStateChange, {
-    graphState: getGraphState(graph)
-  });
-}
-/** 清除选中状态 */
-
-function clearSelectedState(graph, shouldUpdate) {
-  if (shouldUpdate === void 0) {
-    shouldUpdate = function shouldUpdate() {
-      return true;
-    };
+});
+Object.defineProperty(exports, "EditableLabel", {
+  enumerable: true,
+  get: function get() {
+    return _EditableLabel["default"];
   }
-
-  var selectedNodes = getSelectedNodes(graph);
-  var selectedEdges = getSelectedEdges(graph);
-  executeBatch(graph, function () {
-    [].concat(selectedNodes, selectedEdges).forEach(function (item) {
-      if (shouldUpdate(item)) {
-        graph.setItemState(item, ItemState.Selected, false);
-      }
-    });
-  });
-}
-/** 获取回溯路径 - Flow */
-
-function getFlowRecallEdges(graph, node, targetIds, edges) {
-  if (targetIds === void 0) {
-    targetIds = [];
+});
+Object.defineProperty(exports, "global", {
+  enumerable: true,
+  get: function get() {
+    return _global["default"];
   }
-
-  if (edges === void 0) {
-    edges = [];
+});
+Object.defineProperty(exports, "CommandManager", {
+  enumerable: true,
+  get: function get() {
+    return _CommandManager["default"];
   }
-
-  var inEdges = node.getInEdges();
-
-  if (!inEdges.length) {
-    return [];
+});
+Object.defineProperty(exports, "behaviorManager", {
+  enumerable: true,
+  get: function get() {
+    return _behaviorManager["default"];
   }
-
-  inEdges.map(function (edge) {
-    var sourceId = edge.getModel().source;
-    var sourceNode = graph.findById(sourceId);
-    edges.push(edge);
-    var targetId = node.get('id');
-    targetIds.push(targetId);
-
-    if (!targetIds.includes(sourceId)) {
-      getFlowRecallEdges(graph, sourceNode, targetIds, edges);
-    }
-  });
-  return edges;
-}
-/** 获取回溯路径 - Mind */
-
-function getMindRecallEdges(graph, node, edges) {
-  if (edges === void 0) {
-    edges = [];
+});
+Object.defineProperty(exports, "setAnchorPointsState", {
+  enumerable: true,
+  get: function get() {
+    return _anchor.setAnchorPointsState;
   }
+});
+exports.constants = exports.Util = exports["default"] = void 0;
 
-  var parentNode = node.get('parent');
+var _g = _interopRequireDefault(require("@antv/g6"));
 
-  if (!parentNode) {
-    return edges;
-  }
-
-  node.getEdges().forEach(function (edge) {
-    var sourceId = edge.getModel().source;
-
-    if (sourceId === parentNode.get('id')) {
-      edges.push(edge);
-    }
-  });
-  return getMindRecallEdges(graph, parentNode, edges);
-}
-
-var index$1 = /*#__PURE__*/Object.freeze({
-  __proto__: null,
-  guid: guid,
-  toQueryString: toQueryString,
-  executeBatch: executeBatch,
-  recursiveTraversal: recursiveTraversal,
-  isFlow: isFlow,
-  isMind: isMind,
-  isNode: isNode,
-  isEdge: isEdge,
-  getSelectedNodes: getSelectedNodes,
-  getSelectedEdges: getSelectedEdges,
-  getHighlightEdges: getHighlightEdges,
-  getGraphState: getGraphState,
-  setSelectedItems: setSelectedItems,
-  clearSelectedState: clearSelectedState,
-  getFlowRecallEdges: getFlowRecallEdges,
-  getMindRecallEdges: getMindRecallEdges
-});
-
-var Global = function Global() {
-  /** 当前版本 */
-  this.version = "3.1.1";
-  /** 埋点开关 */
-
-  this.trackable = true;
-  /** 剪贴板 */
-
-  this.clipboard = {
-    point: {
-      x: 0,
-      y: 0
-    },
-    models: []
-  };
-  /** 组件数据 */
-
-  this.component = {
-    itemPanel: {
-      model: null,
-      delegateShapeClassName: "delegateShape_" + guid()
-    }
-  };
-  /** 插件数据 */
-
-  this.plugin = {
-    itemPopover: {
-      state: 'hide'
-    },
-    contextMenu: {
-      state: 'hide'
-    },
-    editableLabel: {
-      state: 'hide'
-    }
-  };
-};
-
-var global = new Global();
-
-var CommandManager = /*#__PURE__*/function () {
-  function CommandManager() {
-    this.command = {};
-    this.commandQueue = [];
-    this.commandIndex = 0;
-  }
-  /** 注册命令 */
-
-
-  var _proto = CommandManager.prototype;
-
-  _proto.register = function register(name, command) {
-    this.command[name] = _extends({}, command, {
-      name: name
-    });
-  }
-  /** 执行命令 */
-  ;
-
-  _proto.execute = function execute(graph, name, params) {
-    var Command = this.command[name];
-
-    if (!Command) {
-      return;
-    }
-
-    var command = Object.create(Command);
-    command.params = cloneDeep(Command.params);
-
-    if (params) {
-      command.params = _extends({}, command.params, {}, params);
-    }
-
-    if (!command.canExecute(graph)) {
-      return;
-    }
-
-    if (!command.shouldExecute(graph)) {
-      return;
-    }
-
-    command.init(graph);
-    graph.emit(EditorEvent.onBeforeExecuteCommand, {
-      name: command.name,
-      params: command.params
-    });
-    command.execute(graph);
-    graph.emit(EditorEvent.onAfterExecuteCommand, {
-      name: command.name,
-      params: command.params
-    });
-
-    if (command.canUndo(graph)) {
-      var commandQueue = this.commandQueue,
-          commandIndex = this.commandIndex;
-      commandQueue.splice(commandIndex, commandQueue.length - commandIndex, command);
-      this.commandIndex += 1;
-    }
-
-    graph.emit(EditorEvent.onGraphStateChange, {
-      graphState: getGraphState(graph)
-    });
-  }
-  /** 判断是否可以执行 */
-  ;
-
-  _proto.canExecute = function canExecute(graph, name) {
-    return this.command[name].canExecute(graph);
-  }
-  /** 注入是否应该执行 */
-  ;
-
-  _proto.injectShouldExecute = function injectShouldExecute(name, shouldExecute) {
-    this.command[name].shouldExecute = shouldExecute;
-  };
-
-  return CommandManager;
-}();
-
-function withContext (Context, shouldRender) {
-  if (shouldRender === void 0) {
-    shouldRender = function shouldRender() {
-      return true;
-    };
-  }
-
-  return function (WrappedComponent) {
-    var InjectContext = function InjectContext(props) {
-      var forwardRef = props.forwardRef,
-          rest = _objectWithoutPropertiesLoose(props, ["forwardRef"]);
-
-      var refProp = {};
-
-      if (WrappedComponent.prototype.isReactComponent) {
-        refProp = {
-          ref: forwardRef
-        };
-      } else {
-        refProp = {
-          forwardRef: forwardRef
-        };
-      }
-
-      return React.createElement(Context.Consumer, null, function (context) {
-        return shouldRender(context) ? React.createElement(WrappedComponent, Object.assign({}, refProp, rest, context)) : null;
-      });
-    };
-
-    return React.forwardRef(function (props, ref) {
-      return React.createElement(InjectContext, Object.assign({
-        forwardRef: ref
-      }, props));
-    });
-  };
-}
-
-var EditorContext = React.createContext({});
-var EditorPrivateContext = React.createContext({});
-var withEditorContext = withContext(EditorContext, function (context) {
-  return !!context.graph;
-});
-var withEditorPrivateContext = withContext(EditorPrivateContext);
-
-var _Editor$defaultProps;
-
-var Editor = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Editor, _React$Component);
-
-  function Editor(props) {
-    var _this;
-
-    _this = _React$Component.call(this, props) || this;
-    _this.lastMousedownTarget = null;
-
-    _this.setGraph = function (graph) {
-      _this.setState({
-        graph: graph
-      });
-
-      _this.bindEvent(graph);
-
-      _this.bindShortcut(graph);
-    };
-
-    _this.executeCommand = function (name, params) {
-      var _this$state = _this.state,
-          graph = _this$state.graph,
-          commandManager = _this$state.commandManager;
-
-      if (graph) {
-        commandManager.execute(graph, name, params);
-      }
-    };
-
-    _this.state = {
-      graph: null,
-      setGraph: _this.setGraph,
-      executeCommand: _this.executeCommand,
-      commandManager: new CommandManager()
-    };
-    _this.lastMousedownTarget = null;
-    return _this;
-  }
-
-  Editor.setTrackable = function setTrackable(trackable) {
-    global.trackable = trackable;
-  };
-
-  var _proto = Editor.prototype;
-
-  _proto.shouldTriggerShortcut = function shouldTriggerShortcut(graph, target) {
-    var renderer = graph.get('renderer');
-    var canvasElement = graph.get('canvas').get('el');
-
-    if (!target) {
-      return false;
-    }
-
-    if (target === canvasElement) {
-      return true;
-    }
-
-    if (renderer === RendererType.Svg) {
-      if (target.nodeName === 'svg') {
-        return true;
-      }
-
-      var parentNode = target.parentNode;
-
-      while (parentNode && parentNode.nodeName !== 'BODY') {
-        if (parentNode.nodeName === 'svg') {
-          return true;
-        } else {
-          parentNode = parentNode.parentNode;
-        }
-      }
-
-      return false;
-    }
-  };
-
-  _proto.bindEvent = function bindEvent(graph) {
-    var props = this.props;
-    graph.on(EditorEvent.onBeforeExecuteCommand, props[EditorEvent.onBeforeExecuteCommand]);
-    graph.on(EditorEvent.onAfterExecuteCommand, props[EditorEvent.onAfterExecuteCommand]);
-  };
-
-  _proto.bindShortcut = function bindShortcut(graph) {
-    var _this2 = this;
-
-    var commandManager = this.state.commandManager;
-    window.addEventListener(GraphCommonEvent.onMouseDown, function (e) {
-      _this2.lastMousedownTarget = e.target;
-    });
-    graph.on(GraphCommonEvent.onKeyDown, function (e) {
-      if (!_this2.shouldTriggerShortcut(graph, _this2.lastMousedownTarget)) {
-        return;
-      }
-
-      Object.values(commandManager.command).some(function (command) {
-        var name = command.name,
-            shortcuts = command.shortcuts;
-        var flag = shortcuts.some(function (shortcut) {
-          var key = e.key;
-
-          if (!isArray(shortcut)) {
-            return shortcut === key;
-          }
-
-          return shortcut.every(function (item, index) {
-            if (index === shortcut.length - 1) {
-              return item === key;
-            }
-
-            return e[item];
-          });
-        });
-
-        if (flag) {
-          if (commandManager.canExecute(graph, name)) {
-            // Prevent default
-            e.preventDefault(); // Execute command
-
-            _this2.executeCommand(name);
-
-            return true;
-          }
-        }
-
-        return false;
-      });
-    });
-  };
-
-  _proto.render = function render() {
-    var children = this.props.children;
-    var _this$state2 = this.state,
-        graph = _this$state2.graph,
-        setGraph = _this$state2.setGraph,
-        executeCommand = _this$state2.executeCommand,
-        commandManager = _this$state2.commandManager;
-    return React.createElement(EditorContext.Provider, {
-      value: {
-        graph: graph,
-        executeCommand: executeCommand,
-        commandManager: commandManager
-      }
-    }, React.createElement(EditorPrivateContext.Provider, {
-      value: {
-        setGraph: setGraph,
-        commandManager: commandManager
-      }
-    }, React.createElement("div", Object.assign({}, pick(this.props, ['className', 'style'])), children)));
-  };
-
-  return Editor;
-}(React.Component);
-
-Editor.defaultProps = (_Editor$defaultProps = {}, _Editor$defaultProps[EditorEvent.onBeforeExecuteCommand] = function () {}, _Editor$defaultProps[EditorEvent.onAfterExecuteCommand] = function () {}, _Editor$defaultProps);
-
-var BehaviorManager = /*#__PURE__*/function () {
-  function BehaviorManager() {
-    this.behaviors = {};
-  }
-
-  var _proto = BehaviorManager.prototype;
-
-  _proto.getRegisteredBehaviors = function getRegisteredBehaviors(type) {
-    var _this = this;
-
-    var registeredBehaviors = {};
-    Object.keys(this.behaviors).forEach(function (name) {
-      var behavior = _this.behaviors[name];
-      var graphType = behavior.graphType;
-
-      if (graphType && graphType !== type) {
-        return;
-      }
-
-      var _behavior$graphMode = behavior.graphMode,
-          graphMode = _behavior$graphMode === void 0 ? 'default' : _behavior$graphMode;
-
-      if (!registeredBehaviors[graphMode]) {
-        registeredBehaviors[graphMode] = {};
-      }
-
-      registeredBehaviors[graphMode][name] = name;
-    });
-    return registeredBehaviors;
-  };
-
-  _proto.wrapEventHandler = function wrapEventHandler(type, behavior) {
-    var events = behavior.getEvents();
-    Object.keys(events).forEach(function (event) {
-      var handlerName = events[event];
-      var handler = behavior[handlerName];
-
-      behavior[handlerName] = function () {
-        var graph = this.graph;
-
-        if (type === GraphType.Flow && isMind(graph) === false || type === GraphType.Mind && isMind(graph)) {
-          for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
-            params[_key] = arguments[_key];
-          }
-
-          handler.apply(this, params);
-        }
-      };
-    });
-    return behavior;
-  };
-
-  _proto.register = function register(name, behavior) {
-    var graphType = behavior.graphType;
-    this.behaviors[name] = behavior;
-
-    switch (graphType) {
-      case GraphType.Flow:
-        G6.registerBehavior(name, this.wrapEventHandler(GraphType.Flow, behavior));
-        break;
-
-      case GraphType.Mind:
-        G6.registerBehavior(name, this.wrapEventHandler(GraphType.Mind, behavior));
-        break;
-
-      default:
-        G6.registerBehavior(name, behavior);
-        break;
-    }
-  };
-
-  return BehaviorManager;
-}();
-
-var behaviorManager = new BehaviorManager();
-
-var BASE_URL = 'http://gm.mmstat.com/fsp.1.1';
-function track(graphType) {
-  var version = global.version;
-  var trackable = global.trackable;
-
-  if (!trackable) {
-    return;
-  }
-
-  var _window = window,
-      location = _window.location,
-      navigator = _window.navigator;
-  var image = new Image();
-  var params = toQueryString({
-    pid: 'ggeditor',
-    code: '11',
-    msg: 'syslog',
-    page: location.protocol + "//" + location.host + location.pathname,
-    hash: location.hash,
-    ua: navigator.userAgent,
-    rel: version,
-    c1: graphType
-  });
-  image.src = BASE_URL + "?" + params;
-}
-
-var redoCommand = {
-  name: 'redo',
-  params: {},
-  canExecute: function canExecute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandQueue = commandManager.commandQueue,
-        commandIndex = commandManager.commandIndex;
-    return commandIndex < commandQueue.length;
-  },
-  shouldExecute: function shouldExecute() {
-    return true;
-  },
-  canUndo: function canUndo() {
-    return false;
-  },
-  init: function init() {},
-  execute: function execute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandQueue = commandManager.commandQueue,
-        commandIndex = commandManager.commandIndex;
-    commandQueue[commandIndex].execute(graph);
-    commandManager.commandIndex += 1;
-  },
-  undo: function undo() {},
-  shortcuts: [['metaKey', 'shiftKey', 'z'], ['ctrlKey', 'shiftKey', 'z']]
-};
-
-var undoCommand = {
-  name: 'undo',
-  params: {},
-  canExecute: function canExecute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandIndex = commandManager.commandIndex;
-    return commandIndex > 0;
-  },
-  shouldExecute: function shouldExecute() {
-    return true;
-  },
-  canUndo: function canUndo() {
-    return false;
-  },
-  init: function init() {},
-  execute: function execute(graph) {
-    var commandManager = graph.get('commandManager');
-    var commandQueue = commandManager.commandQueue,
-        commandIndex = commandManager.commandIndex;
-    commandQueue[commandIndex - 1].undo(graph);
-    commandManager.commandIndex -= 1;
-  },
-  undo: function undo() {},
-  shortcuts: [['metaKey', 'z'], ['ctrlKey', 'z']]
-};
-
-var baseCommand = {
-  name: '',
-  params: {},
-  canExecute: function canExecute() {
-    return true;
-  },
-  shouldExecute: function shouldExecute() {
-    return true;
-  },
-  canUndo: function canUndo() {
-    return true;
-  },
-  init: function init() {},
-  execute: function execute() {},
-  undo: function undo() {},
-  shortcuts: [],
-  isMind: isMind,
-  getSelectedNodes: getSelectedNodes,
-  getSelectedEdges: getSelectedEdges,
-  setSelectedItems: setSelectedItems,
-  editSelectedNode: function editSelectedNode(graph) {
-    graph.emit(EditorEvent.onLabelStateChange, {
-      labelState: LabelState.Show
-    });
-  }
-};
-
-var addCommand = _extends({}, baseCommand, {
-  params: {
-    type: ItemType.Node,
-    model: {
-      id: ''
-    }
-  },
-  init: function init() {
-    var model = this.params.model;
-
-    if (model.id) {
-      return;
-    }
-
-    model.id = guid();
-  },
-  execute: function execute(graph) {
-    var _this$params = this.params,
-        type = _this$params.type,
-        model = _this$params.model;
-    graph.add(type, model);
-    this.setSelectedItems(graph, [model.id]);
-  },
-  undo: function undo(graph) {
-    var model = this.params.model;
-    graph.remove(model.id);
-  }
-});
-
-var removeCommand = _extends({}, baseCommand, {
-  params: {
-    flow: {
-      nodes: {},
-      edges: {}
-    },
-    mind: {
-      model: null,
-      parent: ''
-    }
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    var selectedEdges = this.getSelectedEdges(graph);
-    return !!(selectedNodes.length || selectedEdges.length);
-  },
-  init: function init(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    var selectedEdges = this.getSelectedEdges(graph);
-
-    if (isMind(graph)) {
-      var selectedNode = selectedNodes[0];
-      var selectedNodeModel = selectedNode.getModel();
-      var selectedNodeParent = selectedNode.get('parent');
-      var selectedNodeParentModel = selectedNodeParent ? selectedNodeParent.getModel() : {};
-      this.params.mind = {
-        model: selectedNodeModel,
-        parent: selectedNodeParentModel.id
-      };
-    } else {
-      var _this$params$flow = this.params.flow,
-          nodes = _this$params$flow.nodes,
-          edges = _this$params$flow.edges;
-      selectedNodes.forEach(function (node) {
-        var nodeModel = node.getModel();
-        var nodeEdges = node.getEdges();
-        nodes[nodeModel.id] = nodeModel;
-        nodeEdges.forEach(function (edge) {
-          var edgeModel = edge.getModel();
-          edges[edgeModel.id] = edgeModel;
-        });
-      });
-      selectedEdges.forEach(function (edge) {
-        var edgeModel = edge.getModel();
-        edges[edgeModel.id] = edgeModel;
-      });
-    }
-  },
-  execute: function execute(graph) {
-    if (isMind(graph)) {
-      var model = this.params.mind.model;
-
-      if (!model) {
-        return;
-      }
-
-      graph.removeChild(model.id);
-    } else {
-      var _this$params$flow2 = this.params.flow,
-          nodes = _this$params$flow2.nodes,
-          edges = _this$params$flow2.edges;
-      executeBatch(graph, function () {
-        [].concat(Object.keys(nodes), Object.keys(edges)).forEach(function (id) {
-          graph.removeItem(id);
-        });
-      });
-    }
-  },
-  undo: function undo(graph) {
-    if (isMind(graph)) {
-      var _this$params$mind = this.params.mind,
-          model = _this$params$mind.model,
-          parent = _this$params$mind.parent;
-
-      if (!model) {
-        return;
-      }
-
-      graph.addChild(model, parent);
-    } else {
-      var _this$params$flow3 = this.params.flow,
-          nodes = _this$params$flow3.nodes,
-          edges = _this$params$flow3.edges;
-      executeBatch(graph, function () {
-        Object.keys(nodes).forEach(function (id) {
-          var model = nodes[id];
-          graph.addItem(ItemType.Node, model);
-        });
-        Object.keys(edges).forEach(function (id) {
-          var model = edges[id];
-          graph.addItem(ItemType.Edge, model);
-        });
-      });
-    }
-  },
-  shortcuts: ['Delete', 'Backspace']
-});
-
-var updateCommand = _extends({}, baseCommand, {
-  params: {
-    id: '',
-    originModel: {},
-    updateModel: {},
-    forceRefreshLayout: false
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    var selectedEdges = this.getSelectedEdges(graph);
-    return (selectedNodes.length || selectedEdges.length) && (selectedNodes.length === 1 || selectedEdges.length === 1) ? true : false;
-  },
-  init: function init(graph) {
-    var _this$params = this.params,
-        id = _this$params.id,
-        updateModel = _this$params.updateModel;
-    var updatePaths = Object.keys(updateModel);
-    var originModel = pick(graph.findById(id).getModel(), updatePaths);
-    this.params.originModel = originModel;
-  },
-  execute: function execute(graph) {
-    var _this$params2 = this.params,
-        id = _this$params2.id,
-        updateModel = _this$params2.updateModel,
-        forceRefreshLayout = _this$params2.forceRefreshLayout;
-    graph.updateItem(id, updateModel);
-
-    if (forceRefreshLayout) {
-      graph.refreshLayout && graph.refreshLayout(false);
-    }
-  },
-  undo: function undo(graph) {
-    var _this$params3 = this.params,
-        id = _this$params3.id,
-        originModel = _this$params3.originModel;
-    graph.updateItem(id, originModel);
-  }
-});
-
-var copyCommand = _extends({}, baseCommand, {
-  canExecute: function canExecute(graph) {
-    return !!this.getSelectedNodes(graph).length;
-  },
-  canUndo: function canUndo() {
-    return false;
-  },
-  execute: function execute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    global.clipboard.models = cloneDeep(selectedNodes.map(function (node) {
-      return node.getModel();
-    }));
-  },
-  shortcuts: [['metaKey', 'c'], ['ctrlKey', 'c']]
-});
-
-var pasteCommand = _extends({}, baseCommand, {
-  params: {
-    models: []
-  },
-  canExecute: function canExecute() {
-    return !!global.clipboard.models.length;
-  },
-  init: function init() {
-    var models = global.clipboard.models;
-    var offsetX = 10;
-    var offsetY = 10;
-    this.params = {
-      models: models.map(function (model) {
-        var x = model.x,
-            y = model.y;
-        return _extends({}, model, {
-          id: guid(),
-          x: x + offsetX,
-          y: y + offsetY
-        });
-      })
-    };
-  },
-  execute: function execute(graph) {
-    var models = this.params.models;
-    executeBatch(graph, function () {
-      models.forEach(function (model) {
-        graph.addItem(ItemType.Node, model);
-      });
-    });
-    this.setSelectedItems(graph, models.map(function (model) {
-      return model.id;
-    }));
-  },
-  undo: function undo(graph) {
-    var models = this.params.models;
-    executeBatch(graph, function () {
-      models.forEach(function (model) {
-        graph.removeItem(model.id);
-      });
-    });
-  },
-  shortcuts: [['metaKey', 'v'], ['ctrlKey', 'v']]
-});
-
-var pasteHereCommand = _extends({}, pasteCommand, {
-  params: {
-    models: []
-  },
-  init: function init() {
-    var _global$clipboard = global.clipboard,
-        point = _global$clipboard.point,
-        models = _global$clipboard.models;
-    this.params = {
-      models: models.map(function (model) {
-        var x = model.x,
-            y = model.y;
-        var offsetX = point.x - x;
-        var offsetY = point.y - y;
-        return _extends({}, model, {
-          id: guid(),
-          x: x + offsetX,
-          y: y + offsetY
-        });
-      })
-    };
-  },
-  shortcuts: []
-});
-
-var DELTA = 0.05;
-
-var zoomInCommand = _extends({}, baseCommand, {
-  canUndo: function canUndo() {
-    return false;
-  },
-  execute: function execute(graph) {
-    var ratio = 1 + DELTA;
-    var zoom = graph.getZoom() * ratio;
-    var maxZoom = graph.get('maxZoom');
-
-    if (zoom > maxZoom) {
-      return;
-    }
-
-    graph.zoom(ratio);
-  },
-  shortcuts: [['metaKey', '='], ['ctrlKey', '=']]
-});
-
-var DELTA$1 = 0.05;
-
-var zoomOutCommand = _extends({}, baseCommand, {
-  canUndo: function canUndo() {
-    return false;
-  },
-  execute: function execute(graph) {
-    var ratio = 1 - DELTA$1;
-    var zoom = graph.getZoom() * ratio;
-    var minZoom = graph.get('minZoom');
-
-    if (zoom < minZoom) {
-      return;
-    }
-
-    graph.zoom(ratio);
-  },
-  shortcuts: [['metaKey', '-'], ['ctrlKey', '-']]
-});
-
-var baseCommands = {
-  redo: redoCommand,
-  undo: undoCommand,
-  add: addCommand,
-  remove: removeCommand,
-  update: updateCommand,
-  copy: copyCommand,
-  paste: pasteCommand,
-  pasteHere: pasteHereCommand,
-  zoomIn: zoomInCommand,
-  zoomOut: zoomOutCommand
-};
-
-var topicCommand = _extends({}, baseCommand, {
-  params: {
-    id: '',
-    model: {
-      id: ''
-    }
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-    return selectedNodes.length && selectedNodes.length === 1 && selectedNodes[0].get('parent');
-  },
-  init: function init(graph) {
-    if (this.params.id) {
-      return;
-    }
-
-    var selectedNode = this.getSelectedNodes(graph)[0];
-    this.params = {
-      id: selectedNode.get('id'),
-      model: {
-        id: guid(),
-        label: LABEL_DEFAULT_TEXT
-      }
-    };
-  },
-  execute: function execute(graph) {
-    var _this$params = this.params,
-        id = _this$params.id,
-        model = _this$params.model;
-    var parent = graph.findById(id).get('parent'); // 添加节点
-
-    graph.addChild(model, parent); // 选中节点
-
-    this.setSelectedItems(graph, [model.id]); // 编辑节点
-
-    this.editSelectedNode(graph);
-  },
-  undo: function undo(graph) {
-    var _this$params2 = this.params,
-        id = _this$params2.id,
-        model = _this$params2.model;
-    this.setSelectedItems(graph, [id]);
-    graph.removeChild(model.id);
-  },
-  shortcuts: ['Enter']
-});
-
-var subtopicCommand = _extends({}, topicCommand, {
-  canExecute: function canExecute(graph) {
-    return this.getSelectedNodes(graph)[0] ? true : false;
-  },
-  execute: function execute(graph) {
-    var _this$params = this.params,
-        id = _this$params.id,
-        model = _this$params.model; // 添加节点
-
-    graph.addChild(model, id); // 选中节点
-
-    this.setSelectedItems(graph, [model.id]); // 编辑节点
-
-    this.editSelectedNode(graph);
-  },
-  shortcuts: ['Tab']
-});
-
-var foldCommand = _extends({}, baseCommand, {
-  params: {
-    id: ''
-  },
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-
-    if (!selectedNodes.length) {
-      return false;
-    }
-
-    var selectedNode = selectedNodes[0];
-    var selectedNodeModel = selectedNode.getModel();
-
-    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
-      return false;
-    }
-
-    if (selectedNodeModel.collapsed) {
-      return false;
-    }
-
-    return true;
-  },
-  init: function init(graph) {
-    var selectedNode = this.getSelectedNodes(graph)[0];
-    var selectedNodeModel = selectedNode.getModel();
-    this.params = {
-      id: selectedNodeModel.id
-    };
-  },
-  execute: function execute(graph) {
-    var id = this.params.id;
-    var sourceData = graph.findDataById(id);
-    sourceData.collapsed = !sourceData.collapsed;
-    graph.refreshLayout(false);
-  },
-  undo: function undo(graph) {
-    this.execute(graph);
-  },
-  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
-});
-
-var unfoldCommand = _extends({}, foldCommand, {
-  canExecute: function canExecute(graph) {
-    var selectedNodes = this.getSelectedNodes(graph);
-
-    if (!selectedNodes.length) {
-      return false;
-    }
-
-    var selectedNode = selectedNodes[0];
-    var selectedNodeModel = selectedNode.getModel();
-
-    if (!selectedNodeModel.children || !selectedNodeModel.children.length) {
-      return false;
-    }
-
-    if (!selectedNodeModel.collapsed) {
-      return false;
-    }
-
-    return true;
-  },
-  shortcuts: [['metaKey', '/'], ['ctrlKey', '/']]
-});
-
-var mindCommands = {
-  topic: topicCommand,
-  subtopic: subtopicCommand,
-  fold: foldCommand,
-  unfold: unfoldCommand
-};
-
-var clickItemBehavior = {
-  getDefaultCfg: function getDefaultCfg() {
-    return {
-      multiple: true,
-      keydown: false,
-      keyCode: 17
-    };
-  },
-  getEvents: function getEvents() {
-    return {
-      'node:click': 'handleItemClick',
-      'edge:click': 'handleItemClick',
-      'canvas:click': 'handleCanvasClick',
-      keydown: 'handleKeyDown',
-      keyup: 'handleKeyUp'
-    };
-  },
-  handleItemClick: function handleItemClick(_ref) {
-    var item = _ref.item;
-    var graph = this.graph;
-
-    if (isMind(graph) && isEdge(item)) {
-      return;
-    }
-
-    var isSelected = item.hasState(ItemState.Selected);
-
-    if (this.multiple && this.keydown) {
-      graph.setItemState(item, ItemState.Selected, !isSelected);
-    } else {
-      clearSelectedState(graph, function (selectedItem) {
-        return selectedItem !== item;
-      });
-
-      if (!isSelected) {
-        graph.setItemState(item, ItemState.Selected, true);
-      }
-    }
-
-    graph.emit(EditorEvent.onGraphStateChange, {
-      graphState: getGraphState(graph)
-    });
-  },
-  handleCanvasClick: function handleCanvasClick() {
-    var graph = this.graph;
-    clearSelectedState(graph);
-    graph.emit(EditorEvent.onGraphStateChange, {
-      graphState: GraphState.CanvasSelected
-    });
-  },
-  handleKeyDown: function handleKeyDown(e) {
-    this.keydown = (e.keyCode || e.which) === this.keyCode;
-  },
-  handleKeyUp: function handleKeyUp() {
-    this.keydown = false;
-  }
-};
-behaviorManager.register('click-item', clickItemBehavior);
-
-var hoverItemBehavior = {
-  getEvents: function getEvents() {
-    return {
-      'node:mouseenter': 'handleItemMouseenter',
-      'edge:mouseenter': 'handleItemMouseenter',
-      'node:mouseleave': 'handleItemMouseleave',
-      'edge:mouseleave': 'handleItemMouseleave'
-    };
-  },
-  handleItemMouseenter: function handleItemMouseenter(_ref) {
-    var item = _ref.item;
-    var graph = this.graph;
-    graph.setItemState(item, ItemState.Active, true);
-  },
-  handleItemMouseleave: function handleItemMouseleave(_ref2) {
-    var item = _ref2.item;
-    var graph = this.graph;
-    graph.setItemState(item, ItemState.Active, false);
-  }
-};
-behaviorManager.register('hover-item', hoverItemBehavior);
-
-var dragCanvasBehavior = {
-  origin: null,
-  keyCode: null,
-  dragging: false,
-  handleWindowMouseUp: null,
-  getDefaultCfg: function getDefaultCfg() {
-    return {
-      allowKeyCode: [],
-      notAllowKeyCode: [16]
-    };
-  },
-  getEvents: function getEvents() {
-    return {
-      'canvas:dragstart': 'handleCanvasDragStart',
-      'canvas:drag': 'handleCanvasDrag',
-      'canvas:dragend': 'handleCanvasDragEnd',
-      'canvas:mouseleave': 'handleCanvasMouseLeave',
-      'canvas:contextmenu': 'handleCanvasContextMenu',
-      keydown: 'handleKeyDown',
-      keyup: 'handleKeyUp'
-    };
-  },
-  canDrag: function canDrag() {
-    var keyCode = this.keyCode,
-        allowKeyCode = this.allowKeyCode,
-        notAllowKeyCode = this.notAllowKeyCode;
-    var isAllow = !!!allowKeyCode.length;
-
-    if (!keyCode) {
-      return isAllow;
-    }
-
-    if (allowKeyCode.length && allowKeyCode.includes(keyCode)) {
-      isAllow = true;
-    }
-
-    if (notAllowKeyCode.includes(keyCode)) {
-      isAllow = false;
-    }
-
-    return isAllow;
-  },
-  updateViewport: function updateViewport(e) {
-    var clientX = e.clientX,
-        clientY = e.clientY;
-    var dx = clientX - this.origin.x;
-    var dy = clientY - this.origin.y;
-    this.origin = {
-      x: clientX,
-      y: clientY
-    };
-    this.graph.translate(dx, dy);
-    this.graph.paint();
-  },
-  handleCanvasDragStart: function handleCanvasDragStart(e) {
-    if (!this.shouldBegin.call(this, e)) {
-      return;
-    }
-
-    if (!this.canDrag()) {
-      return;
-    }
-
-    this.origin = {
-      x: e.clientX,
-      y: e.clientY
-    };
-    this.dragging = false;
-  },
-  handleCanvasDrag: function handleCanvasDrag(e) {
-    if (!this.shouldUpdate.call(this, e)) {
-      return;
-    }
-
-    if (!this.canDrag()) {
-      return;
-    }
-
-    if (!this.origin) {
-      return;
-    }
-
-    if (!this.dragging) {
-      this.dragging = true;
-    } else {
-      this.updateViewport(e);
-    }
-  },
-  handleCanvasDragEnd: function handleCanvasDragEnd(e) {
-    if (!this.shouldEnd.call(this, e)) {
-      return;
-    }
-
-    if (!this.canDrag()) {
-      return;
-    }
-
-    this.origin = null;
-    this.dragging = false;
-
-    if (this.handleWindowMouseUp) {
-      document.body.removeEventListener('mouseup', this.handleWindowMouseUp, false);
-      this.handleWindowMouseUp = null;
-    }
-  },
-  handleCanvasMouseLeave: function handleCanvasMouseLeave() {
-    var _this = this;
-
-    var canvasElement = this.graph.get('canvas').get('el');
-
-    if (this.handleWindowMouseUp) {
-      return;
-    }
-
-    this.handleWindowMouseUp = function (e) {
-      if (e.target !== canvasElement) {
-        _this.handleCanvasDragEnd();
-      }
-    };
-
-    document.body.addEventListener('mouseup', this.handleWindowMouseUp, false);
-  },
-  handleCanvasContextMenu: function handleCanvasContextMenu() {
-    this.origin = null;
-    this.dragging = false;
-  },
-  handleKeyDown: function handleKeyDown(e) {
-    this.keyCode = e.keyCode || e.which;
-  },
-  handleKeyUp: function handleKeyUp() {
-    this.keyCode = null;
-  }
-};
-behaviorManager.register('drag-canvas', dragCanvasBehavior);
-
-var recallEdgeBehavior = {
-  edgeIds: [],
-  getEvents: function getEvents() {
-    return {
-      'node:click': 'handleNodeClick',
-      'edge:click': 'handleEdgeClick',
-      'canvas:click': 'handleCanvasClick'
-    };
-  },
-  setHighLightState: function setHighLightState(edges) {
-    var graph = this.graph;
-    this.clearHighLightState();
-    executeBatch(graph, function () {
-      edges.forEach(function (item) {
-        graph.setItemState(item, ItemState.HighLight, true);
-      });
-    });
-    this.edgeIds = edges.map(function (edge) {
-      return edge.get('id');
-    });
-  },
-  clearHighLightState: function clearHighLightState() {
-    var _this = this;
-
-    var graph = this.graph;
-    executeBatch(graph, function () {
-      _this.edgeIds.forEach(function (id) {
-        var item = graph.findById(id);
-
-        if (item && !item.destroyed) {
-          graph.setItemState(item, ItemState.HighLight, false);
-        }
-      });
-    });
-    this.edgeIds = [];
-  },
-  handleNodeClick: function handleNodeClick(_ref) {
-    var item = _ref.item;
-    var graph = this.graph;
-    var edges = [];
-
-    if (isFlow(graph)) {
-      edges = getFlowRecallEdges(graph, item);
-    }
-
-    if (isMind(graph)) {
-      edges = getMindRecallEdges(graph, item);
-    }
-
-    this.setHighLightState(edges);
-  },
-  handleEdgeClick: function handleEdgeClick() {
-    this.clearHighLightState();
-  },
-  handleCanvasClick: function handleCanvasClick() {
-    this.clearHighLightState();
-  }
-};
-behaviorManager.register('recall-edge', recallEdgeBehavior);
-
-var GraphComponent = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(GraphComponent, _React$Component);
-
-  function GraphComponent() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.graph = null;
-    return _this;
-  }
-
-  var _proto = GraphComponent.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    this.initGraph();
-    this.bindEvent();
-  };
-
-  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
-    var data = this.props.data;
-
-    if (data !== prevProps.data) {
-      this.changeData(data);
-    }
-  };
-
-  _proto.focusRootNode = function focusRootNode(graph, data) {
-    if (!isMind(graph)) {
-      return;
-    }
-
-    var id = data.id;
-    graph.focusItem(id);
-  };
-
-  _proto.initGraph = function initGraph() {
-    var _this$props = this.props,
-        containerId = _this$props.containerId,
-        parseData = _this$props.parseData,
-        initGraph = _this$props.initGraph,
-        setGraph = _this$props.setGraph,
-        commandManager = _this$props.commandManager;
-
-    var _ref = document.getElementById(containerId) || {},
-        _ref$clientWidth = _ref.clientWidth,
-        clientWidth = _ref$clientWidth === void 0 ? 0 : _ref$clientWidth,
-        _ref$clientHeight = _ref.clientHeight,
-        clientHeight = _ref$clientHeight === void 0 ? 0 : _ref$clientHeight; // 解析数据
-
-
-    var data = _extends({}, this.props.data);
-
-    parseData(data); // 初始画布
-
-    this.graph = initGraph(clientWidth, clientHeight);
-    this.graph.data(data);
-    this.graph.render();
-    this.focusRootNode(this.graph, data);
-    this.graph.setMode('default');
-    setGraph(this.graph); // 设置命令管理器
-
-    this.graph.set('commandManager', commandManager); // 注册命令
-
-    var commands = baseCommands;
-
-    if (isMind(this.graph)) {
-      commands = _extends({}, commands, {}, mindCommands);
-    }
-
-    Object.keys(commands).forEach(function (name) {
-      commandManager.register(name, commands[name]);
-    }); // 发送埋点
-
-    if (global.trackable) {
-      var graphType = isMind(this.graph) ? GraphType.Mind : GraphType.Flow;
-      track(graphType);
-    }
-  };
-
-  _proto.bindEvent = function bindEvent() {
-    var graph = this.graph,
-        props = this.props;
-
-    if (!graph) {
-      return;
-    }
-
-    var events = _extends({}, GraphCommonEvent, {}, GraphNodeEvent, {}, GraphEdgeEvent, {}, GraphCanvasEvent, {}, GraphCustomEvent);
-
-    Object.keys(events).forEach(function (event) {
-      if (typeof props[event] === 'function') {
-        graph.on(events[event], props[event]);
-      }
-    });
-  };
-
-  _proto.changeData = function changeData(data) {
-    var graph = this.graph;
-    var parseData = this.props.parseData;
-
-    if (!graph) {
-      return;
-    }
-
-    parseData(data);
-    graph.changeData(data);
-    this.focusRootNode(graph, data);
-  };
-
-  _proto.render = function render() {
-    var _this$props2 = this.props,
-        containerId = _this$props2.containerId,
-        children = _this$props2.children;
-    return React.createElement("div", Object.assign({
-      id: containerId
-    }, pick(this.props, ['className', 'style'])), children);
-  };
-
-  return GraphComponent;
-}(React.Component);
-
-var GraphComponent$1 = withEditorPrivateContext(GraphComponent);
-
-var dragAddNodeBehavior = {
-  shape: null,
-  graphType: GraphType.Flow,
-  graphMode: GraphMode.AddNode,
-  getEvents: function getEvents() {
-    return {
-      'canvas:mouseenter': 'handleCanvasMouseEnter',
-      mousemove: 'handleMouseMove',
-      mouseup: 'handleMouseUp'
-    };
-  },
-  handleCanvasMouseEnter: function handleCanvasMouseEnter(e) {
-    var graph = this.graph,
-        shape = this.shape;
-
-    if (shape) {
-      return;
-    }
-
-    var group = graph.get('group');
-    var model = global.component.itemPanel.model;
-    var _model$size = model.size,
-        size = _model$size === void 0 ? 100 : _model$size;
-    var width = 0;
-    var height = 0;
-
-    if (isArray(size)) {
-      width = size[0];
-      height = size[1];
-    } else {
-      width = size;
-      height = size;
-    }
-
-    var x = e.x - width / 2;
-    var y = e.y - height / 2;
-    this.shape = group.addShape('rect', {
-      className: global.component.itemPanel.delegateShapeClassName,
-      attrs: {
-        x: x,
-        y: y,
-        width: width,
-        height: height,
-        fill: '#f3f9ff',
-        fillOpacity: 0.5,
-        stroke: '#1890ff',
-        strokeOpacity: 0.9,
-        lineDash: [5, 5]
-      }
-    });
-    graph.paint();
-  },
-  handleMouseMove: function handleMouseMove(e) {
-    var graph = this.graph;
-
-    var _this$shape$getBBox = this.shape.getBBox(),
-        width = _this$shape$getBBox.width,
-        height = _this$shape$getBBox.height;
-
-    var x = e.x - width / 2;
-    var y = e.y - height / 2;
-    this.shape.attr({
-      x: x,
-      y: y
-    });
-    graph.paint();
-  },
-  handleMouseUp: function handleMouseUp(e) {
-    var graph = this.graph;
-
-    var _this$shape$getBBox2 = this.shape.getBBox(),
-        width = _this$shape$getBBox2.width,
-        height = _this$shape$getBBox2.height;
-
-    var x = e.x;
-    var y = e.y;
-    var model = global.component.itemPanel.model;
-
-    if (model.center === 'topLeft') {
-      x -= width / 2;
-      y -= height / 2;
-    }
-
-    this.shape.remove(true);
-    var commandManager = graph.get('commandManager');
-    commandManager.execute(graph, EditorCommand.Add, {
-      type: ItemType.Node,
-      model: _extends({
-        id: guid(),
-        x: x,
-        y: y
-      }, model)
-    });
-  }
-};
-behaviorManager.register('drag-add-node', dragAddNodeBehavior);
-
-var dragAddEdgeBehavior = {
-  edge: null,
-  graphType: GraphType.Flow,
-  getDefaultCfg: function getDefaultCfg() {
-    return {
-      edgeType: 'bizFlowEdge',
-      getAnchorPointStateOfSourceNode: function getAnchorPointStateOfSourceNode() {
-        return AnchorPointState.Enabled;
-      },
-      getAnchorPointStateOfTargetNode: function getAnchorPointStateOfTargetNode() {
-        return AnchorPointState.Enabled;
-      }
-    };
-  },
-  getEvents: function getEvents() {
-    return {
-      'node:mouseenter': 'handleNodeMouseEnter',
-      'node:mouseleave': 'handleNodeMouseLeave',
-      'node:mousedown': 'handleNodeMouseDown',
-      mousemove: 'handleMouseMove',
-      mouseup: 'handleMouseUp'
-    };
-  },
-  isEnabledAnchorPoint: function isEnabledAnchorPoint(e) {
-    var target = e.target;
-    return !!target.get('isAnchorPoint') && target.get('anchorPointState') === AnchorPointState.Enabled;
-  },
-  isNotSelf: function isNotSelf(e) {
-    var edge = this.edge;
-    var item = e.item;
-    return item.getModel().id !== edge.getSource().getModel().id;
-  },
-  getTargetNodes: function getTargetNodes(sourceId) {
-    var graph = this.graph;
-    var nodes = graph.getNodes();
-    return nodes.filter(function (node) {
-      return node.getModel().id !== sourceId;
-    });
-  },
-  canFindTargetAnchorPoint: function canFindTargetAnchorPoint(e) {
-    return this.isEnabledAnchorPoint(e) && this.isNotSelf(e);
-  },
-  shouldAddDelegateEdge: function shouldAddDelegateEdge(e) {
-    return this.isEnabledAnchorPoint(e);
-  },
-  shouldAddRealEdge: function shouldAddRealEdge() {
-    var edge = this.edge;
-    var target = edge.getTarget();
-    return !isPlainObject(target);
-  },
-  handleNodeMouseEnter: function handleNodeMouseEnter(e) {
-    var graph = this.graph,
-        getAnchorPointStateOfSourceNode = this.getAnchorPointStateOfSourceNode;
-    var sourceNode = e.item;
-    var sourceAnchorPoints = sourceNode.getAnchorPoints();
-    var sourceAnchorPointsState = [];
-    sourceAnchorPoints.forEach(function (sourceAnchorPoint) {
-      sourceAnchorPointsState.push(getAnchorPointStateOfSourceNode(sourceNode, sourceAnchorPoint));
-    });
-    sourceNode.set('anchorPointsState', sourceAnchorPointsState);
-    graph.setItemState(sourceNode, ItemState.ActiveAnchorPoints, true);
-  },
-  handleNodeMouseLeave: function handleNodeMouseLeave(e) {
-    var graph = this.graph,
-        edge = this.edge;
-    var item = e.item;
-
-    if (!edge) {
-      item.set('anchorPointsState', []);
-      graph.setItemState(item, ItemState.ActiveAnchorPoints, false);
-    }
-  },
-  handleNodeMouseDown: function handleNodeMouseDown(e) {
-    if (!this.shouldBegin(e) || !this.shouldAddDelegateEdge(e)) {
-      return;
-    }
-
-    var graph = this.graph,
-        edgeType = this.edgeType,
-        getAnchorPointStateOfTargetNode = this.getAnchorPointStateOfTargetNode;
-    var target = e.target;
-    var sourceNode = e.item;
-    var sourceNodeId = sourceNode.getModel().id;
-    var sourceAnchorPointIndex = target.get('anchorPointIndex');
-    var sourceAnchorPoint = sourceNode.getAnchorPoints()[sourceAnchorPointIndex];
-    var model = {
-      id: guid(),
-      type: edgeType,
-      source: sourceNodeId,
-      sourceAnchor: sourceAnchorPointIndex,
-      target: {
-        x: e.x,
-        y: e.y
-      }
-    };
-    this.edge = graph.addItem(ItemType.Edge, model);
-    graph.getNodes().forEach(function (targetNode) {
-      if (targetNode.getModel().id === sourceNodeId) {
-        return;
-      }
-
-      var targetAnchorPoints = targetNode.getAnchorPoints();
-      var targetAnchorPointsState = [];
-      targetAnchorPoints.forEach(function (targetAnchorPoint) {
-        targetAnchorPointsState.push(getAnchorPointStateOfTargetNode(sourceNode, sourceAnchorPoint, targetNode, targetAnchorPoint));
-      });
-      targetNode.set('anchorPointsState', targetAnchorPointsState);
-      graph.setItemState(targetNode, ItemState.ActiveAnchorPoints, true);
-    });
-  },
-  handleMouseMove: function handleMouseMove(e) {
-    var graph = this.graph,
-        edge = this.edge;
-
-    if (!edge) {
-      return;
-    }
-
-    if (this.canFindTargetAnchorPoint(e)) {
-      var item = e.item,
-          target = e.target;
-      var targetId = item.getModel().id;
-      var targetAnchor = target.get('anchorPointIndex');
-      graph.updateItem(edge, {
-        target: targetId,
-        targetAnchor: targetAnchor
-      });
-    } else {
-      graph.updateItem(edge, {
-        target: {
-          x: e.x,
-          y: e.y
-        },
-        targetAnchor: undefined
-      });
-    }
-  },
-  handleMouseUp: function handleMouseUp() {
-    var graph = this.graph,
-        edge = this.edge;
-
-    if (!edge) {
-      return;
-    }
-
-    if (!this.shouldAddRealEdge()) {
-      graph.removeItem(this.edge);
-    }
-
-    this.edge = null;
-    graph.getNodes().forEach(function (node) {
-      node.set('anchorPointsState', []);
-      graph.setItemState(node, ItemState.ActiveAnchorPoints, false);
-    });
-  }
-};
-behaviorManager.register('drag-add-edge', dragAddEdgeBehavior);
-
-var Flow = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Flow, _React$Component);
-
-  function Flow() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.graph = null;
-    _this.containerId = FLOW_CONTAINER_ID + "_" + guid();
-
-    _this.canDragNode = function (e) {
-      return !['anchor', 'banAnchor'].some(function (item) {
-        return item === e.target.get('className');
-      });
-    };
-
-    _this.canDragOrZoomCanvas = function () {
-      var _assertThisInitialize = _assertThisInitialized(_this),
-          graph = _assertThisInitialize.graph;
-
-      if (!graph) {
-        return false;
-      }
-
-      return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';
-    };
-
-    _this.parseData = function (data) {
-      var nodes = data.nodes,
-          edges = data.edges;
-      [].concat(nodes, edges).forEach(function (item) {
-        var id = item.id;
-
-        if (id) {
-          return;
-        }
-
-        item.id = guid();
-      });
-    };
-
-    _this.initGraph = function (width, height) {
-      var _assertThisInitialize2 = _assertThisInitialized(_this),
-          containerId = _assertThisInitialize2.containerId;
-
-      var _this$props = _this.props,
-          graphConfig = _this$props.graphConfig,
-          customModes = _this$props.customModes;
-      var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Flow), {
-        "default": {
-          'drag-node': {
-            type: 'drag-node',
-            enableDelegate: true,
-            shouldBegin: _this.canDragNode
-          },
-          'drag-canvas': {
-            type: 'drag-canvas',
-            shouldBegin: _this.canDragOrZoomCanvas,
-            shouldUpdate: _this.canDragOrZoomCanvas
-          },
-          'zoom-canvas': {
-            type: 'zoom-canvas',
-            shouldUpdate: _this.canDragOrZoomCanvas
-          },
-          'recall-edge': 'recall-edge',
-          'brush-select': 'brush-select'
-        }
-      });
-      Object.keys(modes).forEach(function (mode) {
-        var behaviors = modes[mode];
-        modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
-      });
-      _this.graph = new G6.Graph(_extends({
-        container: containerId,
-        width: width,
-        height: height,
-        modes: modes,
-        defaultNode: {
-          type: 'bizFlowNode'
-        },
-        defaultEdge: {
-          type: 'bizFlowEdge'
-        }
-      }, graphConfig));
-      return _this.graph;
-    };
-
-    return _this;
-  }
-
-  var _proto = Flow.prototype;
-
-  _proto.render = function render() {
-    var containerId = this.containerId,
-        parseData = this.parseData,
-        initGraph = this.initGraph;
-    return React.createElement(GraphComponent$1, Object.assign({
-      containerId: containerId,
-      parseData: parseData,
-      initGraph: initGraph
-    }, omit(this.props, ['graphConfig', 'customModes'])));
-  };
-
-  return Flow;
-}(React.Component);
-
-Flow.defaultProps = {
-  graphConfig: {}
-};
-
-var Mind = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Mind, _React$Component);
-
-  function Mind() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.graph = null;
-    _this.containerId = MIND_CONTAINER_ID + "_" + guid();
-
-    _this.canDragOrZoomCanvas = function () {
-      var _assertThisInitialize = _assertThisInitialized(_this),
-          graph = _assertThisInitialize.graph;
-
-      if (!graph) {
-        return false;
-      }
-
-      return global.plugin.itemPopover.state === 'hide' && global.plugin.contextMenu.state === 'hide' && global.plugin.editableLabel.state === 'hide';
-    };
-
-    _this.canCollapseExpand = function (_ref) {
-      var target = _ref.target;
-      return target && [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].includes(target.get('className'));
-    };
-
-    _this.parseData = function (data) {
-      recursiveTraversal(data, function (item) {
-        var id = item.id;
-
-        if (id) {
-          return;
-        }
-
-        item.id = guid();
-      });
-    };
-
-    _this.initGraph = function (width, height) {
-      var _assertThisInitialize2 = _assertThisInitialized(_this),
-          containerId = _assertThisInitialize2.containerId;
-
-      var _this$props = _this.props,
-          graphConfig = _this$props.graphConfig,
-          customModes = _this$props.customModes;
-      var modes = merge(behaviorManager.getRegisteredBehaviors(GraphType.Mind), {
-        "default": {
-          'click-item': {
-            type: 'click-item',
-            multiple: false
-          },
-          'collapse-expand': {
-            type: 'collapse-expand',
-            shouldBegin: _this.canCollapseExpand
-          },
-          'drag-canvas': {
-            type: 'drag-canvas',
-            shouldBegin: _this.canDragOrZoomCanvas,
-            shouldUpdate: _this.canDragOrZoomCanvas
-          },
-          'zoom-canvas': {
-            type: 'zoom-canvas',
-            shouldUpdate: _this.canDragOrZoomCanvas
-          }
-        }
-      });
-      Object.keys(modes).forEach(function (mode) {
-        var behaviors = modes[mode];
-        modes[mode] = Object.values(customModes ? customModes(mode, behaviors) : behaviors);
-      });
-      _this.graph = new G6.TreeGraph(_extends({
-        container: containerId,
-        width: width,
-        height: height,
-        modes: modes,
-        layout: {
-          type: 'mindmap',
-          direction: 'H',
-          getWidth: function getWidth() {
-            return 120;
-          },
-          getHeight: function getHeight() {
-            return 60;
-          },
-          getHGap: function getHGap() {
-            return 100;
-          },
-          getVGap: function getVGap() {
-            return 50;
-          },
-          getSide: function getSide(_ref2) {
-            var data = _ref2.data;
-
-            if (data.side) {
-              return data.side;
-            }
-
-            return 'right';
-          }
-        },
-        animate: false,
-        defaultNode: {
-          type: 'bizMindNode'
-        },
-        defaultEdge: {
-          type: 'bizMindEdge'
-        }
-      }, graphConfig));
-      return _this.graph;
-    };
-
-    return _this;
-  }
-
-  var _proto = Mind.prototype;
-
-  _proto.render = function render() {
-    var containerId = this.containerId,
-        parseData = this.parseData,
-        initGraph = this.initGraph;
-    var data = this.props.data;
-    return React.createElement(GraphComponent$1, Object.assign({
-      containerId: containerId,
-      data: data,
-      parseData: parseData,
-      initGraph: initGraph
-    }, omit(this.props, ['graphConfig', 'customModes'])));
-  };
-
-  return Mind;
-}(React.Component);
-
-Mind.defaultProps = {
-  graphConfig: {}
-};
-
-var Command = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Command, _React$Component);
-
-  function Command() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.state = {
-      disabled: false
-    };
-
-    _this.handleClick = function () {
-      var _this$props = _this.props,
-          name = _this$props.name,
-          executeCommand = _this$props.executeCommand;
-      executeCommand(name);
-    };
-
-    return _this;
-  }
-
-  var _proto = Command.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        name = _this$props2.name;
-    var commandManager = graph.get('commandManager');
-    this.setState({
-      disabled: !commandManager.canExecute(graph, name)
-    });
-    graph.on(EditorEvent.onGraphStateChange, function () {
-      _this2.setState({
-        disabled: !commandManager.canExecute(graph, name)
-      });
-    });
-  };
-
-  _proto.render = function render() {
-    var graph = this.props.graph;
-
-    if (!graph) {
-      return null;
-    }
-
-    var _this$props3 = this.props,
-        className = _this$props3.className,
-        disabledClassName = _this$props3.disabledClassName,
-        children = _this$props3.children;
-    var disabled = this.state.disabled;
-    return React.createElement("div", {
-      className: "" + className + (disabled ? " " + disabledClassName : ''),
-      onClick: this.handleClick
-    }, children);
-  };
-
-  return Command;
-}(React.Component);
-
-Command.defaultProps = {
-  className: 'command',
-  disabledClassName: 'command-disabled'
-};
-var index$2 = withEditorContext(Command);
-
-var Item = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Item, _React$Component);
-
-  function Item() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-
-    _this.handleMouseDown = function () {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          type = _this$props.type,
-          model = _this$props.model;
-
-      if (type === ItemType.Node) {
-        global.component.itemPanel.model = model;
-        graph.setMode(GraphMode.AddNode);
-      }
-    };
-
-    return _this;
-  }
-
-  var _proto = Item.prototype;
-
-  _proto.render = function render() {
-    var children = this.props.children;
-    return React.createElement("div", Object.assign({}, pick(this.props, ['style', 'className']), {
-      onMouseDown: this.handleMouseDown
-    }), children);
-  };
-
-  return Item;
-}(React.Component);
-
-Item.defaultProps = {
-  type: ItemType.Node
-};
-var Item$1 = withEditorContext(Item);
-
-var ItemPanel = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(ItemPanel, _React$Component);
-
-  function ItemPanel() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-
-    _this.handleMouseUp = function () {
-      var graph = _this.props.graph;
-
-      if (graph.getCurrentMode() === GraphMode.Default) {
-        return;
-      }
-
-      var group = graph.get('group');
-      var shape = group.findByClassName(global.component.itemPanel.delegateShapeClassName);
-
-      if (shape) {
-        shape.remove(true);
-        graph.paint();
-      }
-
-      global.component.itemPanel.model = null;
-      graph.setMode(GraphMode.Default);
-    };
-
-    return _this;
-  }
-
-  var _proto = ItemPanel.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    document.addEventListener('mouseup', this.handleMouseUp, false);
-  };
-
-  _proto.componentWillUnmount = function componentWillUnmount() {
-    document.removeEventListener('mouseup', this.handleMouseUp, false);
-  };
-
-  _proto.render = function render() {
-    var children = this.props.children;
-    return React.createElement("div", Object.assign({}, pick(this.props, ['style', 'className'])), children);
-  };
-
-  return ItemPanel;
-}(React.Component);
-
-ItemPanel.Item = Item$1;
-var index$3 = withEditorContext(ItemPanel);
-
-var DetailPanel = function DetailPanel() {};
-
-DetailPanel.create = function (type) {
-  return function (WrappedComponent) {
-    var TypedPanel = /*#__PURE__*/function (_React$Component) {
-      _inheritsLoose(TypedPanel, _React$Component);
-
-      function TypedPanel() {
-        var _this;
-
-        _this = _React$Component.apply(this, arguments) || this;
-        _this.state = {
-          graphState: GraphState.CanvasSelected
-        };
-        return _this;
-      }
-
-      var _proto = TypedPanel.prototype;
-
-      _proto.componentDidMount = function componentDidMount() {
-        var _this2 = this;
-
-        var graph = this.props.graph;
-        graph.on(EditorEvent.onGraphStateChange, function (_ref) {
-          var graphState = _ref.graphState;
-
-          _this2.setState({
-            graphState: graphState
-          });
-        });
-      };
-
-      _proto.render = function render() {
-        var graph = this.props.graph;
-        var graphState = this.state.graphState;
-
-        if (graphState !== type + "Selected") {
-          return null;
-        }
-
-        var nodes = getSelectedNodes(graph);
-        var edges = getSelectedEdges(graph);
-        return React.createElement(WrappedComponent, Object.assign({
-          type: type,
-          nodes: nodes,
-          edges: edges
-        }, this.props));
-      };
-
-      return TypedPanel;
-    }(React.Component);
-
-    return withEditorContext(TypedPanel);
-  };
-};
-
-var Register = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(Register, _React$Component);
-
-  function Register(props, type) {
-    var _this;
-
-    _this = _React$Component.call(this, props) || this;
-    var name = props.name,
-        config = props.config,
-        extend = props.extend,
-        commandManager = props.commandManager;
-
-    switch (type) {
-      case 'node':
-        G6.registerNode(name, config, extend);
-        break;
-
-      case 'edge':
-        G6.registerEdge(name, config, extend);
-        break;
-
-      case 'command':
-        commandManager.register(name, config);
-        break;
-
-      case 'behavior':
-        behaviorManager.register(name, config);
-        break;
-    }
-
-    return _this;
-  }
-
-  var _proto = Register.prototype;
-
-  _proto.render = function render() {
-    return null;
-  };
-
-  return Register;
-}(React.Component);
-
-Register.create = function (type) {
-  var TypedRegister = /*#__PURE__*/function (_Register) {
-    _inheritsLoose(TypedRegister, _Register);
-
-    function TypedRegister(props) {
-      return _Register.call(this, props, type) || this;
-    }
-
-    return TypedRegister;
-  }(Register);
-
-  return withEditorPrivateContext(TypedRegister);
-};
-
-var RegisterNode = Register.create('node');
-var RegisterEdge = Register.create('edge');
-var RegisterCommand = Register.create('command');
-var RegisterBehavior = Register.create('behavior');
-
-var ItemPopoverType;
-
-(function (ItemPopoverType) {
-  ItemPopoverType["Node"] = "node";
-  ItemPopoverType["Edge"] = "edge";
-})(ItemPopoverType || (ItemPopoverType = {}));
-
-var ItemPopover = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(ItemPopover, _React$Component);
-
-  function ItemPopover() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.state = {
-      visible: false,
-      content: null
-    };
-    _this.mouseEnterTimeoutID = 0;
-    _this.mouseLeaveTimeoutID = 0;
-
-    _this.showItemPopover = function (item) {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          renderContent = _this$props.renderContent;
-      global.plugin.itemPopover.state = 'show';
-
-      var _item$getBBox = item.getBBox(),
-          minX = _item$getBBox.minX,
-          minY = _item$getBBox.minY,
-          maxX = _item$getBBox.maxX,
-          maxY = _item$getBBox.maxY,
-          centerX = _item$getBBox.centerX,
-          centerY = _item$getBBox.centerY;
-
-      var _graph$getCanvasByPoi = graph.getCanvasByPoint(minX, minY),
-          itemMinX = _graph$getCanvasByPoi.x,
-          itemMinY = _graph$getCanvasByPoi.y;
-
-      var _graph$getCanvasByPoi2 = graph.getCanvasByPoint(maxX, maxY),
-          itemMaxX = _graph$getCanvasByPoi2.x,
-          itemMaxY = _graph$getCanvasByPoi2.y;
-
-      var _graph$getCanvasByPoi3 = graph.getCanvasByPoint(centerX, centerY),
-          itemCenterX = _graph$getCanvasByPoi3.x,
-          itemCenterY = _graph$getCanvasByPoi3.y;
-
-      var position = {
-        minX: itemMinX,
-        minY: itemMinY,
-        maxX: itemMaxX,
-        maxY: itemMaxY,
-        centerX: itemCenterX,
-        centerY: itemCenterY
-      };
-
-      _this.setState({
-        visible: true,
-        content: renderContent(item, position)
-      });
-    };
-
-    _this.hideItemPopover = function () {
-      global.plugin.itemPopover.state = 'hide';
-
-      _this.setState({
-        visible: false,
-        content: null
-      });
-    };
-
-    return _this;
-  }
-
-  var _proto = ItemPopover.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        type = _this$props2.type;
-
-    if (type === ItemPopoverType.Node) {
-      graph.on(GraphNodeEvent.onNodeMouseEnter, function (_ref) {
-        var item = _ref.item;
-        clearTimeout(_this2.mouseLeaveTimeoutID);
-        _this2.mouseEnterTimeoutID = delay(_this2.showItemPopover, 250, item);
-      });
-      graph.on(GraphNodeEvent.onNodeMouseLeave, function () {
-        clearTimeout(_this2.mouseEnterTimeoutID);
-        _this2.mouseLeaveTimeoutID = delay(_this2.hideItemPopover, 250);
-      });
-    }
-  };
-
-  _proto.render = function render() {
-    var graph = this.props.graph;
-    var _this$state = this.state,
-        visible = _this$state.visible,
-        content = _this$state.content;
-
-    if (!visible) {
-      return null;
-    }
-
-    return ReactDOM.createPortal(content, graph.get('container'));
-  };
-
-  return ItemPopover;
-}(React.Component);
-
-ItemPopover.defaultProps = {
-  type: ItemPopoverType.Node
-};
-var index$4 = withEditorContext(ItemPopover);
-
-var ContextMenuType;
-
-(function (ContextMenuType) {
-  ContextMenuType["Canvas"] = "canvas";
-  ContextMenuType["Node"] = "node";
-  ContextMenuType["Edge"] = "edge";
-})(ContextMenuType || (ContextMenuType = {}));
-
-var ContextMenu = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(ContextMenu, _React$Component);
-
-  function ContextMenu() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.state = {
-      visible: false,
-      content: null
-    };
-
-    _this.showContextMenu = function (x, y, item) {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          renderContent = _this$props.renderContent;
-      clearSelectedState(graph);
-
-      if (item) {
-        graph.setItemState(item, ItemState.Selected, true);
-      }
-
-      global.plugin.contextMenu.state = 'show';
-      global.clipboard.point = {
-        x: x,
-        y: y
-      };
-      var position = graph.getCanvasByPoint(x, y);
-
-      _this.setState({
-        visible: true,
-        content: renderContent(item, position, _this.hideContextMenu)
-      });
-    };
-
-    _this.hideContextMenu = function () {
-      global.plugin.contextMenu.state = 'hide';
-
-      _this.setState({
-        visible: false,
-        content: null
-      });
-    };
-
-    return _this;
-  }
-
-  var _proto = ContextMenu.prototype;
-
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
-
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        type = _this$props2.type;
-
-    switch (type) {
-      case ContextMenuType.Canvas:
-        graph.on(GraphCanvasEvent.onCanvasContextMenu, function (e) {
-          e.preventDefault();
-          var x = e.x,
-              y = e.y;
-
-          _this2.showContextMenu(x, y);
-        });
-        break;
-
-      case ContextMenuType.Node:
-        graph.on(GraphNodeEvent.onNodeContextMenu, function (e) {
-          e.preventDefault();
-          var x = e.x,
-              y = e.y,
-              item = e.item;
-
-          _this2.showContextMenu(x, y, item);
-        });
-        break;
-
-      case ContextMenuType.Edge:
-        graph.on(GraphEdgeEvent.onEdgeContextMenu, function (e) {
-          e.preventDefault();
-          var x = e.x,
-              y = e.y,
-              item = e.item;
-
-          _this2.showContextMenu(x, y, item);
-        });
-        break;
-    }
-
-    graph.on(GraphCommonEvent.onClick, function () {
-      _this2.hideContextMenu();
-    });
-  };
-
-  _proto.render = function render() {
-    var graph = this.props.graph;
-    var _this$state = this.state,
-        visible = _this$state.visible,
-        content = _this$state.content;
-
-    if (!visible) {
-      return null;
-    }
-
-    return ReactDOM.createPortal(content, graph.get('container'));
-  };
-
-  return ContextMenu;
-}(React.Component);
-
-ContextMenu.defaultProps = {
-  type: ContextMenuType.Canvas
-};
-var index$5 = withEditorContext(ContextMenu);
-
-var EditableLabel = /*#__PURE__*/function (_React$Component) {
-  _inheritsLoose(EditableLabel, _React$Component);
-
-  function EditableLabel() {
-    var _this;
-
-    _this = _React$Component.apply(this, arguments) || this;
-    _this.el = null;
-    _this.state = {
-      visible: false
-    };
-
-    _this.update = function () {
-      var _this$props = _this.props,
-          graph = _this$props.graph,
-          executeCommand = _this$props.executeCommand;
-      var node = getSelectedNodes(graph)[0];
-      var model = node.getModel();
-      var label = _this.el.textContent;
-
-      if (label === model.label) {
-        return;
-      }
-
-      executeCommand('update', {
-        id: model.id,
-        updateModel: {
-          label: label
-        },
-        forceRefreshLayout: isMind(graph)
-      });
-    };
-
-    _this.showEditableLabel = function () {
-      global.plugin.editableLabel.state = 'show';
-
-      _this.setState({
-        visible: true
-      }, function () {
-        var _assertThisInitialize = _assertThisInitialized(_this),
-            el = _assertThisInitialize.el;
-
-        if (el) {
-          el.focus();
-          document.execCommand('selectAll', false, null);
-        }
-      });
-    };
-
-    _this.hideEditableLabel = function () {
-      global.plugin.editableLabel.state = 'hide';
-
-      _this.setState({
-        visible: false
-      });
-    };
-
-    _this.handleBlur = function () {
-      _this.update();
-
-      _this.hideEditableLabel();
-    };
-
-    _this.handleKeyDown = function (e) {
-      e.stopPropagation();
-      var key = e.key;
-
-      if (['Tab'].includes(key)) {
-        e.preventDefault();
-      }
-
-      if (['Enter', 'Escape', 'Tab'].includes(key)) {
-        _this.update();
-
-        _this.hideEditableLabel();
-      }
-    };
-
-    return _this;
-  }
+require("./shape");
 
-  var _proto = EditableLabel.prototype;
+var Util = _interopRequireWildcard(require("./utils"));
 
-  _proto.componentDidMount = function componentDidMount() {
-    var _this2 = this;
+exports.Util = Util;
 
-    var graph = this.props.graph;
-    graph.on(EditorEvent.onLabelStateChange, function (_ref) {
-      var labelState = _ref.labelState;
+var _Editor = _interopRequireDefault(require("./components/Editor"));
 
-      if (labelState === LabelState.Show) {
-        _this2.showEditableLabel();
-      } else {
-        _this2.hideEditableLabel();
-      }
-    });
-    graph.on(GraphNodeEvent.onNodeDoubleClick, function () {
-      _this2.showEditableLabel();
-    });
-  };
+var _Flow = _interopRequireDefault(require("./components/Flow"));
 
-  _proto.render = function render() {
-    var _this3 = this;
+var _Mind = _interopRequireDefault(require("./components/Mind"));
 
-    var _this$props2 = this.props,
-        graph = _this$props2.graph,
-        labelClassName = _this$props2.labelClassName,
-        labelMaxWidth = _this$props2.labelMaxWidth;
-    var mode = graph.getCurrentMode();
-    var zoom = graph.getZoom();
+var _Command = _interopRequireDefault(require("./components/Command"));
 
-    if (mode === GraphMode.Readonly) {
-      return null;
-    }
+var _ItemPanel = _interopRequireWildcard(require("./components/ItemPanel"));
 
-    var node = getSelectedNodes(graph)[0];
+var _DetailPanel = _interopRequireDefault(require("./components/DetailPanel"));
 
-    if (!node) {
-      return null;
-    }
+var _Register = require("./components/Register");
 
-    var model = node.getModel();
-    var group = node.getContainer();
-    var label = model.label;
-    var labelShape = group.findByClassName(labelClassName);
+var _EditorContext = require("./components/EditorContext");
 
-    if (!labelShape) {
-      return null;
-    }
+var _base = require("./components/Graph/command/base");
 
-    var visible = this.state.visible;
+var _ItemPopover = _interopRequireDefault(require("./plugins/ItemPopover"));
 
-    if (!visible) {
-      return null;
-    } // Get the label offset
+var _ContextMenu = _interopRequireDefault(require("./plugins/ContextMenu"));
 
+var _EditableLabel = _interopRequireDefault(require("./plugins/EditableLabel"));
 
-    var _labelShape$getBBox = labelShape.getBBox(),
-        relativeX = _labelShape$getBBox.x,
-        relativeY = _labelShape$getBBox.y;
+var _global = _interopRequireDefault(require("./common/global"));
 
-    var _G6$Util$applyMatrix = G6.Util.applyMatrix({
-      x: relativeX,
-      y: relativeY
-    }, node.getContainer().getMatrix()),
-        absoluteX = _G6$Util$applyMatrix.x,
-        absoluteY = _G6$Util$applyMatrix.y;
+var constants = _interopRequireWildcard(require("./common/constants"));
 
-    var _graph$getCanvasByPoi = graph.getCanvasByPoint(absoluteX, absoluteY),
-        left = _graph$getCanvasByPoi.x,
-        top = _graph$getCanvasByPoi.y; // Get the label size
+exports.constants = constants;
 
+var _CommandManager = _interopRequireDefault(require("./common/CommandManager"));
 
-    var _labelShape$getBBox2 = labelShape.getBBox(),
-        width = _labelShape$getBBox2.width,
-        height = _labelShape$getBBox2.height; // Get the label font
+var _behaviorManager = _interopRequireDefault(require("./common/behaviorManager"));
 
+var _anchor = require("./shape/common/anchor");
 
-    var font = labelShape.attr('font');
-    var style = {
-      position: 'absolute',
-      top: top,
-      left: left,
-      width: 'auto',
-      height: 'auto',
-      minWidth: width,
-      minHeight: height,
-      maxWidth: labelMaxWidth,
-      font: font,
-      background: 'white',
-      border: '1px solid #1890ff',
-      outline: 'none',
-      transform: "scale(" + zoom + ")",
-      transformOrigin: 'left top'
-    };
-    return ReactDOM.createPortal(React.createElement("div", {
-      ref: function ref(el) {
-        _this3.el = el;
-      },
-      style: style,
-      contentEditable: true,
-      onBlur: this.handleBlur,
-      onKeyDown: this.handleKeyDown,
-      suppressContentEditableWarning: true
-    }, label), graph.get('container'));
-  };
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }
 
-  return EditableLabel;
-}(React.Component);
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
 
-EditableLabel.defaultProps = {
-  labelClassName: 'node-label',
-  labelMaxWidth: 100
-};
-var index$6 = withEditorContext(EditableLabel);
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
 
-exports.G6 = G6;
-exports.Command = index$2;
-exports.CommandManager = CommandManager;
-exports.ContextMenu = index$5;
-exports.DetailPanel = DetailPanel;
-exports.EditableLabel = index$6;
-exports.Flow = Flow;
-exports.Item = Item$1;
-exports.ItemPanel = index$3;
-exports.ItemPopover = index$4;
-exports.Mind = Mind;
-exports.RegisterBehavior = RegisterBehavior;
-exports.RegisterCommand = RegisterCommand;
-exports.RegisterEdge = RegisterEdge;
-exports.RegisterNode = RegisterNode;
-exports.Util = index$1;
-exports.baseCommand = baseCommand;
-exports.behaviorManager = behaviorManager;
-exports.constants = index;
-exports.default = Editor;
-exports.global = global;
-exports.setAnchorPointsState = setAnchorPointsState;
-exports.withEditorContext = withEditorContext;
+var _default = _Editor["default"];
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/plugins/ContextMenu/index.d.ts b/node_modules/gg-editor/lib/plugins/ContextMenu/index.d.ts
index a1990cf..614b8e2 100644
--- a/node_modules/gg-editor/lib/plugins/ContextMenu/index.d.ts
+++ b/node_modules/gg-editor/lib/plugins/ContextMenu/index.d.ts
@@ -15,5 +15,5 @@ interface ContextMenuProps extends EditorContextProps {
         y: number;
     }, hide: () => void) => React.ReactNode;
 }
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ContextMenuProps>, "type" | "renderContent" | "children"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ContextMenuProps>, "type" | "children" | "renderContent"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/plugins/ContextMenu/index.js b/node_modules/gg-editor/lib/plugins/ContextMenu/index.js
new file mode 100644
index 0000000..ee2010f
--- /dev/null
+++ b/node_modules/gg-editor/lib/plugins/ContextMenu/index.js
@@ -0,0 +1,184 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = exports.ContextMenuType = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _reactDom = _interopRequireDefault(require("react-dom"));
+
+var _utils = require("../../utils");
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../../components/EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var ContextMenuType;
+exports.ContextMenuType = ContextMenuType;
+
+(function (ContextMenuType) {
+  ContextMenuType["Canvas"] = "canvas";
+  ContextMenuType["Node"] = "node";
+  ContextMenuType["Edge"] = "edge";
+})(ContextMenuType || (exports.ContextMenuType = ContextMenuType = {}));
+
+var ContextMenu =
+/** @class */
+function () {
+  var ContextMenu = /*#__PURE__*/function (_React$Component) {
+    _inherits(ContextMenu, _React$Component);
+
+    var _super = _createSuper(ContextMenu);
+
+    function ContextMenu() {
+      var _this;
+
+      _classCallCheck(this, ContextMenu);
+
+      _this = _super.apply(this, arguments);
+      _this.state = {
+        visible: false,
+        content: null
+      };
+
+      _this.showContextMenu = function (x, y, item) {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            renderContent = _this$props.renderContent;
+        (0, _utils.clearSelectedState)(graph);
+
+        if (item) {
+          graph.setItemState(item, _constants.ItemState.Selected, true);
+        }
+
+        _global["default"].plugin.contextMenu.state = 'show';
+        _global["default"].clipboard.point = {
+          x: x,
+          y: y
+        };
+        var position = graph.getCanvasByPoint(x, y);
+
+        _this.setState({
+          visible: true,
+          content: renderContent(item, position, _this.hideContextMenu)
+        });
+      };
+
+      _this.hideContextMenu = function () {
+        _global["default"].plugin.contextMenu.state = 'hide';
+
+        _this.setState({
+          visible: false,
+          content: null
+        });
+      };
+
+      return _this;
+    }
+
+    _createClass(ContextMenu, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            type = _this$props2.type;
+
+        switch (type) {
+          case ContextMenuType.Canvas:
+            graph.on(_constants.GraphCanvasEvent.onCanvasContextMenu, function (e) {
+              e.preventDefault();
+              var x = e.x,
+                  y = e.y;
+
+              _this2.showContextMenu(x, y);
+            });
+            break;
+
+          case ContextMenuType.Node:
+            graph.on(_constants.GraphNodeEvent.onNodeContextMenu, function (e) {
+              e.preventDefault();
+              var x = e.x,
+                  y = e.y,
+                  item = e.item;
+
+              _this2.showContextMenu(x, y, item);
+            });
+            break;
+
+          case ContextMenuType.Edge:
+            graph.on(_constants.GraphEdgeEvent.onEdgeContextMenu, function (e) {
+              e.preventDefault();
+              var x = e.x,
+                  y = e.y,
+                  item = e.item;
+
+              _this2.showContextMenu(x, y, item);
+            });
+            break;
+
+          default:
+            break;
+        }
+
+        graph.on(_constants.GraphCommonEvent.onClick, function () {
+          _this2.hideContextMenu();
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var graph = this.props.graph;
+        var _this$state = this.state,
+            visible = _this$state.visible,
+            content = _this$state.content;
+
+        if (!visible) {
+          return null;
+        }
+
+        return /*#__PURE__*/_reactDom["default"].createPortal(content, graph.get('container'));
+      }
+    }]);
+
+    return ContextMenu;
+  }(_react["default"].Component);
+
+  ContextMenu.defaultProps = {
+    type: ContextMenuType.Canvas
+  };
+  return ContextMenu;
+}();
+
+var _default = (0, _EditorContext.withEditorContext)(ContextMenu);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/plugins/EditableLabel/index.d.ts b/node_modules/gg-editor/lib/plugins/EditableLabel/index.d.ts
index 1750824..bf47e1d 100644
--- a/node_modules/gg-editor/lib/plugins/EditableLabel/index.d.ts
+++ b/node_modules/gg-editor/lib/plugins/EditableLabel/index.d.ts
@@ -6,5 +6,5 @@ interface EditableLabelProps extends EditorContextProps {
     /** 标签最大宽度 */
     labelMaxWidth?: number;
 }
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<EditableLabelProps>, "labelClassName" | "labelMaxWidth" | "children"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<EditableLabelProps>, "children" | "labelClassName" | "labelMaxWidth"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/plugins/EditableLabel/index.js b/node_modules/gg-editor/lib/plugins/EditableLabel/index.js
new file mode 100644
index 0000000..0381aae
--- /dev/null
+++ b/node_modules/gg-editor/lib/plugins/EditableLabel/index.js
@@ -0,0 +1,254 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _reactDom = _interopRequireDefault(require("react-dom"));
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _utils = require("../../utils");
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../../components/EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var EditableLabel =
+/** @class */
+function () {
+  var EditableLabel = /*#__PURE__*/function (_React$Component) {
+    _inherits(EditableLabel, _React$Component);
+
+    var _super = _createSuper(EditableLabel);
+
+    function EditableLabel() {
+      var _this;
+
+      _classCallCheck(this, EditableLabel);
+
+      _this = _super.apply(this, arguments);
+      _this.el = null;
+      _this.state = {
+        visible: false
+      };
+
+      _this.update = function () {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            executeCommand = _this$props.executeCommand;
+        var node = (0, _utils.getSelectedNodes)(graph)[0];
+        var model = node.getModel();
+        var label = _this.el.textContent;
+
+        if (label === model.label) {
+          return;
+        }
+
+        executeCommand('update', {
+          id: model.id,
+          updateModel: {
+            label: label
+          },
+          forceRefreshLayout: (0, _utils.isMind)(graph)
+        });
+      };
+
+      _this.showEditableLabel = function () {
+        _global["default"].plugin.editableLabel.state = 'show';
+
+        _this.setState({
+          visible: true
+        }, function () {
+          var _assertThisInitialize = _assertThisInitialized(_this),
+              el = _assertThisInitialize.el;
+
+          if (el) {
+            el.focus();
+            document.execCommand('selectAll', false, null);
+          }
+        });
+      };
+
+      _this.hideEditableLabel = function () {
+        _global["default"].plugin.editableLabel.state = 'hide';
+
+        _this.setState({
+          visible: false
+        });
+      };
+
+      _this.handleBlur = function () {
+        _this.update();
+
+        _this.hideEditableLabel();
+      };
+
+      _this.handleKeyDown = function (e) {
+        e.stopPropagation();
+        var key = e.key;
+
+        if (['Tab'].includes(key)) {
+          e.preventDefault();
+        }
+
+        if (['Enter', 'Escape', 'Tab'].includes(key)) {
+          _this.update();
+
+          _this.hideEditableLabel();
+        }
+      };
+
+      return _this;
+    }
+
+    _createClass(EditableLabel, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var graph = this.props.graph;
+        graph.on(_constants.EditorEvent.onLabelStateChange, function (_ref) {
+          var labelState = _ref.labelState;
+
+          if (labelState === _constants.LabelState.Show) {
+            _this2.showEditableLabel();
+          } else {
+            _this2.hideEditableLabel();
+          }
+        });
+        graph.on(_constants.GraphNodeEvent.onNodeDoubleClick, function () {
+          _this2.showEditableLabel();
+        });
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var _this3 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            labelClassName = _this$props2.labelClassName,
+            labelMaxWidth = _this$props2.labelMaxWidth;
+        var mode = graph.getCurrentMode();
+        var zoom = graph.getZoom();
+
+        if (mode === _constants.GraphMode.Readonly) {
+          return null;
+        }
+
+        var node = (0, _utils.getSelectedNodes)(graph)[0];
+
+        if (!node) {
+          return null;
+        }
+
+        var model = node.getModel();
+        var group = node.getContainer();
+        var label = model.label;
+        var labelShape = group.findByClassName(labelClassName);
+
+        if (!labelShape) {
+          return null;
+        }
+
+        var visible = this.state.visible;
+
+        if (!visible) {
+          return null;
+        } // Get the label offset
+
+
+        var _labelShape$getBBox = labelShape.getBBox(),
+            relativeX = _labelShape$getBBox.x,
+            relativeY = _labelShape$getBBox.y;
+
+        var _G6$Util$applyMatrix = _g["default"].Util.applyMatrix({
+          x: relativeX,
+          y: relativeY
+        }, node.getContainer().getMatrix()),
+            absoluteX = _G6$Util$applyMatrix.x,
+            absoluteY = _G6$Util$applyMatrix.y;
+
+        var _graph$getCanvasByPoi = graph.getCanvasByPoint(absoluteX, absoluteY),
+            left = _graph$getCanvasByPoi.x,
+            top = _graph$getCanvasByPoi.y; // Get the label size
+
+
+        var _labelShape$getBBox2 = labelShape.getBBox(),
+            width = _labelShape$getBBox2.width,
+            height = _labelShape$getBBox2.height; // Get the label font
+
+
+        var font = labelShape.attr('font');
+        var style = {
+          position: 'absolute',
+          top: top,
+          left: left,
+          width: 'auto',
+          height: 'auto',
+          minWidth: width,
+          minHeight: height,
+          maxWidth: labelMaxWidth,
+          font: font,
+          background: 'white',
+          border: '1px solid #1890ff',
+          outline: 'none',
+          transform: "scale(".concat(zoom, ")"),
+          transformOrigin: 'left top'
+        };
+        return /*#__PURE__*/_reactDom["default"].createPortal( /*#__PURE__*/_react["default"].createElement("div", {
+          ref: function ref(el) {
+            _this3.el = el;
+          },
+          style: style,
+          contentEditable: true,
+          onBlur: this.handleBlur,
+          onKeyDown: this.handleKeyDown,
+          suppressContentEditableWarning: true
+        }, label), graph.get('container'));
+      }
+    }]);
+
+    return EditableLabel;
+  }(_react["default"].Component);
+
+  EditableLabel.defaultProps = {
+    labelClassName: 'node-label',
+    labelMaxWidth: 100
+  };
+  return EditableLabel;
+}();
+
+var _default = (0, _EditorContext.withEditorContext)(EditableLabel);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/plugins/ItemPopover/index.d.ts b/node_modules/gg-editor/lib/plugins/ItemPopover/index.d.ts
index 7219168..fe8f17e 100644
--- a/node_modules/gg-editor/lib/plugins/ItemPopover/index.d.ts
+++ b/node_modules/gg-editor/lib/plugins/ItemPopover/index.d.ts
@@ -18,5 +18,5 @@ interface ItemPopoverProps extends EditorContextProps {
         centerY: number;
     }) => React.ReactNode;
 }
-declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemPopoverProps>, "type" | "renderContent" | "children"> & React.RefAttributes<unknown>>;
+declare const _default: React.ForwardRefExoticComponent<Pick<React.PropsWithChildren<ItemPopoverProps>, "type" | "children" | "renderContent"> & React.RefAttributes<unknown>>;
 export default _default;
diff --git a/node_modules/gg-editor/lib/plugins/ItemPopover/index.js b/node_modules/gg-editor/lib/plugins/ItemPopover/index.js
new file mode 100644
index 0000000..e2f4cd2
--- /dev/null
+++ b/node_modules/gg-editor/lib/plugins/ItemPopover/index.js
@@ -0,0 +1,174 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports["default"] = exports.ItemPopoverType = void 0;
+
+var _react = _interopRequireDefault(require("react"));
+
+var _reactDom = _interopRequireDefault(require("react-dom"));
+
+var _delay = _interopRequireDefault(require("lodash/delay"));
+
+var _global = _interopRequireDefault(require("../../common/global"));
+
+var _constants = require("../../common/constants");
+
+var _EditorContext = require("../../components/EditorContext");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
+
+function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
+
+function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
+
+function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
+
+function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
+
+function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
+
+function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
+
+function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }
+
+function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
+
+function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
+
+function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
+
+var ItemPopoverType;
+exports.ItemPopoverType = ItemPopoverType;
+
+(function (ItemPopoverType) {
+  ItemPopoverType["Node"] = "node";
+  ItemPopoverType["Edge"] = "edge";
+})(ItemPopoverType || (exports.ItemPopoverType = ItemPopoverType = {}));
+
+var ItemPopover =
+/** @class */
+function () {
+  var ItemPopover = /*#__PURE__*/function (_React$Component) {
+    _inherits(ItemPopover, _React$Component);
+
+    var _super = _createSuper(ItemPopover);
+
+    function ItemPopover() {
+      var _this;
+
+      _classCallCheck(this, ItemPopover);
+
+      _this = _super.apply(this, arguments);
+      _this.state = {
+        visible: false,
+        content: null
+      };
+      _this.mouseEnterTimeoutID = 0;
+      _this.mouseLeaveTimeoutID = 0;
+
+      _this.showItemPopover = function (item) {
+        var _this$props = _this.props,
+            graph = _this$props.graph,
+            renderContent = _this$props.renderContent;
+        _global["default"].plugin.itemPopover.state = 'show';
+
+        var _item$getBBox = item.getBBox(),
+            minX = _item$getBBox.minX,
+            minY = _item$getBBox.minY,
+            maxX = _item$getBBox.maxX,
+            maxY = _item$getBBox.maxY,
+            centerX = _item$getBBox.centerX,
+            centerY = _item$getBBox.centerY;
+
+        var _graph$getCanvasByPoi = graph.getCanvasByPoint(minX, minY),
+            itemMinX = _graph$getCanvasByPoi.x,
+            itemMinY = _graph$getCanvasByPoi.y;
+
+        var _graph$getCanvasByPoi2 = graph.getCanvasByPoint(maxX, maxY),
+            itemMaxX = _graph$getCanvasByPoi2.x,
+            itemMaxY = _graph$getCanvasByPoi2.y;
+
+        var _graph$getCanvasByPoi3 = graph.getCanvasByPoint(centerX, centerY),
+            itemCenterX = _graph$getCanvasByPoi3.x,
+            itemCenterY = _graph$getCanvasByPoi3.y;
+
+        var position = {
+          minX: itemMinX,
+          minY: itemMinY,
+          maxX: itemMaxX,
+          maxY: itemMaxY,
+          centerX: itemCenterX,
+          centerY: itemCenterY
+        };
+
+        _this.setState({
+          visible: true,
+          content: renderContent(item, position)
+        });
+      };
+
+      _this.hideItemPopover = function () {
+        _global["default"].plugin.itemPopover.state = 'hide';
+
+        _this.setState({
+          visible: false,
+          content: null
+        });
+      };
+
+      return _this;
+    }
+
+    _createClass(ItemPopover, [{
+      key: "componentDidMount",
+      value: function componentDidMount() {
+        var _this2 = this;
+
+        var _this$props2 = this.props,
+            graph = _this$props2.graph,
+            type = _this$props2.type;
+
+        if (type === ItemPopoverType.Node) {
+          graph.on(_constants.GraphNodeEvent.onNodeMouseEnter, function (_ref) {
+            var item = _ref.item;
+            clearTimeout(_this2.mouseLeaveTimeoutID);
+            _this2.mouseEnterTimeoutID = (0, _delay["default"])(_this2.showItemPopover, 250, item);
+          });
+          graph.on(_constants.GraphNodeEvent.onNodeMouseLeave, function () {
+            clearTimeout(_this2.mouseEnterTimeoutID);
+            _this2.mouseLeaveTimeoutID = (0, _delay["default"])(_this2.hideItemPopover, 250);
+          });
+        }
+      }
+    }, {
+      key: "render",
+      value: function render() {
+        var graph = this.props.graph;
+        var _this$state = this.state,
+            visible = _this$state.visible,
+            content = _this$state.content;
+
+        if (!visible) {
+          return null;
+        }
+
+        return /*#__PURE__*/_reactDom["default"].createPortal(content, graph.get('container'));
+      }
+    }]);
+
+    return ItemPopover;
+  }(_react["default"].Component);
+
+  ItemPopover.defaultProps = {
+    type: ItemPopoverType.Node
+  };
+  return ItemPopover;
+}();
+
+var _default = (0, _EditorContext.withEditorContext)(ItemPopover);
+
+exports["default"] = _default;
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/common/anchor.js b/node_modules/gg-editor/lib/shape/common/anchor.js
new file mode 100644
index 0000000..1ed99ed
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/common/anchor.js
@@ -0,0 +1,118 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.setAnchorPointsState = setAnchorPointsState;
+
+var _constants = require("../../common/constants");
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+var ANCHOR_POINT_NAME = 'anchorPoint';
+
+var getAnchorPointDefaultStyle = function getAnchorPointDefaultStyle(item, anchorPoint) {
+  var _item$getKeyShape$get = item.getKeyShape().getBBox(),
+      width = _item$getKeyShape$get.width,
+      height = _item$getKeyShape$get.height;
+
+  var _anchorPoint = _slicedToArray(anchorPoint, 2),
+      x = _anchorPoint[0],
+      y = _anchorPoint[1];
+
+  return {
+    x: width * x,
+    y: height * y - 3,
+    r: 3,
+    lineWidth: 2,
+    fill: '#FFFFFF',
+    stroke: '#5AAAFF'
+  };
+};
+
+var getAnchorPointDefaultDisabledStyle = function getAnchorPointDefaultDisabledStyle(item, anchorPoint) {
+  var _item$getKeyShape$get2 = item.getKeyShape().getBBox(),
+      width = _item$getKeyShape$get2.width,
+      height = _item$getKeyShape$get2.height;
+
+  var _anchorPoint2 = _slicedToArray(anchorPoint, 2),
+      x = _anchorPoint2[0],
+      y = _anchorPoint2[1];
+
+  return {
+    img: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI4IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0xLjUxNSAxLjE3Mmw1LjY1NyA1LjY1Nm0wLTUuNjU2TDEuNTE1IDYuODI4IiBzdHJva2U9IiNGRjYwNjAiIHN0cm9rZS13aWR0aD0iMS42IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIi8+PC9zdmc+',
+    x: width * x - 4,
+    y: height * y - 8,
+    width: 8,
+    height: 8
+  };
+};
+
+function drawAnchorPoints(item, getAnchorPointStyle, getAnchorPointDisabledStyle) {
+  var group = item.getContainer();
+  var model = item.getModel();
+  var anchorPoints = this.getAnchorPoints ? this.getAnchorPoints(model) : [];
+  var anchorPointsState = item.get('anchorPointsState') || [];
+  anchorPoints.forEach(function (anchorPoint, index) {
+    if (anchorPointsState[index] === _constants.AnchorPointState.Enabled) {
+      group.addShape('circle', {
+        name: ANCHOR_POINT_NAME,
+        attrs: _objectSpread(_objectSpread({}, getAnchorPointDefaultStyle(item, anchorPoint)), getAnchorPointStyle(item, anchorPoint)),
+        isAnchorPoint: true,
+        anchorPointIndex: index,
+        anchorPointState: _constants.AnchorPointState.Enabled
+      });
+    } else {
+      group.addShape('image', {
+        name: ANCHOR_POINT_NAME,
+        attrs: _objectSpread(_objectSpread({}, getAnchorPointDefaultDisabledStyle(item, anchorPoint)), getAnchorPointDisabledStyle(item, anchorPoint)),
+        isAnchorPoint: true,
+        anchorPointIndex: index,
+        anchorPointState: _constants.AnchorPointState.Disabled
+      });
+    }
+  });
+}
+
+function removeAnchorPoints(item) {
+  var group = item.getContainer();
+  var anchorPoints = group.findAllByName(ANCHOR_POINT_NAME);
+  anchorPoints.forEach(function (anchorPoint) {
+    group.removeChild(anchorPoint);
+  });
+}
+
+function setAnchorPointsState(name, value, item) {
+  var getAnchorPointStyle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {
+    return {};
+  };
+  var getAnchorPointDisabledStyle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {
+    return {};
+  };
+
+  if (name !== _constants.ItemState.ActiveAnchorPoints) {
+    return;
+  }
+
+  if (value) {
+    drawAnchorPoints.call(this, item, getAnchorPointStyle, getAnchorPointDisabledStyle);
+  } else {
+    removeAnchorPoints.call(this, item);
+  }
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/edges/bizFlowEdge.js b/node_modules/gg-editor/lib/shape/edges/bizFlowEdge.js
new file mode 100644
index 0000000..0c3ace0
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/edges/bizFlowEdge.js
@@ -0,0 +1,139 @@
+"use strict";
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _constants = require("../../common/constants");
+
+var _stateStyles;
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var EDGE_LABEL_CLASS_NAME = 'edge-label';
+var EDGE_LABEL_WRAPPER_CLASS_NAME = 'edge-label-wrapper-label';
+var bizFlowEdge = {
+  options: {
+    style: {
+      stroke: '#ccc1d8',
+      lineWidth: 2,
+      shadowColor: null,
+      shadowBlur: 0,
+      radius: 8,
+      offset: 24,
+      // startArrow: {
+      //   path: 'M 3,0 A 3,3,0,1,1,-3,0 A 3,3,0,1,1,3,0 Z',
+      //   d: 7,
+      // },
+      // endArrow: {
+      //   path: 'M 3,0 L -3,-3 L -3,3 Z',
+      //   d: 5,
+      // },
+      endArrow: {
+        path: 'M 0,0 L 4,3 L 4,-3 Z'
+      }
+    },
+    labelCfg: {
+      style: {
+        fill: '#000000',
+        fontSize: 10
+      }
+    },
+    stateStyles: (_stateStyles = {}, _defineProperty(_stateStyles, _constants.ItemState.Selected, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _defineProperty(_stateStyles, _constants.ItemState.HighLight, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _stateStyles)
+  },
+  createLabelWrapper: function createLabelWrapper(group) {
+    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
+    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
+
+    if (!label) {
+      return;
+    }
+
+    if (labelWrapper) {
+      return;
+    }
+
+    group.addShape('rect', {
+      className: EDGE_LABEL_WRAPPER_CLASS_NAME,
+      attrs: {
+        fill: '#e1e5e8',
+        radius: 2
+      }
+    });
+    label.set('zIndex', 1);
+    group.sort();
+  },
+  updateLabelWrapper: function updateLabelWrapper(group) {
+    var label = group.findByClassName(EDGE_LABEL_CLASS_NAME);
+    var labelWrapper = group.findByClassName(EDGE_LABEL_WRAPPER_CLASS_NAME);
+
+    if (!label) {
+      labelWrapper && labelWrapper.hide();
+      return;
+    } else {
+      labelWrapper && labelWrapper.show();
+    }
+
+    if (!labelWrapper) {
+      return;
+    }
+
+    var _label$getBBox = label.getBBox(),
+        minX = _label$getBBox.minX,
+        minY = _label$getBBox.minY,
+        width = _label$getBBox.width,
+        height = _label$getBBox.height;
+
+    labelWrapper.attr({
+      x: minX - 5,
+      y: minY - 3,
+      width: width + 10,
+      height: height + 6
+    });
+  },
+  afterDraw: function afterDraw(model, group) {
+    this.createLabelWrapper(group);
+    this.updateLabelWrapper(group);
+  },
+  afterUpdate: function afterUpdate(model, item) {
+    var group = item.getContainer();
+    this.createLabelWrapper(group);
+    this.updateLabelWrapper(group);
+  },
+  setState: function setState(name, value, item) {
+    var shape = item.get('keyShape');
+
+    if (!shape) {
+      return;
+    }
+
+    var _this$options = this.options,
+        style = _this$options.style,
+        stateStyles = _this$options.stateStyles;
+    var stateStyle = stateStyles[name];
+
+    if (!stateStyle) {
+      return;
+    }
+
+    if (value) {
+      shape.attr(_objectSpread(_objectSpread({}, style), stateStyle));
+    } else {
+      shape.attr(style);
+    }
+  }
+};
+
+_g["default"].registerEdge('bizFlowEdge', bizFlowEdge, 'polyline');
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/edges/bizMindEdge.js b/node_modules/gg-editor/lib/shape/edges/bizMindEdge.js
new file mode 100644
index 0000000..72fea05
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/edges/bizMindEdge.js
@@ -0,0 +1,33 @@
+"use strict";
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _constants = require("../../common/constants");
+
+var _stateStyles;
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var bizMindEdge = {
+  options: {
+    style: {
+      stroke: '#ccc1d8',
+      lineWidth: 2,
+      shadowColor: null,
+      shadowBlur: 0
+    },
+    stateStyles: (_stateStyles = {}, _defineProperty(_stateStyles, _constants.ItemState.Selected, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _defineProperty(_stateStyles, _constants.ItemState.HighLight, {
+      stroke: '#5aaaff',
+      shadowColor: '#5aaaff',
+      shadowBlur: 24
+    }), _stateStyles)
+  }
+};
+
+_g["default"].registerEdge('bizMindEdge', bizMindEdge, 'cubic-horizontal');
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/index.js b/node_modules/gg-editor/lib/shape/index.js
new file mode 100644
index 0000000..3aaf42f
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/index.js
@@ -0,0 +1,11 @@
+"use strict";
+
+require("./nodes/bizNode");
+
+require("./nodes/bizFlowNode");
+
+require("./nodes/bizMindNode");
+
+require("./edges/bizFlowEdge");
+
+require("./edges/bizMindEdge");
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/nodes/bizFlowNode.js b/node_modules/gg-editor/lib/shape/nodes/bizFlowNode.js
new file mode 100644
index 0000000..11886bd
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/nodes/bizFlowNode.js
@@ -0,0 +1,18 @@
+"use strict";
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _anchor = require("../common/anchor");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+var bizFlowNode = {
+  afterSetState: function afterSetState(name, value, item) {
+    _anchor.setAnchorPointsState.call(this, name, value, item);
+  },
+  getAnchorPoints: function getAnchorPoints() {
+    return [[0.5, 0], [0.5, 1], [0, 0.5], [1, 0.5]];
+  }
+};
+
+_g["default"].registerNode('bizFlowNode', bizFlowNode, 'bizNode');
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/nodes/bizMindNode.js b/node_modules/gg-editor/lib/shape/nodes/bizMindNode.js
new file mode 100644
index 0000000..5fda8eb
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/nodes/bizMindNode.js
@@ -0,0 +1,99 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.UNFOLD_BUTTON_CLASS_NAME = exports.FOLD_BUTTON_CLASS_NAME = void 0;
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _utils = require("../utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+var FOLD_BUTTON_CLASS_NAME = 'node-fold-button';
+exports.FOLD_BUTTON_CLASS_NAME = FOLD_BUTTON_CLASS_NAME;
+var UNFOLD_BUTTON_CLASS_NAME = 'node-unfold-button';
+exports.UNFOLD_BUTTON_CLASS_NAME = UNFOLD_BUTTON_CLASS_NAME;
+var bizMindNode = {
+  afterDraw: function afterDraw(model, group) {
+    this.drawButton(model, group);
+  },
+  afterUpdate: function afterUpdate(model, item) {
+    var group = item.getContainer();
+    this.drawButton(model, group);
+    this.adjustButton(model, item);
+  },
+  drawButton: function drawButton(model, group) {
+    var children = model.children,
+        collapsed = model.collapsed;
+    [FOLD_BUTTON_CLASS_NAME, UNFOLD_BUTTON_CLASS_NAME].forEach(function (className) {
+      var shape = group.findByClassName(className);
+
+      if (shape) {
+        shape.destroy();
+      }
+    });
+
+    if (!children || !children.length) {
+      return;
+    }
+
+    if (!collapsed) {
+      group.addShape('path', {
+        className: FOLD_BUTTON_CLASS_NAME,
+        attrs: {
+          path: (0, _utils.getFoldButtonPath)(),
+          fill: '#ffffff',
+          stroke: '#ccc1d8'
+        }
+      });
+    } else {
+      group.addShape('path', {
+        className: UNFOLD_BUTTON_CLASS_NAME,
+        attrs: {
+          path: (0, _utils.getUnfoldButtonPath)(),
+          fill: '#ffffff',
+          stroke: '#ccc1d8'
+        }
+      });
+    }
+  },
+  adjustButton: function adjustButton(model, item) {
+    var children = model.children,
+        collapsed = model.collapsed;
+
+    if (!children || !children.length) {
+      return;
+    }
+
+    var group = item.getContainer();
+    var shape = group.findByClassName(!collapsed ? FOLD_BUTTON_CLASS_NAME : UNFOLD_BUTTON_CLASS_NAME);
+
+    var _this$getSize = this.getSize(model),
+        _this$getSize2 = _slicedToArray(_this$getSize, 2),
+        width = _this$getSize2[0],
+        height = _this$getSize2[1];
+
+    var x = (0, _utils.getNodeSide)(item) === 'left' ? -24 : width + 10;
+    var y = height / 2 - 9;
+    shape.translate(x, y);
+  },
+  getAnchorPoints: function getAnchorPoints() {
+    return [[0, 0.5], [1, 0.5]];
+  }
+};
+
+_g["default"].registerNode('bizMindNode', bizMindNode, 'bizNode');
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/nodes/bizNode.js b/node_modules/gg-editor/lib/shape/nodes/bizNode.js
new file mode 100644
index 0000000..28561a0
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/nodes/bizNode.js
@@ -0,0 +1,230 @@
+"use strict";
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _merge = _interopRequireDefault(require("lodash/merge"));
+
+var _isArray = _interopRequireDefault(require("lodash/isArray"));
+
+var _constants = require("../../common/constants");
+
+var _utils = require("../utils");
+
+var _stateStyles;
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
+
+function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
+
+function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
+
+function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
+
+function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+var WRAPPER_BORDER_WIDTH = 2;
+var WRAPPER_HORIZONTAL_PADDING = 10;
+var WRAPPER_CLASS_NAME = 'node-wrapper';
+var CONTENT_CLASS_NAME = 'node-content';
+var LABEL_CLASS_NAME = 'node-label';
+var bizNode = {
+  options: {
+    size: [120, 60],
+    wrapperStyle: {
+      fill: '#5487ea',
+      radius: 8
+    },
+    contentStyle: {
+      fill: '#ffffff',
+      radius: 6
+    },
+    labelStyle: {
+      fill: '#000000',
+      textAlign: 'center',
+      textBaseline: 'middle'
+    },
+    stateStyles: (_stateStyles = {}, _defineProperty(_stateStyles, _constants.ItemState.Active, {
+      wrapperStyle: {},
+      contentStyle: {},
+      labelStyle: {}
+    }), _defineProperty(_stateStyles, _constants.ItemState.Selected, {
+      wrapperStyle: {},
+      contentStyle: {},
+      labelStyle: {}
+    }), _stateStyles)
+  },
+  getOptions: function getOptions(model) {
+    return (0, _merge["default"])({}, this.options, this.getCustomConfig(model) || {}, model);
+  },
+  draw: function draw(model, group) {
+    var keyShape = this.drawWrapper(model, group);
+    this.drawContent(model, group);
+    this.drawLabel(model, group);
+    return keyShape;
+  },
+  drawWrapper: function drawWrapper(model, group) {
+    var _this$getSize = this.getSize(model),
+        _this$getSize2 = _slicedToArray(_this$getSize, 2),
+        width = _this$getSize2[0],
+        height = _this$getSize2[1];
+
+    var _this$getOptions = this.getOptions(model),
+        wrapperStyle = _this$getOptions.wrapperStyle;
+
+    var shape = group.addShape('rect', {
+      className: WRAPPER_CLASS_NAME,
+      draggable: true,
+      attrs: _objectSpread({
+        x: 0,
+        y: -WRAPPER_BORDER_WIDTH * 2,
+        width: width,
+        height: height + WRAPPER_BORDER_WIDTH * 2
+      }, wrapperStyle)
+    });
+    return shape;
+  },
+  drawContent: function drawContent(model, group) {
+    var _this$getSize3 = this.getSize(model),
+        _this$getSize4 = _slicedToArray(_this$getSize3, 2),
+        width = _this$getSize4[0],
+        height = _this$getSize4[1];
+
+    var _this$getOptions2 = this.getOptions(model),
+        contentStyle = _this$getOptions2.contentStyle;
+
+    var shape = group.addShape('rect', {
+      className: CONTENT_CLASS_NAME,
+      draggable: true,
+      attrs: _objectSpread({
+        x: 0,
+        y: 0,
+        width: width,
+        height: height
+      }, contentStyle)
+    });
+    return shape;
+  },
+  drawLabel: function drawLabel(model, group) {
+    var _this$getSize5 = this.getSize(model),
+        _this$getSize6 = _slicedToArray(_this$getSize5, 2),
+        width = _this$getSize6[0],
+        height = _this$getSize6[1];
+
+    var _this$getOptions3 = this.getOptions(model),
+        labelStyle = _this$getOptions3.labelStyle;
+
+    var shape = group.addShape('text', {
+      className: LABEL_CLASS_NAME,
+      draggable: true,
+      attrs: _objectSpread({
+        x: width / 2,
+        y: height / 2,
+        text: model.label
+      }, labelStyle)
+    });
+    return shape;
+  },
+  setLabelText: function setLabelText(model, group) {
+    var shape = group.findByClassName(LABEL_CLASS_NAME);
+
+    if (!shape) {
+      return;
+    }
+
+    var _this$getSize7 = this.getSize(model),
+        _this$getSize8 = _slicedToArray(_this$getSize7, 1),
+        width = _this$getSize8[0];
+
+    var _shape$attr = shape.attr(),
+        fontStyle = _shape$attr.fontStyle,
+        fontWeight = _shape$attr.fontWeight,
+        fontSize = _shape$attr.fontSize,
+        fontFamily = _shape$attr.fontFamily;
+
+    var text = model.label;
+    var font = "".concat(fontStyle, " ").concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily); //@ts-ignore
+
+    shape.attr(text, (0, _utils.optimizeMultilineText)(text, font, 2, width - WRAPPER_HORIZONTAL_PADDING * 2));
+  },
+  update: function update(model, item) {
+    var group = item.getContainer();
+    this.setLabelText(model, group);
+  },
+  setState: function setState(name, value, item) {
+    var _this = this;
+
+    var group = item.getContainer();
+    var model = item.getModel();
+    var states = item.getStates();
+    [WRAPPER_CLASS_NAME, CONTENT_CLASS_NAME, LABEL_CLASS_NAME].forEach(function (className) {
+      var shape = group.findByClassName(className);
+
+      var options = _this.getOptions(model);
+
+      var shapeName = className.split('-')[1];
+      shape.attr(_objectSpread({}, options["".concat(shapeName, "Style")]));
+      states.forEach(function (state) {
+        if (options.stateStyles[state] && options.stateStyles[state]["".concat(shapeName, "Style")]) {
+          shape.attr(_objectSpread({}, options.stateStyles[state]["".concat(shapeName, "Style")]));
+        }
+      });
+    });
+
+    if (name === _constants.ItemState.Selected) {
+      var wrapperShape = group.findByClassName(WRAPPER_CLASS_NAME);
+
+      var _this$getSize9 = this.getSize(model),
+          _this$getSize10 = _slicedToArray(_this$getSize9, 2),
+          width = _this$getSize10[0],
+          height = _this$getSize10[1];
+
+      if (value) {
+        wrapperShape.attr({
+          x: -WRAPPER_BORDER_WIDTH,
+          y: -WRAPPER_BORDER_WIDTH * 2,
+          width: width + WRAPPER_BORDER_WIDTH * 2,
+          height: height + WRAPPER_BORDER_WIDTH * 3
+        });
+      } else {
+        wrapperShape.attr({
+          x: 0,
+          y: -WRAPPER_BORDER_WIDTH * 2,
+          width: width,
+          height: height + WRAPPER_BORDER_WIDTH * 2
+        });
+      }
+    }
+
+    if (this.afterSetState) {
+      this.afterSetState(name, value, item);
+    }
+  },
+  getSize: function getSize(model) {
+    var _this$getOptions4 = this.getOptions(model),
+        size = _this$getOptions4.size;
+
+    if (!(0, _isArray["default"])(size)) {
+      return [size, size];
+    }
+
+    return size;
+  },
+  getCustomConfig: function getCustomConfig() {
+    return {};
+  },
+  getAnchorPoints: function getAnchorPoints() {
+    return [];
+  }
+};
+
+_g["default"].registerNode('bizNode', bizNode);
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/shape/utils/index.js b/node_modules/gg-editor/lib/shape/utils/index.js
new file mode 100644
index 0000000..d2048fd
--- /dev/null
+++ b/node_modules/gg-editor/lib/shape/utils/index.js
@@ -0,0 +1,138 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.getNodeSide = getNodeSide;
+exports.getRectPath = getRectPath;
+exports.getFoldButtonPath = getFoldButtonPath;
+exports.getUnfoldButtonPath = getUnfoldButtonPath;
+exports.optimizeMultilineText = optimizeMultilineText;
+
+function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+var canvas = document.createElement('canvas');
+var canvasContext = canvas.getContext('2d');
+
+function getNodeSide(item) {
+  var model = item.getModel();
+
+  if (model.side) {
+    return model.side;
+  }
+
+  var parent = item.get('parent');
+
+  if (parent) {
+    return getNodeSide(parent);
+  }
+
+  return 'right';
+}
+
+function getRectPath(x, y, w, h, r) {
+  if (r) {
+    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
+  }
+
+  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']];
+  res.toString = toString;
+  return res;
+}
+
+function getFoldButtonPath() {
+  var w = 14;
+  var h = 14;
+  var rect = getRectPath(0, 0, w, h, 2);
+  var hp = "M".concat(w * 3 / 14, ",").concat(h / 2, "L").concat(w * 11 / 14, ",").concat(h / 2);
+  var vp = '';
+  return rect + hp + vp;
+}
+
+function getUnfoldButtonPath() {
+  var w = 14;
+  var h = 14;
+  var rect = getRectPath(0, 0, w, h, 2);
+  var hp = "M".concat(w * 3 / 14, ",").concat(h / 2, "L").concat(w * 11 / 14, ",").concat(h / 2);
+  var vp = "M".concat(w / 2, ",").concat(h * 3 / 14, "L").concat(w / 2, ",").concat(h * 11 / 14);
+  return rect + hp + vp;
+}
+
+function optimizeMultilineText(text, font, maxRows, maxWidth) {
+  canvasContext.font = font;
+
+  if (canvasContext.measureText(text).width <= maxWidth) {
+    return text;
+  }
+
+  var multilineText = [];
+  var tempText = '';
+  var tempTextWidth = 0;
+
+  var _iterator = _createForOfIteratorHelper(text),
+      _step;
+
+  try {
+    for (_iterator.s(); !(_step = _iterator.n()).done;) {
+      var _char2 = _step.value;
+
+      var _canvasContext$measur2 = canvasContext.measureText(_char2),
+          _width = _canvasContext$measur2.width;
+
+      if (tempTextWidth + _width >= maxWidth) {
+        multilineText.push(tempText);
+        tempText = '';
+        tempTextWidth = 0;
+      }
+
+      tempText += _char2;
+      tempTextWidth += _width;
+    }
+  } catch (err) {
+    _iterator.e(err);
+  } finally {
+    _iterator.f();
+  }
+
+  if (tempText) {
+    multilineText.push(tempText);
+  }
+
+  if (multilineText.length > maxRows) {
+    var ellipsis = '...';
+    var ellipsisWidth = canvasContext.measureText(ellipsis).width;
+    var _tempText = '';
+    var _tempTextWidth = 0;
+
+    var _iterator2 = _createForOfIteratorHelper(multilineText[maxRows - 1]),
+        _step2;
+
+    try {
+      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
+        var _char = _step2.value;
+
+        var _canvasContext$measur = canvasContext.measureText(_char),
+            width = _canvasContext$measur.width;
+
+        if (_tempTextWidth + width > maxWidth - ellipsisWidth) {
+          break;
+        }
+
+        _tempText += _char;
+        _tempTextWidth += width;
+      }
+    } catch (err) {
+      _iterator2.e(err);
+    } finally {
+      _iterator2.f();
+    }
+
+    multilineText = multilineText.slice(0, maxRows - 1).concat("".concat(_tempText).concat(ellipsis));
+  }
+
+  return multilineText.join('\n');
+}
\ No newline at end of file
diff --git a/node_modules/gg-editor/lib/utils/index.js b/node_modules/gg-editor/lib/utils/index.js
new file mode 100644
index 0000000..2b75cca
--- /dev/null
+++ b/node_modules/gg-editor/lib/utils/index.js
@@ -0,0 +1,230 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.guid = guid;
+exports.executeBatch = executeBatch;
+exports.recursiveTraversal = recursiveTraversal;
+exports.isFlow = isFlow;
+exports.isMind = isMind;
+exports.isNode = isNode;
+exports.isEdge = isEdge;
+exports.getSelectedNodes = getSelectedNodes;
+exports.getSelectedEdges = getSelectedEdges;
+exports.getHighlightEdges = getHighlightEdges;
+exports.getGraphState = getGraphState;
+exports.setSelectedItems = setSelectedItems;
+exports.clearSelectedState = clearSelectedState;
+exports.getFlowRecallEdges = getFlowRecallEdges;
+exports.getMindRecallEdges = getMindRecallEdges;
+exports.toQueryString = void 0;
+
+var _g = _interopRequireDefault(require("@antv/g6"));
+
+var _constants = require("../common/constants");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
+
+function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
+
+function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
+
+function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
+
+function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }
+
+function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
+
+function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
+
+/** 生成唯一标识 */
+function guid() {
+  return 'xxxxxxxx'.replace(/[xy]/g, function (c) {
+    var r = Math.random() * 16 | 0;
+    var v = c === 'x' ? r : r & 0x3 | 0x8;
+    return v.toString(16);
+  });
+}
+/** 拼接查询字符 */
+
+
+var toQueryString = function toQueryString(obj) {
+  return Object.keys(obj).map(function (key) {
+    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(obj[key]));
+  }).join('&');
+};
+/** 执行批量处理 */
+
+
+exports.toQueryString = toQueryString;
+
+function executeBatch(graph, execute) {
+  var autoPaint = graph.get('autoPaint');
+  graph.setAutoPaint(false);
+  execute();
+  graph.paint();
+  graph.setAutoPaint(autoPaint);
+}
+/** 执行递归遍历 */
+
+
+function recursiveTraversal(root, callback) {
+  if (!root) {
+    return;
+  }
+
+  callback(root);
+
+  if (!root.children) {
+    return;
+  }
+
+  root.children.forEach(function (item) {
+    return recursiveTraversal(item, callback);
+  });
+}
+/** 判断是否流程图 */
+
+
+function isFlow(graph) {
+  return graph.constructor === _g["default"].Graph;
+}
+/** 判断是否脑图 */
+
+
+function isMind(graph) {
+  return graph.constructor === _g["default"].TreeGraph;
+}
+/** 判断是否节点 */
+
+
+function isNode(item) {
+  return item.getType() === _constants.ItemType.Node;
+}
+/** 判断是否边线 */
+
+
+function isEdge(item) {
+  return item.getType() === _constants.ItemType.Edge;
+}
+/** 获取选中节点 */
+
+
+function getSelectedNodes(graph) {
+  return graph.findAllByState(_constants.ItemType.Node, _constants.ItemState.Selected);
+}
+/** 获取选中边线 */
+
+
+function getSelectedEdges(graph) {
+  return graph.findAllByState(_constants.ItemType.Edge, _constants.ItemState.Selected);
+}
+/** 获取高亮边线 */
+
+
+function getHighlightEdges(graph) {
+  return graph.findAllByState(_constants.ItemType.Edge, _constants.ItemState.HighLight);
+}
+/** 获取图表状态 */
+
+
+function getGraphState(graph) {
+  var graphState = _constants.GraphState.MultiSelected;
+  var selectedNodes = getSelectedNodes(graph);
+  var selectedEdges = getSelectedEdges(graph);
+
+  if (selectedNodes.length === 1 && !selectedEdges.length) {
+    graphState = _constants.GraphState.NodeSelected;
+  }
+
+  if (selectedEdges.length === 1 && !selectedNodes.length) {
+    graphState = _constants.GraphState.EdgeSelected;
+  }
+
+  if (!selectedNodes.length && !selectedEdges.length) {
+    graphState = _constants.GraphState.CanvasSelected;
+  }
+
+  return graphState;
+}
+/** 设置选中元素 */
+
+
+function setSelectedItems(graph, items) {
+  executeBatch(graph, function () {
+    var selectedNodes = getSelectedNodes(graph);
+    var selectedEdges = getSelectedEdges(graph);
+    [].concat(_toConsumableArray(selectedNodes), _toConsumableArray(selectedEdges)).forEach(function (node) {
+      graph.setItemState(node, _constants.ItemState.Selected, false);
+    });
+    items.forEach(function (item) {
+      graph.setItemState(item, _constants.ItemState.Selected, true);
+    });
+  });
+  graph.emit(_constants.EditorEvent.onGraphStateChange, {
+    graphState: getGraphState(graph)
+  });
+}
+/** 清除选中状态 */
+
+
+function clearSelectedState(graph) {
+  var shouldUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
+    return true;
+  };
+  var selectedNodes = getSelectedNodes(graph);
+  var selectedEdges = getSelectedEdges(graph);
+  executeBatch(graph, function () {
+    [].concat(_toConsumableArray(selectedNodes), _toConsumableArray(selectedEdges)).forEach(function (item) {
+      if (shouldUpdate(item)) {
+        graph.setItemState(item, _constants.ItemState.Selected, false);
+      }
+    });
+  });
+}
+/** 获取回溯路径 - Flow */
+
+
+function getFlowRecallEdges(graph, node) {
+  var targetIds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  var edges = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
+  var inEdges = node.getInEdges();
+
+  if (!inEdges.length) {
+    return [];
+  }
+
+  inEdges.map(function (edge) {
+    var sourceId = edge.getModel().source;
+    var sourceNode = graph.findById(sourceId);
+    edges.push(edge);
+    var targetId = node.get('id');
+    targetIds.push(targetId);
+
+    if (!targetIds.includes(sourceId)) {
+      getFlowRecallEdges(graph, sourceNode, targetIds, edges);
+    }
+  });
+  return edges;
+}
+/** 获取回溯路径 - Mind */
+
+
+function getMindRecallEdges(graph, node) {
+  var edges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
+  var parentNode = node.get('parent');
+
+  if (!parentNode) {
+    return edges;
+  }
+
+  node.getEdges().forEach(function (edge) {
+    var sourceId = edge.getModel().source;
+
+    if (sourceId === parentNode.get('id')) {
+      edges.push(edge);
+    }
+  });
+  return getMindRecallEdges(graph, parentNode, edges);
+}
\ No newline at end of file
